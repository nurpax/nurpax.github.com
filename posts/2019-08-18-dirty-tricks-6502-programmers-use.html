<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width">
        <link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Sans+Pro" rel="stylesheet">
        <title>nurpax - Dirty tricks 6502 programmers use</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />

        <link rel="stylesheet" type="text/css" href="../css/syntax2.css" />

        <link rel="alternate" type="application/rss+xml" title="SimpleBlog" href="../rss.xml" />
        
        <meta property="og:image" content="http://nurpax.github.io/images/c64/lines/lines-scroll.gif">
        
        <script src="../js/jquery.min.js" type="text/javascript"></script>
        <script src="../js/jquery.flot.min.js" type="text/javascript"></script>
        

<style>
.narrowlines {
    line-height: 0.9em;
}
.overflow {
	width: 100%;
	overflow-x: auto;
}
.center {
	display: flex;
	flex-direction: column;
	align-items: center;
}
</style>

    </head>
    <body>

    <div id="page-wrap">
        <div id="header">
            <h1>&nbsp;</h1>
        </div>
        <div id="navigation">
             <a href="../">Home</a>
             <a href="../posts.html">All posts</a>
        </div>
        <div id="content">
<article>

<h1>Dirty tricks 6502 programmers use</h1>

<p class="post-author">Janne Hellsten on August 18, 2019</p>

<p>This post recaps some of the C64 coding tricks used in my little <a href="https://twitter.com/nurpax/status/1159192477598965766">Commodore 64 coding competition</a>. The competition rules were simple: make a C64 executable (PRG) that draws two lines to form the below image. The objective was to do this in as few bytes as possible.</p>
<div class="center">
<img width="75%" class="img-pixelated" src="../images/c64/lines/lines-2x.png" />
</div>
<p>Entries were posted as Twitter replies and DMs, containing only the PRG byte-length and an MD5 hash of the PRG file.</p>
<p>Here’s a list of participants with source code links to their submissions:</p>
<ul>
<li><a href="https://twitter.com/fsphil">Philip Heron</a> (<a href="https://github.com/fsphil/tinyx">code</a> - 34 bytes - compo winner)</li>
<li><a href="https://twitter.com/GeirSigmund">Geir Straume</a> (<a href="https://c64prg.appspot.com/downloads/lines34b.zip">code</a> - 34 bytes)</li>
<li><a href="https://twitter.com/petrih3">Petri Häkkinen</a> (<a href="https://github.com/petrihakkinen/c64-lines">code</a> - 37 bytes)</li>
<li><a href="https://twitter.com/laubzega">Mathlev Raxenblatz</a> (<a href="https://gist.github.com/laubzega/fb59ee6a3d482feb509dae7b77e925cf">code</a> - 38 bytes)</li>
<li><a href="https://twitter.com/achrenico">Jan Achrenius</a> (<a href="https://twitter.com/achrenico/status/1161383381835362305">code</a> - 48 bytes)</li>
<li><a href="https://twitter.com/jamie30dbs">Jamie Fuller</a> (<a href="https://github.com/30dbs/c64x">code</a> - 50 bytes)</li>
<li><a href="https://twitter.com/dagershman">David A. Gershman</a> (<a href="http://c64.dagertech.net/cgi-bin/cgiwrap/c64/index.cgi?p=xchallenge/.git;a=tree">code</a> - 53 bytes)</li>
<li><a href="https://twitter.com/nurpax">Janne Hellsten</a> (<a href="https://gist.github.com/nurpax/d429be441c7a9f4a6ceffbddc35a0003">code</a> - 56 bytes)</li>
</ul>
<p>(If I missed someone, please let me know and I’ll update the post.)</p>
<p>The rest of this post focuses on some of the assembly coding tricks used in the compo submissions.</p>
<h3 id="basics">Basics</h3>
<p>The C64 default graphics mode is the 40x25 charset mode. The framebuffer is split into two arrays in RAM:</p>
<ul>
<li><code>$0400</code> (Screen RAM, 40x25 bytes)</li>
<li><code>$d800</code> (Color RAM, 40x25 bytes)</li>
</ul>
<p>To set a character, you store a byte into screen RAM at <code>$0400</code> (e.g., <code>$0400+y*40+x</code>). Color RAM is by default initialized to light blue (color 14) which happens to be the same color we use for the lines – meaning we can leave color RAM untouched.</p>
<p>You can control the border and background colors with memory mapped I/O registers at <code>$d020</code> (border) and <code>$d021</code> (background).</p>
<p>Drawing the two lines is pretty easy as we can hardcode for the fixed line slope. Here’s a C implementation that draws the lines and dumps screen contents on stdout (register writes stubbed out and screen RAM is <code>malloc()</code>’d to make it run on PC):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dump<span class="op">(</span><span class="dt">const</span> <span class="dt">uint8_t</span><span class="op">*</span> screen<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">uint8_t</span><span class="op">*</span> s <span class="op">=</span> screen<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> y <span class="op">&lt;</span> <span class="dv">25</span><span class="op">;</span> y<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++,</span> s<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>s <span class="op">==</span> <span class="bn">0xa0</span> <span class="op">?</span> <span class="ch">'#'</span> <span class="op">:</span> <span class="ch">'.'</span><span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> setreg<span class="op">(</span><span class="dt">uintptr_t</span> dst<span class="op">,</span> <span class="dt">uint8_t</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">//  *((uint8_t *)dst) = v;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">//  uint8_t* screenRAM = (uint_8*)0x0400;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span><span class="op">*</span> screenRAM <span class="op">=</span> <span class="op">(</span><span class="dt">uint8_t</span> <span class="op">*)</span>calloc<span class="op">(</span><span class="dv">40</span><span class="op">*</span><span class="dv">25</span><span class="op">,</span> <span class="bn">0x20</span><span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    setreg<span class="op">(</span><span class="bn">0xd020</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Set border color</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    setreg<span class="op">(</span><span class="bn">0xd021</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Set background color</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yslope <span class="op">=</span> <span class="op">(</span><span class="dv">25</span><span class="op">&lt;&lt;</span><span class="dv">8</span><span class="op">)/</span><span class="dv">40</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yf <span class="op">=</span> yslope<span class="op">/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> yi <span class="op">=</span> yf <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// First line</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        screenRAM<span class="op">[</span>x <span class="op">+</span> yi<span class="op">*</span><span class="dv">40</span><span class="op">]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Second line (X-mirrored)</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        screenRAM<span class="op">[(</span><span class="dv">39</span><span class="op">-</span>x<span class="op">)</span> <span class="op">+</span> yi<span class="op">*</span><span class="dv">40</span><span class="op">]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        yf <span class="op">+=</span> yslope<span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    dump<span class="op">(</span>screenRAM<span class="op">);</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The screen codes used above are: <code>$20</code> (blank) and <code>$a0</code> (8x8 filled block). If you run it, you should see ASCII art for the two lines:</p>
<pre class="narrowlines"><code>##....................................##
..#..................................#..
...##..............................##...
.....#............................#.....
......##........................##......
........##....................##........
..........#..................#..........
...........##..............##...........
.............#............#.............
..............##........##..............
................##....##................
..................#..#..................
...................##...................
..................#..#..................
................##....##................
..............##........##..............
.............#............#.............
...........##..............##...........
..........#..................#..........
........##....................##........
......##........................##......
.....#............................#.....
...##..............................##...
..#..................................#..
##....................................##</code></pre>
<p>Using 6502 assembly and assembly pseudos, we can trivially implement the same in assembly:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>!<span class="bu">include</span> <span class="st">&quot;c64.asm&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>+c64<span class="op">::</span>basic_start<span class="op">(</span>entry<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">entry:</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span>      <span class="co">; black color</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d020   <span class="co">; set border to 0</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d021   <span class="co">; set background to 0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">; clear the screen</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    ldx <span class="op">#</span><span class="dv">0</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#$</span><span class="bn">20</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="fu">clrscr:</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>!for i in <span class="op">[</span><span class="dv">0</span><span class="op">,</span> <span class="op">$</span><span class="bn">100</span><span class="op">,</span> <span class="op">$</span><span class="bn">200</span><span class="op">,</span> <span class="op">$</span><span class="bn">300</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> i<span class="op">,</span> x</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    inx</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    bne clrscr</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">; line drawing, completely unrolled</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">; with assembly pseudos</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#$</span>a0</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    !for i in range<span class="op">(</span><span class="dv">40</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        !let y0 <span class="op">=</span> Math<span class="op">.</span>floor<span class="op">(</span><span class="dv">25</span><span class="op">/</span><span class="dv">40</span><span class="op">*(</span>i<span class="op">+</span><span class="fl">0.5</span><span class="op">))</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> y0<span class="op">*</span><span class="dv">40</span> <span class="op">+</span> i</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="op">(</span><span class="dv">24</span><span class="op">-</span>y0<span class="op">)*</span><span class="dv">40</span> <span class="op">+</span> i</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span> <span class="cf">jmp</span> inf  <span class="co">; halt</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This completely unrolls the line drawing part resulting in a fairly large 286 byte PRG.</p>
<p>Before diving into optimized variants, let’s make a couple of observations:</p>
<p>First, we’re running on the C64 with the ROM routines banked in. There’s a bunch of subroutines in ROM that may be useful for our little program. For example, you can clear the screen with <code>JSR $E544</code>.</p>
<p>Second, address calculations on an 8-bit CPU like the 6502 can be cumbersome and cost a lot of bytes. This CPU also doesn’t have a multiplier, so computing something like <code>y*40+i</code> usually involves either a bunch of logical shifts or a lookup table, again costing bytes. To avoid multiplying by 40, we can instead advance the screen pointer incrementally:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yslope <span class="op">=</span> <span class="op">(</span><span class="dv">25</span><span class="op">&lt;&lt;</span><span class="dv">8</span><span class="op">)/</span><span class="dv">40</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yf <span class="op">=</span> yslope<span class="op">/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span><span class="op">*</span> dst <span class="op">=</span> screenRAM<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        dst<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        dst<span class="op">[(</span><span class="dv">39</span><span class="op">-</span>x<span class="op">)]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        yf <span class="op">+=</span> yslope<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>yf <span class="op">&amp;</span> <span class="dv">256</span><span class="op">)</span> <span class="op">{</span> <span class="co">// Carry set?</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            dst <span class="op">+=</span> <span class="dv">40</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            yf <span class="op">&amp;=</span> <span class="dv">255</span><span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>We keep adding the line slope to a fixed point counter <code>yf</code> and when the 8-bit addition sets the carry flag, add 40.</p>
<p>Here’s the incremental approach implemented in assembly:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>!<span class="bu">include</span> <span class="st">&quot;c64.asm&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>+c64<span class="op">::</span>basic_start<span class="op">(</span>entry<span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>!let screenptr <span class="op">=</span> <span class="op">$</span><span class="bn">20</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>!let x0 <span class="op">=</span> <span class="op">$</span><span class="bn">40</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>!let x1 <span class="op">=</span> <span class="op">$</span><span class="bn">41</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>!let yf <span class="op">=</span> <span class="op">$</span><span class="bn">60</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="fu">entry:</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        sta x0</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span>d020</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span>d021</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">; kernal clear screen</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e544</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">; set screenptr = $0400</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&lt;$</span><span class="bn">0400</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">0</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&gt;$</span><span class="bn">0400</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">80</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        ldy x0</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">; screenRAM[x] = 0xA0</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">(</span>screenptr<span class="op">),</span> y</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        ldy x1</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">; screenRAM[39-x] = 0xA0</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">(</span>screenptr<span class="op">),</span> y</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">clc</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">160</span>  <span class="co">; line slope</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        bcc no_add</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">; advance screen ptr by 40</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">clc</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        lda screenptr</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">40</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>        sta screenptr</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        lda screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a><span class="fu">no_add:</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> x0</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        bpl xloop</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    <span class="cf">jmp</span> inf</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>At 82 bytes, this is still pretty hefty. A couple of obvious size problems arise from 16-bit address computations:</p>
<p>Setting up the <code>screenptr</code> value for indirect-indexed addressing:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">; set screenptr = $0400</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&lt;$</span><span class="bn">0400</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&gt;$</span><span class="bn">0400</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span></code></pre></div>
<p>Advancing <code>screenptr</code> to the next row by adding 40:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">; advance screen ptr by 40</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">clc</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        lda screenptr</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">40</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        sta screenptr</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        lda screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span></code></pre></div>
<p>Sure this code could probably be made smaller but what if we didn’t need manipulate 16-bit addresses in the first place? Let’s see this can be avoided.</p>
<h3 id="trick-1-scrolling">Trick 1: Scrolling!</h3>
<p>Instead of plotting the line across the screen RAM, we draw only on the last Y=24 screen row, and scroll the whole screen up by calling a “scroll up” ROM function with <code>JSR $E8EA</code>!</p>
<p>The x-loop becomes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        sta x0</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        ldx x0</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">; hardcoded absolute address to last screen line</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        bcc no_scroll</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">; scroll screen up!</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e8ea</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="fu">no_scroll:</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> x0</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        bpl xloop</span></code></pre></div>
<p>Here’s how the line renderer progresses with this trick:</p>
<div class="center">
<img width="75%" class="img-pixelated" src="../images/c64/lines/lines-scroll.gif" />
</div>
<p>This trick was one of my favorites in this compo. It was also independently discovered by pretty much every participant.</p>
<h3 id="trick-2-self-modifying-code">Trick 2: Self-modifying code</h3>
<p>The code to store the pixel values ends up being roughly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">; hardcoded absolute address to last screen line</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        ldx x0</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> x0</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span></code></pre></div>
<p>This encodes into the following 14 byte sequence:</p>
<pre><code>0803: A6 22               LDX $22
0805: 9D C0 07            STA $07C0,X
0808: A6 20               LDX $20
080A: 9D C0 07            STA $07C0,X
080D: E6 22               INC $22
080F: C6 20               DEC $20</code></pre>
<p>There’s a more compact way to write this using self-modifying code (SMC)..</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">addr0:</span>  sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">; advance the second x-coord with SMC</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> addr0<span class="op">+</span><span class="dv">1</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span></code></pre></div>
<p>..which encodes to 13 bytes:</p>
<pre><code>0803: A6 22               LDX $22
0805: 9D C0 07            STA $07C0,X
0808: 8D C0 07            STA $07C0
080B: EE 09 08            INC $0809
080E: C6 22               DEC $22</code></pre>
<h3 id="trick-3-exploiting-the-power-on-state">Trick 3: Exploiting the power on state</h3>
<p>Making wild assumptions about the running environment was considered OK in this compo: the line drawing PRG is the first thing that’s run after C64 power on, and there was no requirement to exit cleanly back to the BASIC prompt. So anything you find from the initial environment upon entry to your PRG, you can and should use to your advantage. Here are some of the things that were considered “constant” upon entry to the PRG:</p>
<ul>
<li>A, X, Y registers were assumed to be all zeros</li>
<li>All CPU flags cleared</li>
<li>Zeropage (addresses <code>$00</code>-<code>$ff</code>) contents</li>
</ul>
<p>Similarly, if you called any KERNAL ROM routines, you could totally take advantage of any side-effects they might have: returned CPU flags, temporary values set into zeropage, etc.</p>
<p>After the first few size-optimization passes, everyone turned their eyes on this machine monitor view to look for any interesting values:</p>
<div class="center overflow">
<img class="img-pixelated" src="../images/c64/lines/monitor-screenshot.png" />
</div>
<p>The zeropage indeed contains some useful values for our purposes:</p>
<ul>
<li><code>$d5</code>: 39/$27 == line length - 1</li>
<li><code>$22</code>: 64/$40 == initial value for line slope counter</li>
</ul>
<p>You can use these to shave off a few bytes at init time. For example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>!let x0 <span class="op">=</span> <span class="op">$</span><span class="bn">20</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span>      <span class="co">; 0801: A9 27    LDA #$27</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        sta x0       <span class="co">; 0803: 85 20    STA $20</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x0       <span class="co">; 0805: C6 20    DEC $20</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        bpl xloop    <span class="co">; 0807: 10 FC    BPL $0805</span></span></code></pre></div>
<p>As <code>$d5</code> contains a value 39, you can map your <code>x0</code> counter to point to <code>$d5</code> and skip the LDA/STA pair:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>!let x0 <span class="op">=</span> <span class="op">$</span>d5</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">; nothing here!</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x0       <span class="co">; 0801: C6 D5    DEC $D5</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        bpl xloop    <span class="co">; 0803: 10 FC    BPL $0801</span></span></code></pre></div>
<p>Philip’s <a href="https://github.com/fsphil/tinyx/blob/master/x34/x34.s">winning entry</a> takes this to the extreme. Recall the address of the last char row <code>$07C0</code> (==<code>$0400+24*40</code>). This value does not exist in the zeropage on init. However, as a side-effect of how the ROM “scroll up” subroutine uses zeropage temporaries, addresses <code>$D1-$D2</code> will contain <code>$07C0</code> on return from this function. So instead of <code>STA $07C0,x</code> to store a pixel, you can use the one byte shorter indirect-indexed addressing mode store <code>STA ($D1),y</code>.</p>
<h3 id="trick-4-smaller-startup">Trick 4: Smaller startup</h3>
<p>A typical C64 PRG binary file contains the following:</p>
<ul>
<li>First 2 bytes: loading address (usually <code>$0801</code>)</li>
<li>12 bytes of BASIC startup sequence</li>
</ul>
<p>The BASIC startup sequence looks like this (addresses <code>$801-$80C</code>):</p>
<pre><code>0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00
080D: 8D 20 D0     STA $D020</code></pre>
<p>Without going into details about <a href="https://www.c64-wiki.com/wiki/BASIC_token">tokenized BASIC memory layout</a>, this sequence more or less amounts to “10 SYS 2061”. Address <code>2061</code> (<code>$080D</code>) is where our actual machine code program starts when the BASIC interpreter executes the SYS command.</p>
<p>14 bytes just to get going feels excessive. Philip, Mathlev and Geir had used some clever tricks to get rid of the BASIC sequence altogether. This requires that the PRG is loaded with <code>LOAD "*",8,1</code> as <code>LOAD "*",8</code> ignores the PRG loading address (the first two bytes) and always loads to <code>$0801</code>.</p>
<div class="center">
<img width="75%" class="img-pixelated" src="../images/c64/lines/vice-screen-sys.png" />
</div>
<p>Two methods were used:</p>
<ul>
<li>The stack trick</li>
<li>The BASIC warm reset vector trick</li>
</ul>
<h4 id="the-stack-trick">The stack trick</h4>
<p>The trick is to stomp the CPU stack at <code>$01F8</code> with a value that points to our desired entry point. This is done by crafting a PRG that starts with a 16-bit pointer pointing to our code and loading the PRG into <code>$01F8</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    * = $01F8</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    !<span class="dt">word</span> scroll <span class="op">-</span> <span class="dv">1</span>  <span class="co">; overwrite stack</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">scroll:</span>	jsr <span class="op">$</span>E8EA</span></code></pre></div>
<p>Once the BASIC loader (see <a href="https://www.pagetable.com/c64disasm/#F4A5">disassembly</a>) has finished loading and returns to its caller with <code>RTS</code>, instead of returning to whoever called LOAD, it returns right into our PRG.</p>
<h4 id="the-basic-warm-reset-vector-trick">The BASIC warm reset vector trick</h4>
<p>This is a little easier to explain by just looking at the PRG disassembly.</p>
<pre><code>02E6: 20 EA E8    JSR $E8EA
02E9: A4 D5       LDY $D5
02EB: A9 A0       LDA #$A0
02ED: 99 20 D0    STA $D020,Y
02F0: 91 D1       STA ($D1),Y
02F2: 9D B5 07    STA $07B5,X
02F5: E6 D6       INC $D6
02F7: 65 90       ADC $90
02F9: 85 90       STA $90
02FB: C6 D5       DEC $D5
02FD: 30 FE       BMI $02FD
02FF: 90 E7       BCC $02E8
0301: 4C E6 02    JMP $02E6</code></pre>
<p>Notice the last line (<code>JMP $02E6</code>). The JMP instruction starts at address <code>$0301</code> with the branch target stored in addresses <code>$0302-$0303</code>.</p>
<p>When this code is loaded into memory starting at address <code>$02E6</code>, a value of <code>$02E6</code> is written to addresses <code>$0302-$0303</code>. Well, location <code>$0302-$0303</code> has a special meaning: it contains a pointer to the “BASIC idle loop” (see <a href="http://sta.c64.org/cbm64mem.html">C64 memory map</a> for details). Loading the PRG overwrote this location with <code>$02E6</code> and so when the BASIC interpreter tries to jump to the idle loop after warm reset, it never enters the idle loop but instead ends up in the line renderer!</p>
<h4 id="other-basic-startup-related-tricks">Other BASIC startup related tricks</h4>
<p>Petri had discovered <a href="https://github.com/petrihakkinen/c64-lines/blob/master/main37.asm">another BASIC start trick</a> which allows injecting your own constants into the zeropage. In this method, you hand-craft your own tokenized BASIC start sequence and encode your constants into the BASIC program line number. The BASIC line number, ahem, your constants, will be stored in addresses <code>$39-$3A</code> upon entry. Very clever!</p>
<h3 id="trick-5-unconventional-control-flow">Trick 5: Unconventional control flow</h3>
<p>Here’s a somewhat simplified version of the x-loop that draws only a single line and then halts execution once the line is done:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        bcc no_scroll</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">; scroll screen up!</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e8ea</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="fu">no_scroll:</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        bpl xloop</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">; intentionally halt at the end</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    <span class="cf">jmp</span> inf</span></code></pre></div>
<p>This has a bug in it, though. When we’ve drawn the last pixel of a line, we should NOT scroll the screen up anymore. Thus we need more branching to skip scrolling on the last pixel write:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">; skip scrolling if last pixel</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        bmi done</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        bcc no_scroll</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">; scroll screen up!</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e8ea</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="fu">no_scroll:</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">jmp</span> xloop</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="fu">done:</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">; intentionally halt at the end</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    <span class="cf">jmp</span> inf</span></code></pre></div>
<p>The control flow looks a lot like what a C compiler would output from a structured program. The code to skip the last scroll introduced a new <code>JMP abs</code> instruction that takes up 3 bytes. Conditional branches are only two bytes as they encode the branch target using a relative 8-bit immediate.</p>
<p>The “skip last scroll” JMP can be avoided by moving the scroll up call to the top of the loop, and restructuring the control flow a bit. This is the pattern Philip had come up with:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">scroll:</span> jsr <span class="op">$</span>e8ea</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1     <span class="co">; doesn't set carry!</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    bmi inf    <span class="co">; hang here if last pixel!</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        bcc xloop  <span class="co">; next pixel if no scroll</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        bcs scroll <span class="co">; scroll up and continue</span></span></code></pre></div>
<p>This completely eliminates one 3 byte JMP and converts another JMP to a 2 byte conditional branch, saving 4 bytes in total.</p>
<h3 id="trick-6-bitpacked-line-drawing">Trick 6: Bitpacked line drawing</h3>
<p>Some of the entries didn’t use a line slope counter but rather they had bit-packed the line pattern into an 8-bit constant. This packing comes out of a realisation that the pixel position along the line follows a repeating 8 pixel pattern:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mask <span class="op">=</span> <span class="bn">0xB6</span><span class="op">;</span> <span class="co">// 10110110</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">uint8_t</span><span class="op">*</span> dst <span class="op">=</span> screenRAM<span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    dst<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="bn">0xA0</span><span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>x<span class="op">&amp;</span><span class="dv">7</span><span class="op">)))</span> <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        dst <span class="op">+=</span> <span class="dv">40</span><span class="op">;</span> <span class="co">// go down a row</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This translates to pretty compact assembly. The slope counter variants tended to be even smaller, though.</p>
<h3 id="winner-entry">Winner entry</h3>
<p>This is the <a href="https://github.com/fsphil/tinyx/blob/master/x34/x34.s">winning 34 byte entry</a> from Philip. Most of the above really comes together nicely in his code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>ov <span class="op">=</span> <span class="op">$</span><span class="bn">22</span> <span class="co">; == $40, initial value for the overflow counter</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>ct <span class="op">=</span> <span class="op">$</span>D5 <span class="co">; == $27 / 39, number of passes. Decrementing, finished at -1</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>lp <span class="op">=</span> <span class="op">$</span>D1 <span class="co">; == $07C0, pointer to bottom line. Set by the kernal scroller</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">; Overwrite the return address of the kernal loader on the stack</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">; with a pointer to our own code</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        * = $01F8</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        .<span class="dt">word</span> scroll <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="fu">scroll:</span> jsr <span class="op">$</span>E8EA    <span class="co">; Kernal scroll up, also sets lp pointer to $07C0</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="fu">loop:</span>   ldy ct	     <span class="co">; Load the decrementing counter into Y (39 &gt; -1)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>A0     <span class="co">; Load the PETSCII block / black col / ov step value</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span>D020<span class="op">,</span> y <span class="co">; On the last two passes, sets the background black</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="fu">p1:</span>     sta <span class="op">$</span><span class="bn">07C0</span>    <span class="co">; Draw first block (left &gt; right line)</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">(</span>lp<span class="op">),</span> y  <span class="co">; Draw second block (right &gt; left line)</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> p1 <span class="op">+</span> <span class="dv">1</span>   <span class="co">; Increment pointer for the left &gt; right line</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> ov	     <span class="co">; Add step value $A0 to ov</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        sta ov</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> ct	     <span class="co">; Decrement the Y counter</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        bmi <span class="op">*</span>	     <span class="co">; If it goes negative, we're finished</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        bcc loop     <span class="co">; Repeat. If ov didn't overflow, don't scroll</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        bcs scroll   <span class="co">; Repeat. If ov overflowed, scroll</span></span></code></pre></div>
<h3 id="why-stop-at-34-bytes-though">Why stop at 34 bytes, though?</h3>
<p>Once the competition was over, everyone shared code and notes, and a number of lively conversations took place on how to do even better. Several smaller variants were posted after the deadline:</p>
<ul>
<li><a href="https://gist.github.com/fsphil/05deaa06804b9b2054260b616cafed4b">Philip - 33 bytes</a></li>
<li><a href="https://gist.github.com/fsphil/01bda1a9dd58c219002ddd6e18b36c3f">Philip - 32 bytes</a></li>
<li><a href="https://github.com/petrihakkinen/c64-lines/blob/master/main31.asm">Petri - 31 bytes</a></li>
<li><a href="https://gist.github.com/fsphil/7655a394ec5f953c910e9d9369dced56">Philip - 29 bytes</a></li>
</ul>
<p>You should check them out – there are some real gems to be found.</p>
<p>…</p>
<p>Thanks for reading. And most of all, thanks Mathlev, Phil, Geir, Petri, Jamie, Jan and David for your participation. (I hope I didn’t miss anyone – it was really difficult to keep track of these in Twitter mentions!)</p>
<p>PS. Petri had named my compo “<span class="citation" data-cites="nurpax">@nurpax</span>’s annual C64 size optimization compo”, so uhm, see you next year, I guess.</p>


</article>


        </div>
        <div id="footer">
          <p>Like what you saw here?  Suggestions, improvements?</p>
          <p>Get in touch: jjhellst@gmail.com or <a href="https://twitter.com/nurpax">@nurpax</a></p>
        </div>
    </div>


    </body>
</html>
