<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width">
        <title>nurpax - Break down of a C64 demo effect</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/rss+xml" title="SimpleBlog" href="../rss.xml" />
        
        <meta property="og:image" content="http://nurpax.github.io/images/c64/sine/sinewave-gifanim-2018-05-31.gif">
        
        <script src="../js/jquery.min.js" type="text/javascript"></script>
        <script src="../js/jquery.flot.min.js" type="text/javascript"></script>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37082285-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    </head>
    <body>

    <div id="page-wrap">
        <div id="header">
            <h1>&nbsp;</h1>
        </div>
        <div id="navigation">
             <a href="../">Home</a>
             <a href="../posts.html">All posts</a>
        </div>
        <div id="content">
<article>

<h1>Break down of a C64 demo effect</h1>

<p class="post-author">Janne Hellsten on June  5, 2018</p>

<p>So I recently made this little sinewave demo effect on the Commodore 64:</p>
<p><img class="img-pixelated img-medium-wide" src="../images/c64/sine/sinewave-gifanim-2018-05-31.gif" /></p>
<p>This generated a lot of lively discussion on <a href="https://twitter.com/nurpax/status/1002288831511580672">twitter</a> and <a href="https://www.reddit.com/r/c64/comments/8o9aoh/some_charset_hacking_from_last_week/">/r/c64</a>. A bunch of people were curious as to how it works and I promised to explain it on my blog.</p>
<p>Here comes the first spoiler: it’s character mode rendering with a custom charset. The below gif should make this pretty obvious:</p>
<p><img class="img-pixelated img-medium-wide" src="../images/c64/sine/sinewave-sans-charset.gif" /></p>
<p>The sine wave animates pretty slowly and never goes above a certain frequency. This property can be exploited in a number of ways.</p>
<p>The first trick is to sample the sine wave only at every 8th pixel and drawing a straight line between the two points. Here’s a side-by-side comparison between a relatively low frequency wave and a high frequency version where the line approximation breaks down:</p>
<div class="img-columns-2">
<img class="img-column" src="../images/c64/sine/sinewave-line-low-freq.gif" /><img class="img-column" src="../images/c64/sine/sinewave-line-high-freq.gif" />
</div>
<p>If you had a fast polygon fill routine, here’s how you might render the sine wave in Python:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co"># Compute sine wave by stepping every 8th pixel</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">ypos <span class="op">=</span> [sinewave(phase, x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">+</span> <span class="dv">8</span>, <span class="dv">8</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co"># Loop through each line segment</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    x0 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    x1 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span> <span class="op">+</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    y0 <span class="op">=</span> ypos[x]</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    y1 <span class="op">=</span> ypos[x <span class="op">+</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="co"># Fill everything below the (x0,y0)-(x1,y1) line segment</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="co"># with LIGHT_BLUE</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    fill_polygon([(x0, y0), (x1, y1), (x1, <span class="dv">200</span>), (x0, <span class="dv">200</span>)], LIGHT_BLUE)</a></code></pre></div>
<!-- TODO this needs to explain how the line can intersect the 8x8 blocks. -->
<p>Well, no such thing as a fast polygon fill routine on the C64. So I use character mode rendering instead. With the right LUTs and the right character set, the Python code for the renderer would look something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">subpix <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">def</span> draw_fills(ypos):</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="cf">for</span> xi <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">        x <span class="op">=</span> xi <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        y0 <span class="op">=</span> <span class="bu">int</span>((ypos[xi] <span class="op">*</span> subpix))</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        y1 <span class="op">=</span> <span class="bu">int</span>((ypos[xi <span class="op">+</span> <span class="dv">1</span>] <span class="op">*</span> subpix))</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        yy0 <span class="op">=</span> y0 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">        yy1 <span class="op">=</span> y1 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        y0 <span class="op">-=</span> yy0</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        y1 <span class="op">-=</span> yy0</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">        chrs <span class="op">=</span> fill_tbl[y0][y1 <span class="op">-</span> y0 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix]</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">-</span> <span class="dv">8</span>, chrs[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">        blit_8x8(x, yy0 <span class="op">/</span> subpix, chrs[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">+</span> <span class="dv">8</span>, chrs[<span class="dv">2</span>])</a></code></pre></div>
<p>To pre-calculate <code>fill_tbl</code>, I exhaustively rasterize all the different combinations that a line segment can cross three vertically stacked 8x8 blocks (characters). Any pixels above the segment are set to zero, anything below the segment to one. The <code>subpix</code> constant controls how many bits of subpixel accuracy the rasterizer uses. Here’s the code to the block fill pattern rasterizer:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">def</span> mk8x8(yoffs, a, b, c):</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    arr <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">8</span>)]</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        yy <span class="op">=</span> (y <span class="op">+</span> yoffs) <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">            xx <span class="op">=</span> x <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">            <span class="cf">if</span> a <span class="op">*</span> xx <span class="op">+</span> b <span class="op">*</span> yy <span class="op">+</span> c <span class="op">&gt;=</span> <span class="fl">0.0</span>:</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">                arr[x <span class="op">+</span> y <span class="op">*</span> <span class="dv">8</span>] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="cf">return</span> arr</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">def</span> construct_fill_table():</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    x0 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    x1 <span class="op">=</span> <span class="dv">8</span> <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    fill_tbl <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> subpix)]</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    <span class="cf">for</span> y0 <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix):</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">        fill_tbl[y0] <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix)]</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">        <span class="cf">for</span> yi1 <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">4</span> <span class="op">*</span> subpix, <span class="dv">4</span> <span class="op">*</span> subpix):</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">            y1 <span class="op">=</span> y0 <span class="op">+</span> yi1</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">            a <span class="op">=</span> <span class="op">-</span>(y1 <span class="op">-</span> y0)</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">            b <span class="op">=</span> (x1 <span class="op">-</span> x0)</a>
<a class="sourceLine" id="cb3-22" data-line-number="22">            c <span class="op">=</span> <span class="op">-</span>(a <span class="op">*</span> x0 <span class="op">+</span> b <span class="op">*</span> y0)</a>
<a class="sourceLine" id="cb3-23" data-line-number="23">            fill_tbl[y0][yi1 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix] <span class="op">=</span> [mk8x8(<span class="op">-</span><span class="dv">8</span>, a, b, c), mk8x8(<span class="dv">0</span>, a, b, c), mk8x8(<span class="dv">8</span>, a, b, c)]</a>
<a class="sourceLine" id="cb3-24" data-line-number="24">    <span class="cf">return</span> fill_tbl</a></code></pre></div>
<p>Note that in the above code, each entry in the <code>fill_tbl</code> 2d-array is a list 3 character bitmaps. A character bitmap is a 64 entry list of zeros and ones. To make use of this on the C64, you need to turn this data into two separate arrays: the actual character set and an array indexed by <span class="math inline"><em>y</em>0</span>, <span class="math inline"><em>y</em>1</span> that returns a list of 3 character indices.</p>
<p>The resulting character looks like so:</p>
<p><img class="img-pixelated img-small" src="../images/c64/sine/charset-16x16.png" /></p>
<p>The char index table looks like this (<code>$20</code> is the space character, ie., an empty block, <code>$a0</code> is a fully filled 8x8 block):</p>
<pre><code>y0y1tbl:
    .byte $00, $a0, $a0, $a0
    .byte $02, $0e, $a0, $a0
    .byte $0f, $10, $a0, $a0
    .byte $1b, $24, $a0, $a0
... 252 more entries ...</code></pre>
<p>Since I have full control over the sine animation, I choose animation parameters that make the line segments behave “nicely”. Niceness is defined as follows: let <span class="math inline">(<em>x</em>0, <em>y</em>0)</span> and <span class="math inline">(<em>x</em>0 + 8, <em>y</em>1)</span> be the end points of a line segment. The segment behaves “nicely” if it satisfies the following condition: <span class="math inline">|<em>y</em>0 − <em>y</em>1| &lt; <em>c</em></span> (where <span class="math inline"><em>c</em></span> is some small number, in my case 8). This is required in order to keep the <code>fill_tbl</code> at a reasonable size and to limit the number of unique 8x8 characters (since the hardware character set is only 256 entries).</p>
<p>Here are a couple of animations that demonstrate how the rendering process works. The left image just shows how the 40x25 character blocks (gray grid) intersect with the sine wave line segments. The right image shows how different line segments get rasterized into a vertical stack of 3 characters.</p>
<div class="sine-columns-2">
<img class="sine-column-1" src="../images/c64/sine/sinewave-block-cover.gif" /><img class="img-pixelated sine-column-2" src="../images/c64/sine/sinewave-fill-closeup.gif" />
</div>


</article>


        </div>
        <div id="footer">
          <p>Like what you saw here?  Suggestions, improvements?</p>
          <p>Get in touch: jjhellst@gmail.com or <a href="https://twitter.com/nurpax">@nurpax</a></p>
        </div>
    </div>


    </body>
</html>
