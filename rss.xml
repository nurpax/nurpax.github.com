<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>nurpax.github.com blog</title>
    <link href="http://nurpax.github.com/rss.xml" rel="self" />
    <link href="http://nurpax.github.com" />
    <id>http://nurpax.github.com/rss.xml</id>
    <author>
        <name>Janne Hellsten</name>
        <email>jjhellst@gmail.com</email>
    </author>
    <updated>2018-11-08T00:00:00Z</updated>
    <entry>
    <title>C64jasm - a new take on C64 macro assembling</title>
    <link href="http://nurpax.github.com/posts/2018-11-08-c64jasm.html" />
    <id>http://nurpax.github.com/posts/2018-11-08-c64jasm.html</id>
    <published>2018-11-08T00:00:00Z</published>
    <updated>2018-11-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>For the past couple of months I’ve worked on the C64 <a href="https://csdb.dk/release/?id=171134">VISIO 2018 invitation intro</a> (YouTube capture at the bottom of this post). I upped the difficulty level a bit by first designing and implementing a new 6502 macro assembler called <a href="https://github.com/nurpax/c64jasm">c64jasm</a>, and then using that to develop my demo. While I haven’t had the time to polish the assembler to, say, KickAssembler level, my tool turned out to be a real joy to work with. This post highlights some of its features that I believe make it somewhat unique in its small niche.</p>
<p>These were my initial design choices for c64jasm:</p>
<ul>
<li>Written in TypeScript &amp; running on Node. Easy multi-platform environment with easy to install dependencies.</li>
<li>Ability to extend the assembler’s functionality by calling into user-defined JavaScript modules directly from the .asm source.</li>
<li>A sufficiently powerful pseudo language (macros, conditionals, for-loops, etc) but build on the JavaScript extension mechanism for more complex pseudo ops like LUT creation and file format parsing.</li>
<li>Node-style “watch” support: automatically recompile if any source files change. Design it for efficiency.</li>
<li>VSCode integration (for on-the-fly compilation and error reporting within the IDE, launch output binary in VICE.)</li>
</ul>
<p>The choice of TypeScript was very deliberate. I’ve been meaning to learn the language for quite some time, and developing a macro assembler in it was a good way to learn &amp; evaluate TypeScript. TypeScript turned out to be a great language: supports functional programming style well (and so well-suited for developing compilers) and has a simple but powerful static typing system.</p>
<p>The assembler extension mechanism is the main feature that differentiates c64jasm from traditional 6502 macro assemblers and I’ll spend the rest of this blog talking about this mechanism.</p>
<p>This blog post assumes that you’re at least somewhat familiar with macro assemblers and that you know a bit of JavaScript.</p>
<h2 id="why-do-i-need-to-extend-my-assembler">Why do I need to extend my assembler?</h2>
<p>So why does one need to extend the assembler in the first place? I have my assembly, macros and other pseudo directives, isn’t this enough? Well, you need all of these too. But some things like loading graphics files, generating lookup tables, etc. can be better expressed in a real programming language. Quite commonly a demo project is built using a build script that processes LUTs, graphics, and other assets into hex listings to be included in the main assembly source.</p>
<h2 id="extending-functionality">Extending functionality</h2>
<p>Traditionally, extending the functionality of an application or a tool means that you’d first need to learn the app’s extension API, figure out how to build your extension (say .DLLs or a Java .jar file), install it (and maybe debug your PATH or CLASSPATH when it fails to load), and once all done, the feature becomes available in your tool and you use it to develop your content.</p>
<p>The approach I took in c64jasm is that assembler extensions are just a bunch of source files in your project’s source directory. Extensions shouldn’t require a separate build or installation step and the overhead of creating a new one for any specific purpose should be minimal. Ideally the extensions should be runnable stand-alone without the assembler and that you should be able to debug and test them using standard debugging tools.</p>
<p>Before we get deeper into c64jasm assembler plugins, let’s review some of the c64jasm pseudo directives.</p>
<h2 id="c64jasm-pseudo-ops">C64jasm pseudo ops</h2>
<p>If you’ve used something like KickAssembler, ACME or 64tass, these should look pretty familiar.</p>
<p>Declaring pseudo variables: You can declare pseudo variables using <code>!let</code>. This is basically the same as KickAssembler’s <code>.const</code>/<code>.var</code> (many other assemblers commonly have this as <code>EQU</code>.)</p>
<pre><code>; declaring variables
!let after_bounce_frames = 64
!let sprite_writer_path_tablen = 128

; assigning a new value to a previously declared variable
after_bounce_frames = 33

; using the variables in immediates
    sec
    sbc #sprite_writer_path_tablen
    cmp #after_bounce_frames
    bcs do_wrap
    jmp no_wrap
do_wrap:
    jmp wrap</code></pre>
<p>Macros:</p>
<pre><code>some_mem_loc: !byte 0

; declare a macro to write an immediate value to memory
!macro mov8imm(d, imm) {
    lda #imm
    sta d+0
}
; expand the macro
+mov8imm(some_mem_loc, #$80)

; this will emit the following code:
;
;    lda #$80
;    sta some_mem_loc</code></pre>
<p>Symbols declared within a macro are local to that macro. You can also declare macros within macros.</p>
<p>If/elif/else:</p>
<pre><code>!let double_y = 1
!if (double_y) {            
    ldy #yy*6+1         ; code from this path
    sta (zpdst_even),y  ; will be emitted
    sta (zpdst_odd),y
    txa
    dey
    sta (zpdst_even),y
    sta (zpdst_odd),y
} else {
    ldy #yy*3+1
    sta (zpdst_even),y
    txa
    dey
    sta (zpdst_even),y
}</code></pre>
<p>For-loops:</p>
<pre><code>; emit 8 nops
!for i in range(0, 8) {
    nop
}</code></pre>
<p>As opposed to a C-style “declare loop variable, check condition, increment” for loops, c64jasm’s <code>for</code> is similar to Python’s for-statement. You use a function called <code>range()</code> that returns a list of integers and the for-loop just iterates over the elements of this list, assigning the current list element to the bound loop variable <code>i</code>. E.g., these two are conceptually the same:</p>
<pre><code>; emit four NOPs
!for i in range(4) {
    nop
}

!for i in [0,1,2,3] {
    nop
}</code></pre>
<p>The “emit byte” pseudo <code>!byte</code> supports emitting a list of bytes when passed an integer list. The following two lines are equivalent:</p>
<pre><code>!byte range(4)
!byte 0, 1, 2, 3</code></pre>
<h2 id="c64jasm-extensions">C64jasm extensions</h2>
<p>So with the basic c64jasm pseudo ops explained, let’s continue to c64jasm extensions. A c64jasm extension is just a JavaScript .js module. To use such a .js module in your assembly source, you bind it to a name with <code>!use &quot;path/to/plugin.js&quot;</code>. This name becomes a function that you can call in your assembly source file.</p>
<p>Let’s illustrate this with some code to generate a sine lookup table. First the plugin code:</p>
<pre><code># sintab.js
module.exports = ({}, len, scale) =&gt; {
    const res = Array(len.lit).fill(0).map((v,i) =&gt; Math.sin(i/len.lit * Math.PI * 2.0) * scale.lit);
    return res;
}</code></pre>
<p>Here’s how you’d use the above in your .asm source file:</p>
<pre><code>; Bind sintab.js default export to a pseudo function &#39;mkSintab&#39;
!use &quot;./sintab&quot; as mkSintab

!let sin1scale = 26
sintab1:
!for s in mkSintab(256, sin1scale) {
    !byte s
}</code></pre>
<p>As <code>!byte</code> and <code>!word</code> accept a list as an argument, the above can be written simply as:</p>
<pre><code>sintab1: !byte mkSintab(256, sin1scale)</code></pre>
<p>The nice thing about this approach is that I can keep the assembler implementation simple. The assembler doesn’t need a large standard library of math and other utility functions as this functionality can be easily expressed as tiny JavaScript modules.</p>
<p>Sure, generating a sine table would be pretty easy without an extension too (and this is totally supported by c64jasm):</p>
<pre><code>sintab1:
   !for s in range(0, 256) {
       !byte sin(s/256*2*PI)*scl
   }</code></pre>
<p>Where I find the JavaScript extension mechanism really shines is importing assets (sprites from .spd, .sid, etc.). Here’s how I compile SpritePad .spd files into my demo binary:</p>
<pre><code># spd.js
module.exports = ({readFileSync, resolveRelative}, filename) =&gt; {
    const buf = readFileSync(resolveRelative(filename.lit));
    const numSprites = buf.readUInt8(4)+1;
    const data = [];
    for (let i = 0; i &lt; numSprites; i++) {
        const offs = i*64+9;
        const bytes = [];
        for (let j = 0; j &lt; 64; j++) {
            bytes.push(buf.readUInt8(offs + j));
        }
        data.push(bytes);
    }
    return {
        numSprites,
        enableMask: (1&lt;&lt;numSprites)-1,
        bg: buf.readUInt8(6),
        multicol1: buf.readUInt8(7),
        multicol2: buf.readUInt8(8),
        data
    };
}</code></pre>
<p>Using the above in an .asm file:</p>
<pre><code>!use &quot;./spd&quot;

; Load &#39;hirmu.spd&#39; and store the returned JavaScript object in a
; variable called &#39;hirmu_sprite&#39;
!let hirmu_sprite = spd(&quot;../sprites/hirmu.spd&quot;)</code></pre>
<p>At this point, no code or bytes were yet emittted. The .spd file contents are now in a pseudo variable called <code>hirmu_sprite</code>. This is just a JavaScript object with fields like <code>numSprites</code>, <code>enableMask</code>, <code>data</code> that can be accessed from .asm with the dot operator (e.g., <code>sprite_data.numSprites</code>.)</p>
<p>With this, I can expand the sprite data into the output binary. Or I can use to emit code to setup sprite registers (enable bits, individual and multi color values, etc).</p>
<p>Emitting actual sprite data for all the sprites contained within the .spd file:</p>
<pre><code>hirmu_sprite_data:
    ; loop over all the sprites in hirmu_sprite.data
    !for sdata in hirmu_sprite.data {
        !byte sdata  ; expand 64 bytes of sprite data (one sprite)
    }

    ; or equivalently:
    ; !for sidx in range(hirmu_sprite.numSprites) {
    ;    !byte hirmu_sprite.data[sidx]  ; expand 64 bytes of sprite data (one sprite)
    ; }
</code></pre>
<p>I also define a macro that expands machine code to write sprite registers based on the .spd file contents:</p>
<pre><code>!macro set_sprite(s, ptr, xScale, yScale) {
    !if (xScale == 2) {
        lda #s.enableMask
    } else {
        lda #0
    }
    sta $d01d  ; XSCALE register

    !if (yScale == 2) {
        lda #s.enableMask
    } else {
        lda #0
    }
    sta $d017  ; YSCALE register

    ; set sprite pointers and individual sprite colors for
    ; all sprites
    !for sprite_idx in range(0, s.numSprites) {
        ; load the individual color from sprite data
        lda #s.data[sprite_idx][63]
        ; indiv sprite color
        sta $d027 + sprite_idx    
        lda #ptr/64 + sprite_idx
        sta $7f8 + sprite_idx
    }

    ; enable multicolor for the same sprites, set multicolor values
    lda #s.multicol1
    sta $d025
    lda #s.multicol2
    sta $d026

    ; enable all the sprites that were loaded from the .spd
    lda #s.enableMask
    sta $d01c       ; multicolor enable
    sta $d015       ; sprite enable
}

set_hirmu_sprite: {
    +set_sprite(hirmu_sprite, hirmu_sprite_data, 2, 2)
    rts
}</code></pre>
<p>I use the same pattern for all the different asset types used in my demo. Here’s how I pull the SID tune into the binary:</p>
<pre><code># sid.js
function readWord(buf, offs) {
    return buf.readUInt8(offs) + (buf.readUInt8(offs+1) &lt;&lt; 8);
}

// Read a big-endian word
function readWordBE(buf, offs) {
    return (buf.readUInt8(offs)&lt;&lt;8) + buf.readUInt8(offs+1);
}

module.exports = ({readFileSync, resolveRelative}, filename) =&gt; {
    const buf = readFileSync(resolveRelative(filename.lit));
    const version = readWordBE(buf, 4);
    const dataOffset = readWordBE(buf, 6);
    const startAddress = readWord(buf, dataOffset);
    const init = readWordBE(buf, 0x0a);
    const play = readWordBE(buf, 0x0c);
    const numSongs = readWord(buf, 0x0e);
    const res = {
        startAddress,
        data: [...buf.slice(dataOffset+2)],
        init: startAddress,
        play: startAddress + 3
    }
    return res;
}</code></pre>
<p>Using the loaded SID tune from the .asm source:</p>
<pre><code>!use &quot;./sid&quot; as sid
!let music = sid(&quot;sid/tune.sid&quot;)

demo_start: {
    lda #0
    jsr music.init
    ...
    jsr music.play      ; usually called from an IRQ
}

* = music.startAddress  ; usually music.startAddress == $1000
music:
!byte music.data</code></pre>
<p>All of these content plugins are just normal .js files that can be run from the command line with <code>node</code>. This enables you to use standard tools like VSCode to debug them as stand-alone JavaScript modules. I prefer this code to be part of the project source tree rather than buried somewhere within c64jasm’s standard libraries.</p>
<h2 id="epilogue">Epilogue</h2>
<p>OK, that’s about it for now on c64jasm plugins. I will probably write another blog later about using c64jasm in VSCode (with quick re-compile-on-save and launch .prg in VICE.) I <a href="https://twitter.com/nurpax/status/1049757222547451906">tweeted</a> about it a while ago, you can check out the video if you’re curious about this.</p>
<p>Oh by the way, <a href="https://github.com/nurpax/c64jasm">c64jasm</a> is available on GitHub and is already quite usable. However, it’s still very much work-in-progress. If you’re into this type of stuff and feeling adventurous, feel free to give it a try. Otherwise, stick with the more established C64 assemblers. :)</p>
<h2 id="visio-2018-invitation-demo-capture">VISIO 2018 invitation demo capture</h2>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/Jr5DqTcFpf4?rel=0&amp;controls=1&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>]]></summary>
</entry>
<entry>
    <title>C64 VICE monitor commands</title>
    <link href="http://nurpax.github.com/posts/2018-08-23-vice-monitor-tricks.html" />
    <id>http://nurpax.github.com/posts/2018-08-23-vice-monitor-tricks.html</id>
    <published>2018-08-23T00:00:00Z</published>
    <updated>2018-08-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A collection of random VICE monitor commands.</p>
<h2 id="capturing-the-rom-charset">Capturing the ROM charset</h2>
<p>Make ROM visible to the monitor and save data from <code>$d000</code> onwards:</p>
<pre><code>bank rom
bs &quot;data.bin&quot; 0 $d000 $d7fff</code></pre>]]></summary>
</entry>
<entry>
    <title>BINTRIS C64: Bad lines and flexible line distance (series part 5)</title>
    <link href="http://nurpax.github.com/posts/2018-06-19-bintris-on-c64-part-5.html" />
    <id>http://nurpax.github.com/posts/2018-06-19-bintris-on-c64-part-5.html</id>
    <published>2018-06-19T00:00:00Z</published>
    <updated>2018-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<p>(Looking for the BINTRIS C64 disk image? Find it <a href="/posts/2018-05-21-bintris-on-c64-part-2.html">here</a>.)</p>
<h2 id="introduction">Introduction</h2>
<p>This post discusses how BINTRIS uses YSCROLL manipulation to implement bad line suppression and full-screen vertical scrolling (flexible line distance, or FLD).</p>
<p>Here are the effects in action:</p>
<div class="img-columns-2">
<p class="img-column">
<img width="100%" class="img-pixelated" src="/images/bintris/bintris-writer-fld.gif" /><em>Vertical scrolling.</em>
</p>
<p class="img-column">
<img width="100%" class="img-pixelated" src="/images/bintris/bintris-logo-wobble.gif" /> <em>BINTRIS logo warp effect.</em>
</p>
</div>
<p>Note: all timing values in this post are for specific to PAL-B C64 models.</p>
<h2 id="bad-lines">Bad Lines</h2>
<p>To understand FLD, you need to grasp the concept of Bad Lines. I’ll summarize Bad Lines here but you can read about it in more detail in the excellent <a href="http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt">vic-ii.txt document</a> (section 3.5). The same document also explains FLD in section 3.14.2.</p>
<p>The VIC scans out the video frame line-by-line. Each line takes exactly 63 clock cycles. On normal lines, all these 63 cycles are available to the CPU. However, on every 8th pixel row (=start of a new character row), the VIC needs an extra 40 cycles to fetch a line of character codes from memory. When these fetches start, the CPU is “stunned”, meaning it won’t execute for about 40-43 clock cycles. These lines are called Bad Lines. On these lines, you have only 20-23 clock cycles to spend on your raster magic. With sprites, even less.</p>
<p>This might not be a big deal with timing insensitive code. But since the C64 is all about carefully crafted raster code, bad lines are something you just have to deal with.</p>
<p>To illustrate bad lines, I made this little interactive chart that shows the effect of bad lines. The little green boxes at the bottom represent the 63 cycles you have for a single line. The currently executing cycle is highlighted in white. A white dot over the C64 image is the raster beam. On normal lines, the CPU runs instructions on every cycle. But on bad lines, the CPU is stunned (black boxes) and cannot execute instructions.</p>
<div id="cycle-timing-container">
</div>
<p>When do the bad lines occur? Here’s the bad line condition in pseudo code:</p>
<pre><code>   if (RASTER &gt;= $30 &amp;&amp; RASTER &lt;= $f7) {
     if ((RASTER &amp; 7) == YSCROLL) {
       // BAD LINE
     }
   }</code></pre>
<p>where RASTER is the current scanline register (<code>$d011</code>/<code>$d012</code>) and YSCROLL is the vertical scroll register (bits 0-2 of <code>$d011</code>). (See the <a href="http://sta.c64.org/cbm64mem.html">C64 memory map</a> for details on these registers.)</p>
<p>Notice how the bad line condition depends on the YSCROLL register. Turns out, you can suppress or delay bad lines by manipulating the YSCROLL value at the right time. Recall the <code>(RASTER&amp;7)==YSCROLL</code> condition. If, at the beginning of a line, you set the YSCROLL to a value that doesn’t match the lowest 3 bits of the current line, the bad line will not happen. On such lines, VIC has nothing to render (as we just tricked it to not fetch character codes) and it will render the last byte of the video memory instead (e.g., contents of <code>$3fff</code>)</p>
<p>Let’s see what we can do with this technique.</p>
<h2 id="flexible-line-distance-fld">Flexible Line Distance (FLD)</h2>
<p>Flexible line distance is a technique that uses bad line suppression to scroll the display down by an arbitrary number of lines. I use it in the BINTRIS to scroll the whole screen down when leaving the writer part.</p>
<div class="img-columns-2">
<div class="img-column">
<div id="fld-container"></div>
<em>The FLD effect.</em>
</div>
<div class="img-column">
<img style="display:block" width="100%" class="img-pixelated" src="/images/bintris/bintris-writer-fld.gif" /> <em>Vertical scrolling.</em>
</div>
</div>
<p>To scroll by N lines, simply trigger a raster IRQ at the top of the screen (say on line 46) and suppress N bad lines. Here’s how you might do this in C-like pseudo code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">// YSCROLL is mapped to $d011</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">// RASTER is mapped to $d012</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="cf">while</span>(!new_frame()) {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="co">// do nothing</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">YSCROLL = <span class="bn">0x1B</span>;  <span class="co">// default YSCROLL value (%111)</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">// wait for FLD start line</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="cf">while</span> (RASTER != <span class="bn">0x40</span>) {</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    <span class="co">// do nothing</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; num_fld_lines; i++) {</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    <span class="dt">uint8_t</span> cur_raster = RASTER;</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    <span class="co">// wait for next next line</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">    <span class="cf">while</span> (cur_raster == RASTER) {</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">        <span class="co">// do nothing</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    <span class="co">// skip over bad line by manipulating YSCROLL</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">    YSCROLL = ((YSCROLL + <span class="dv">1</span>) &amp; <span class="dv">7</span>) | <span class="bn">0x18</span>;</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">}</a></code></pre></div>
<p>I found <a href="http://codebase64.org/doku.php?id=base:fld">working FLD code in 6502 assembly</a> from codebase64.org. I tested it by porting it to KickAssembler and running it on VICE.</p>
<h2 id="skipping-bad-lines">Skipping Bad Lines</h2>
<p>As discussed above, it’s possible to vertically scroll down the whole screen by manipulating the YSCROLL register at appropriate times. However, vertical scrolling is not the only reason why you might want to skip bad lines. Recall from the Bad Lines section that on a bad line, the CPU can run only 20-23 cycles worth of machine code. <em>(NB: although many tutorials say that you have 23 CPU cycles on a bad line, in practice you really only have 20-22 cycles to work with. I might write a separate article about this topic later on.)</em></p>
<p>The situation gets even worse if there are any sprites on a bad line. Also, the more sprites you have, the fewer CPU cycles are available. Here’s a simplified formula for evaluating how many cycles you can spend on a bad line with sprites:</p>
<p><span class="math inline"><em>n</em><em>u</em><em>m</em>_<em>c</em><em>y</em><em>c</em><em>l</em><em>e</em><em>s</em> = 23 − (3 + 2 * <em>n</em><em>u</em><em>m</em>_<em>s</em><em>p</em><em>r</em><em>i</em><em>t</em><em>e</em><em>s</em>)</span></p>
<p><em>(NB: This is a bit simplified, see <a href="http://www.antimon.org/dl/c64/code/missing.txt">Missing Cycles</a> for details.)</em></p>
<p>Let’s say you have enabled sprites 0-3 and they all hit a bad line. Now you have only 12 cycles to spare on your fancy raster routine (or in practice, more like 10 cycles.)</p>
<p>Ten cycles is not all that much. For example, say you want to load and store some values. Here’s all you can run during a single bad line:</p>
<pre><code>LDA abs_addr        (4 cycles)
STA abs_addr        (4 cycles)
NOP                 (2 cycles)</code></pre>
<p>The logo warp effect in BINTRIS is implemented using sprites by encoding the logo pixels into 4 separate sprites. The line-by-line warp is implemented by setting the x-coordinate of each sprite to a new value on every raster line the logo spans. Here’s a close up of this effect:</p>
<div class="img-columns-2">
<img class="img-column img-pixelated"  width="100%" src="/images/bintris/bintris-logo-wobble.gif" />
<div class="img-column">
<div id="logo-wobble-closeup-container"></div>
</div>
</div>
<p>To set the the horizontal location of each sprite, we’d need to do this for every raster line the sprites span:</p>
<pre><code>// At the beginning of a raster line
.for (var y 0; y &lt; 21; y++) {
    lda spritex + y*4 + 0   // sprite 0 x-coord
    sta $d000+0
    lda spritex + y*4 + 1   // sprite 1 x-coord
    sta $d000+2
    lda spritex + y*4 + 2   // sprite 2 x-coord
    sta $d000+4
    lda spritex + y*4 + 3   // sprite 3 x-coord
    sta $d000+6
    // + waste cycles until we&#39;re at the beginning of the next
    //   raster line
}</code></pre>
<p>That’s 32 CPU cycles per line. The sprites fall on a few bad lines and on these scanlines there’s only 10 cycles to spare. Sure, it’s possible to optimize the sprite x-coordinate stores down to 24 cycles with self-modifying code but 10 cycles doesn’t seem possible.</p>
<p>Without bad lines, there’s 52 cycles (=63-11 to account for 4 sprites) per scanline which is more than enough to move all the four sprites horizontally.</p>
<p>If only there were no bad lines..</p>
<p>You guessed it, right? If bad lines are suppressed for the duration of the logo, there will be plenty of cycles to move the sprites. Bad line suppression can be done by manipulating the YSCROLL register just as we did with FLD:</p>
<pre><code>
// Note: waste_cycles(c) is a macro that inserts the right
// amount of NOPs and BITs to burn &#39;c&#39; clock cycles.
.for (var y = 0; y &lt; 21; y++) {
    .var cycles = 63
    // skip bad line with FLD
    .var rasty = SPRITE_LOGO_YSTART + y
    .eval cycles = cycles - 3 - 8 // sprite overhead
    // Suppress bad line
    lda #$18 | ((rasty+1) &amp; %111)
    sta $d011
    .eval cycles = cycles - 6

    lda spritex + y*4 + 0
    ldx spritex + y*4 + 1
    ldy spritex + y*4 + 2
    .eval cycles -= 3*4

    sta $d000+0
    stx $d000+2
    sty $d000+4
    .eval cycles -= 4*3

    lda spritex + y*4 + 3
    sta $d000+6
    .eval cycles -= 8
    waste_cycles(cycles)
}</code></pre>
<p>If you’re interested in playing with the sprite warp, I pushed its <a href="https://github.com/nurpax/c64-samples/tree/master/sprite_warp">standalone source code up on github</a>. Here’s how it looks like:</p>
<p><img class="img-medium-wide" src="/images/bintris/sprite-wobble-standalone.png"/></p>
<script type="text/javascript">
var diagram, fld;

$(function () {
    diagram = new diagrams.TimingDiagram('cycle-timing-container');
    diagram.mount();

    fld = new diagrams.FldDiagram('fld-container');
    fld.mount();

    warpCrop = new diagrams.LogoWarpCrop('logo-wobble-closeup-container');
    warpCrop.mount();
})
</script>
<h2 id="next-in-series">Next in series</h2>
<p>My next BINTRIS post will wrap up the article series.</p>]]></summary>
</entry>
<entry>
    <title>Break down of a C64 demo effect</title>
    <link href="http://nurpax.github.com/posts/2018-06-07-c64-filled-sinewave.html" />
    <id>http://nurpax.github.com/posts/2018-06-07-c64-filled-sinewave.html</id>
    <published>2018-06-07T00:00:00Z</published>
    <updated>2018-06-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>So I recently made this little sinewave demo effect on the Commodore 64:</p>
<p><img class="img-pixelated img-medium-wide" src="/images/c64/sine/sinewave-gifanim-2018-05-31.gif" /></p>
<p>This generated a lot of lively discussion on <a href="https://twitter.com/nurpax/status/1002288831511580672">twitter</a> and <a href="https://www.reddit.com/r/c64/comments/8o9aoh/some_charset_hacking_from_last_week/">/r/c64</a>. A bunch of people were curious as to how it works and I promised to explain it on my blog.</p>
<p>The main idea is to use character mode with a custom character set. I sample y-coordinate every 8 pixels to produce a list of line segments <span class="math inline">[(0, <em>y</em><sub>0</sub>), (8, <em>y</em><sub>1</sub>), (16, <em>y</em><sub>2</sub>), ..., (320, <em>y</em><sub>40</sub>)]</span>. In the below animation, you can see these line segments along with blue rectangles that signify which 8x8 character blocks intersect the line segments.</p>
<p><img class="img-medium-wide" src="/images/c64/sine/sinewave-block-cover.gif"/></p>
<p>The goal then is to fill all the pixels below a line segment with light blue and everything above it with dark blue.</p>
<p>Here’s how you might code this up in Python:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co"># Compute sine wave by stepping every 8th pixel</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">ypos <span class="op">=</span> [sinewave(phase, x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">+</span> <span class="dv">8</span>, <span class="dv">8</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">clear_screen(BLUE)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="co"># Loop through each line segment</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    x0 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    x1 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span> <span class="op">+</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    y0 <span class="op">=</span> ypos[x]</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    y1 <span class="op">=</span> ypos[x <span class="op">+</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="co"># Fill everything below the (x0,y0)-(x1,y1) line segment</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="co"># with LIGHT_BLUE</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    fill_polygon([(x0, y0), (x1, y1), (x1, <span class="dv">200</span>), (x0, <span class="dv">200</span>)], LIGHT_BLUE)</a></code></pre></div>
<p>Unfortunately using a polygon fill routine in C64 bitmap mode would be pretty slow. To make this run fast, I precompute the different ways a line segment can intersect 8x8 character blocks using an edge function rasterizer written in Python. Here’s an image that shows some combinations of a line hitting 3 vertically stacked 8x8 blocks:</p>
<p><img class="img-pixelated img-smallest" src="/images/c64/sine/sinewave-fill-closeup.gif"/></p>
<p>Here’s Python code for the block rasterizer:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"> <span class="co"># one bit of subpixel precision</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"> subpix <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">def</span> mk8x8(yoffs, a, b, c):</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    arr <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">8</span>)]</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        yy <span class="op">=</span> (y <span class="op">+</span> yoffs) <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">            xx <span class="op">=</span> x <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">            <span class="cf">if</span> a <span class="op">*</span> xx <span class="op">+</span> b <span class="op">*</span> yy <span class="op">+</span> c <span class="op">&gt;=</span> <span class="fl">0.0</span>:</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">                arr[x <span class="op">+</span> y <span class="op">*</span> <span class="dv">8</span>] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="cf">return</span> arr</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="kw">def</span> construct_fill_table():</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">    x0 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">    x1 <span class="op">=</span> <span class="dv">8</span> <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    fill_tbl <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> subpix)]</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    <span class="cf">for</span> y0 <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix):</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">        fill_tbl[y0] <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix)]</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">        <span class="cf">for</span> yi1 <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">4</span> <span class="op">*</span> subpix, <span class="dv">4</span> <span class="op">*</span> subpix):</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">            y1 <span class="op">=</span> y0 <span class="op">+</span> yi1</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">            a <span class="op">=</span> <span class="op">-</span>(y1 <span class="op">-</span> y0)</a>
<a class="sourceLine" id="cb2-23" data-line-number="23">            b <span class="op">=</span> (x1 <span class="op">-</span> x0)</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">            c <span class="op">=</span> <span class="op">-</span>(a <span class="op">*</span> x0 <span class="op">+</span> b <span class="op">*</span> y0)</a>
<a class="sourceLine" id="cb2-25" data-line-number="25">            chr_a <span class="op">=</span> mk8x8(<span class="op">-</span><span class="dv">8</span>, a, b, c)</a>
<a class="sourceLine" id="cb2-26" data-line-number="26">            chr_b <span class="op">=</span> mk8x8(<span class="dv">0</span>, a, b, c)</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">            chr_c <span class="op">=</span> mk8x8(<span class="dv">8</span>, a, b, c)</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">            fill_tbl[y0][yi1 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix] <span class="op">=</span> [chr_a, chr_b, chr_c]</a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    <span class="cf">return</span> fill_tbl</a></code></pre></div>
<p>A Python renderer using the table generated <code>construct_fill_table()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">def</span> draw_fills(ypos):</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="cf">for</span> xi <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        x <span class="op">=</span> xi <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        y0 <span class="op">=</span> <span class="bu">int</span>((ypos[xi] <span class="op">*</span> subpix))</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        y1 <span class="op">=</span> <span class="bu">int</span>((ypos[xi <span class="op">+</span> <span class="dv">1</span>] <span class="op">*</span> subpix))</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        yy0 <span class="op">=</span> y0 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        yy1 <span class="op">=</span> y1 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        y0 <span class="op">-=</span> yy0</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        y1 <span class="op">-=</span> yy0</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        chrs <span class="op">=</span> fill_tbl[y0][y1 <span class="op">-</span> y0 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix]</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">-</span> <span class="dv">8</span>, chrs[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">        blit_8x8(x, yy0 <span class="op">/</span> subpix, chrs[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">+</span> <span class="dv">8</span>, chrs[<span class="dv">2</span>])</a></code></pre></div>
<p>Note that in the above code, each entry in the <code>fill_tbl</code> 2d-array is a list 3 character bitmaps. A character bitmap is a 64 entry list of zeros and ones. To make use of this on the C64, you need to turn this data into two separate arrays: the actual character set and an array indexed by <span class="math inline"><em>y</em>0</span>, <span class="math inline"><em>y</em>1</span> that returns a list of 3 character indices.</p>
<p>Here’s how these two tables look like. First the charset:</p>
<p><img class="img-pixelated img-small" src="/images/c64/sine/charset-16x16.png" /></p>
<p>..and the character index table (<code>$20</code> is the space character, ie., an empty block, <code>$a0</code> is a fully filled 8x8 block):</p>
<pre><code>y0y1tbl:
    .byte $00, $a0, $a0, $a0
    .byte $02, $0e, $a0, $a0
    .byte $0f, $10, $a0, $a0
    .byte $1b, $24, $a0, $a0
... 252 more entries ...</code></pre>
<p>If you’d run the C64 equivalent of the above Python routine on the default charset, you’d see something like this:</p>
<p><img class="img-pixelated img-medium-wide" src="/images/c64/sine/sinewave-sans-charset.gif" /></p>
<p>Since I have full control over the sine animation, I choose animation parameters that make the line segments behave “nicely”. Niceness is defined as follows: let <span class="math inline">(<em>x</em>0, <em>y</em>0)</span> and <span class="math inline">(<em>x</em>0 + 8, <em>y</em>1)</span> be the end points of a line segment. The segment behaves “nicely” if it satisfies the following condition: <span class="math inline">|<em>y</em>0 − <em>y</em>1| &lt; <em>c</em></span> (where <span class="math inline"><em>c</em></span> is some small number, in my case 8). This is required in order to keep the <code>fill_tbl</code> at a reasonable size and to limit the number of unique 8x8 characters (since the hardware character set is only 256 entries).</p>
<p>That’s about all there is to it, I guess.</p>]]></summary>
</entry>
<entry>
    <title>BINTRIS C64 game screen rendering (series part 4)</title>
    <link href="http://nurpax.github.com/posts/2018-05-30-bintris-on-c64-part-4.html" />
    <id>http://nurpax.github.com/posts/2018-05-30-bintris-on-c64-part-4.html</id>
    <published>2018-05-30T00:00:00Z</published>
    <updated>2018-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(Looking for the BINTRIS C64 disk image? Find it <a href="/posts/2018-05-21-bintris-on-c64-part-2.html">here</a>.)</p>
<p>Let’s take a look at how the actual BINTRIS game screen is rendered. This is the first thing I implemented for this projet (after maybe 25 years of C64 dev hiatus) and in hindsight I think it could’ve been simpler with less sprites and more charset manipulation.</p>
<p>The graphic elements of this screen are:</p>
<ul>
<li>The BINTRIS logo at the top (4 multicolor sprites)</li>
<li>Currently falling bit (one single color sprite)</li>
<li>Current score (3 multicolor sprites, one sprite per number, max 3 digits)</li>
<li>The collapse noise animation (3 multicolor sprites)</li>
<li>The game board rendered in text mode (one character per bit)</li>
<li>Decimal targets (standard text)</li>
</ul>
<p>Here’s how it looks like (with red &amp; green rectangles highlighting sprite locations):</p>
<p><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
    "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 384 272"><style>text { font-family: "arial";}

.pointsample { image-rendering: pixelated; }</style><g><image width="384.0" height="272.0" class="pointsample" xlink:href="/images/bintris/gamescreen-collapse.gif" /><rect width="1120.0" height="1.0" x="-8.0" y="26.0" fill="#393" /><rect width="1120.0" height="1.0" x="-8.0" y="62.0" fill="#933" /><rect width="24.0" height="1.0" x="72.0" y="110.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="96.0" y="110.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="131.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="72.0" y="110.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="158.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="96.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="179.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="72.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="96.0" y="158.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="120.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="96.0" y="179.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="96.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="120.0" y="158.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="144.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="120.0" y="179.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="120.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="158.0" y="68.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="182.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="158.0" y="89.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="158.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="182.0" y="68.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="206.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="182.0" y="89.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="182.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="206.0" y="68.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="230.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="206.0" y="89.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="206.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="96.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="72.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="72.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="96.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="120.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="96.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="96.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="120.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="144.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="120.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="120.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="144.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="168.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="144.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="144.0" y="36.0" fill="#44ff22" /><g transform="matrix(0.6,0.0,0.0,0.6,28.0,92.0)"><g id="title"><rect width="14.0" height="14.0" x="70.0" y="229.0" fill="#393" /><text x="89.0" y="242.0" fill="white">logo irq line </text></g></g><g transform="matrix(0.6,0.0,0.0,0.6,64.0,92.0)"><g id="title"><rect width="14.0" height="14.0" x="160.0" y="229.0" fill="#933" /><text x="179.0" y="242.0" fill="white">board irq line</text></g></g></g></svg></p>
<p>That’s 11 sprites in total. As the C64 hardware only supports 8 sprites, we need to multiplex hardware sprites with raster interrupts:</p>
<ol type="1">
<li>Program sprites 0-3 for the BINTRIS logo at the top of the frame, before the raster beam reaches the logo.</li>
<li>Once the raster beam’s past the logo, program sprites 0-6 to be used for the current score (3 sprites), falling bit (1 sprite), and the collapse noise animation (3 sprites).</li>
</ol>
<p>Note that not all these sprites are always enabled: the noise animation sprites are enabled only when rows are collapsing, the falling bit is turned off during the noise animation, and if the current score is, say, less than 10, we need only one sprite for the score digits.</p>
<p>I did skip over some details, though. The biggest omission is the BINTRIS logo level up warp effect. It looks something like this:</p>
<div class="screenshot">
<img src="/images/bintris/logowarp.gif" title="BINTRIS logo warp gif" class="img-pixelated" width="300" height="80" />
</div>
<p>This effect manipulates the logo sprite X locations on each scanline to achieve the line-by-line distortion effect. It might not look like much in this .gif capture, but as far as timing sensitive code goes, this is by far the trickiest routine in the game. There will be a blog about this effect later in the series.</p>
<p>The game board is rendered using text mode characters. The charset contains an 8x8 filled rectangle which is used to clear the board area on game start or on level up. Per-frame rendering only sets the color of each such block.</p>
<p>Board state is represented by two arrays: <code>setbit</code> and <code>bits</code> (16 bytes each). The <code>setbit</code> array encodes which cells contain a block (one bit per column, one byte per row). The <code>bits</code> array containts the actual bit values. The code to render the board is pretty simple with these two arrays:</p>
<pre><code>piececol:
    .byte DARK_GRAY, BLACK, DARK_GRAY, WHITE

.macro drawboard(colorbuf) {
    .const tsetbits = $62
    .const tbits = $63
    // Note unrolling by 16 is simply due to lazyness, it&#39;s not
    // necessary for performance.
    .for (var y = 0; y &lt; 16; y++) {
        lda setbit+y
        sta tsetbits
        lda bits+y
        sta tbits
        ldy bitwidth     // current board bitwidth
xloop:
        lda tbits
        and #1
        lsr tsetbits
        rol
        tax
        lda piececol, x
        lsr tbits
        sta colorbuf+[(y+1)*40], y
        dey
        bne xloop
    }
}</code></pre>
<p>That’s roughly 31 clock cycles per block. In the <a href="http://nurpax.com/bintris">BINTRIS web version</a> each block is a bunch of SVG <code>&lt;rect&gt;</code> elements wrapped in a <code>&lt;g&gt;</code> element wrapped in a <code>React.PureComponent</code>. I’m pretty sure the cost to render a block in the web version is at least a couple of orders of magnitude higher. That’s not React’s fault of course, I should totally get the blame for abusing React for gamedev like this.</p>
<h2 id="next-in-series">Next in series</h2>
<p>The next post will discuss vertical scrolling with flexible line distance (FLD) and will also go into details on how the BINTRIS logo warp was done.</p>]]></summary>
</entry>
<entry>
    <title>Handy command-line incantations</title>
    <link href="http://nurpax.github.com/posts/2018-05-28-handy-command-line-incantations.html" />
    <id>http://nurpax.github.com/posts/2018-05-28-handy-command-line-incantations.html</id>
    <published>2018-05-28T00:00:00Z</published>
    <updated>2018-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Just some command line copy&amp;pastes that I always tend to forget. Mainly ImageMagick and ffmpeg.</p>
<h2 id="image-files">Image files</h2>
<p>View image width, height &amp; format:</p>
<pre><code>identify &lt;imagefile&gt;</code></pre>
<p>Make a .gif anim from a collection of image files:</p>
<pre><code>convert -loop 0 -delay 300 image1.png image2.png image3.png result.gif</code></pre>
<p>Resize an image with point-sampling while NOT preserving aspect-ratio (ImageMagick forces original aspect ratio without warning):</p>
<pre><code>convert input.png -sample 640x200! output.png</code></pre>
<p>Crop the input image and then make a .gif (<code>+repage</code> is required to actually crop the output image dimensions too):</p>
<pre><code># 104x30 is the size of the crop rectangle
# +62+22 is an offset to the top/left corner of the crop area
convert -crop 104x30+62+22 +repage -loop 0 -delay 300 image?.png result.gif</code></pre>
<h2 id="video-files">Video files</h2>
<p>View video file format details:</p>
<pre><code>ffprobe &lt;videofile&gt;</code></pre>
<p>Convert a VICE video capture .avi (in DivX format) to MP4:</p>
<pre><code>ffmpeg -i screencap.avi -c:v libx264 -crf 19 -preset slow -c:a libvo_aacenc -b:a 192k -ac 2 out.mp4</code></pre>
<p>Convert a series of image files into an MP4:</p>
<pre><code>ffmpeg -r 25 -i &#39;frame_%04d.png&#39; -c:v libx264 -vf fps=25 -pix_fmt yuv420p out.mp4</code></pre>
<p>Convert a MOV file into an MP4 (e.g., for uploading Quicktime screencaps to Twitter):</p>
<pre><code>ffmpeg -i movie.mov -vcodec copy -acodec copy out.mp4</code></pre>]]></summary>
</entry>
<entry>
    <title>BINTRIS C64 title screen implementation (series part 3)</title>
    <link href="http://nurpax.github.com/posts/2018-05-27-bintris-on-c64-part-3.html" />
    <id>http://nurpax.github.com/posts/2018-05-27-bintris-on-c64-part-3.html</id>
    <published>2018-05-27T00:00:00Z</published>
    <updated>2018-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(Looking for the BINTRIS C64 disk image? Find it <a href="/posts/2018-05-21-bintris-on-c64-part-2.html">here</a>.)</p>
<p>This blog post discusses the implementation of the BINTRIS C64 title screen.</p>
<p>The title screen consists of a multicolor bitmap at the top and a text mode scroller at the bottom. Here’s how it looks like:</p>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/akaQcBNG9TE?rel=0&amp;controls=1&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<p>This is a pretty standard text mode scroller: use the horizontal scroll register <code>$d016</code> for 0-7 pixel shifting. When you reach pixel offset 7, reset to pixel offset 0 and move the whole character row left by one character (8 pixels). Additionally, the scroller text is colored with raster bars.</p>
<p>But wait a minute.. The screen is in multicolor bitmap mode. How can we use a <em>text mode</em> scroller at the bottom? Fortunately it’s pretty easy to mix bitmap and text mode within a single frame. Just switch to text-mode right before raster beam reaches the scroller, and switch back to bitmap mode once the raster beam is past it.</p>
<p>The below animation illustrates how the raster IRQs trigger:</p>
<p><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
    "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 716 539"><style>text { font-family: "arial";}

#rasterbeam {
  animation-name: rasterline;
  animation-duration: 4s;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
}
@keyframes rasterline {
  from { transform: translateY(26.0px); }
  to { transform: translateY(506.0px);  }
}
#hilite1 {
  animation-name: hilite1;
  animation-duration: 4s;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
  transform-origin: center;
  transform-box: fill-box;
}
@keyframes hilite1 {
  0% { opacity:0; }
  6.25% { opacity:0; }
  6.26% { opacity:1; }
  16.25% { opacity:0; }
  100% { opacity:0; }
}

#hilite2 {
  animation-name: hilite2;
  animation-duration: 4s;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
  transform-origin: center;
  transform-box: fill-box;
}
@keyframes hilite2 {
  0% { opacity:0; }
  86.666664% { opacity:0; }
  86.67667% { opacity:1; }
  96.666664% { opacity:0; }
  100% { opacity:0; }
}

#hilite3 {
  animation-name: hilite3;
  animation-duration: 4s;
  animation-iteration-count: infinite;
  animation-timing-function: linear;
  transform-origin: center;
  transform-box: fill-box;
}
@keyframes hilite3 {
  0% { opacity:0; }
  88.333336% { opacity:0; }
  88.34334% { opacity:1; }
  98.333336% { opacity:0; }
  100% { opacity:0; }
}

</style><g><image width="716.0" height="539.0" xlink:href="/images/bintris/titlescreen_for_blog.png" /><rect width="748.75" height="2.0" x="-16.875" y="56.0" fill="#008d46" /><rect width="748.75" height="2.0" x="-16.875" y="442.0" fill="#cf4600" /><rect width="748.75" height="2.0" x="-16.875" y="450.0" fill="#0046cf" /><rect width="748.75" height="2.0" x="-16.875" y="0.0" id="rasterbeam" fill="#ffffff" opacity="0.7" /></g><g><g id="title"><rect width="14.0" height="14.0" x="148.0" y="508.0" fill="#008d46" /><text x="167.0" y="521.0" fill="white">bitmap mode</text><rect width="130.0" height="23.0" x="145.0" y="504.0" fill="#fff" id="hilite1" /></g><g id="title"><rect width="14.0" height="14.0" x="298.0" y="508.0" fill="#cf4600" /><text x="317.0" y="521.0" fill="white">text mode</text><rect width="130.0" height="23.0" x="295.0" y="504.0" fill="#fff" id="hilite2" /></g><g id="title"><rect width="14.0" height="14.0" x="433.0" y="508.0" fill="#0046cf" /><text x="452.0" y="521.0" fill="white">raster bar</text><rect width="130.0" height="23.0" x="430.0" y="504.0" fill="#fff" id="hilite3" /></g></g></svg></p>
<p>In summary:</p>
<ul>
<li>Line 16 (<code>irq0</code>): set multicolor bitmap mode, move character row left by one character if <code>framecount&amp;7==0</code>.</li>
<li>Line 238 (<code>irq1</code>): switch to text mode, set horizontal scroll based on <code>framecount</code> bits 0-2</li>
<li>Line 241 (<code>irq2</code>): raster bars (using the <a href="http://codebase64.org/doku.php?id=base:double_irq_explained">double IRQ trick</a> for stable raster), loop back to Line 16</li>
</ul>
<p>And the same in assembly:</p>
<pre><code>.const irq0line = 16
.const textmodeswitchline = 50+200-12
.const rastercolorline = 50+200-9

framecount: .byte 0     // increased at the beginning of each frame

// Macro to save&amp;restore registers and setup the next routine in the
// raster IRQ chain.
.macro irq_start(end_lbl) {
    sta end_lbl-6
    stx end_lbl-4
    sty end_lbl-2
}

.macro irq_end(next, line) {
    :EndIRQ(next, line, false)
    lda #$00
    ldx #$00
    ldy #$00
    rti
}


irq0: {
    irq_start(end)

    inc framecount

    // Set screen mode
    lda #$3b // bitmap mode
    sta $d011
    lda #$18 // multicolor
    sta $d016
    // screen memory ptr
    lda #$18
    sta $d018

    jsr scroller_update_char_row

    irq_end(irq1, textmodeswitchline)
end:
    rti
}

irq1: {
    irq_start(end)

    lda #$1b        // screen on, text mode
    sta $d011

    lda framecount
    and #7
    eor #7 // xor bits 0-2 and leave bit 3 zero for 38 column mode
    sta $d016

    lda #$10 // bank + $0400
    sta $d018

    irq_end(irq2, rastercolorline)
end:
}

// Stable raster IRQ for color bars
irq2: {
    double_irq(end, irq3)

irq3:
    txs

    // Wait exactly 9 * (2+3) cycles so that the raster line is in the border
    ldx #$09
    dex
    bne *-1

    // First line is a bad line so we have only 23 cycles!
    lda colors1+0           // 4 cycles
    sta $d021               // 4 cycles
    .for (var i = 0; i &lt; 6; i++) {
        nop
    }
    bit $fe

    // Next 7 lines are normal lines, so 63 cycles per color change
    ldx #$01
!:
    lda colors1,x           // 4 cycles
    sta $d021               // 4 cycles
    .for (var i = 0; i &lt; (63-15)/2; i++) {
        nop
    }
    inx                     // 2
    cpx #colorend-colors1   // 2
    bne !-                  // 3

    lda #0
    sta $d021

    irq_end(irq0, irq0line)
end:
}</code></pre>
<p>I put up a full stand-alone version of this <a href="https://github.com/nurpax/c64-samples/tree/master/text-scroller">on github</a> – this should compile on KickAssembler. It’s a slightly cleaned up version of the BINTRIS titlescreen. For some historical reason I used VIC bank 1 instead of the default and made screen RAM reside at <code>$4400</code> instead of <code>$0400</code>. This can make the source a bit harder to follow.</p>
<h2 id="next-in-series">Next in series</h2>
<p>The next post will discuss how the main BINTRIS game screen is rendered.</p>]]></summary>
</entry>
<entry>
    <title>BINTRIS on the C64 has been released! (series part 2)</title>
    <link href="http://nurpax.github.com/posts/2018-05-21-bintris-on-c64-part-2.html" />
    <id>http://nurpax.github.com/posts/2018-05-21-bintris-on-c64-part-2.html</id>
    <published>2018-05-21T00:00:00Z</published>
    <updated>2018-05-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="screenshotMax">
<img src="/images/bintris_titlescreen.png" title="BINTRIS" />
</div>
<p>The Commodore 64 version of <a href="http://nurpax.com/bintris">BINTRIS</a> has been released!</p>
<p>Download the latest BINTRIS disk image: <a href="/files/bintris-2018-05-22.d64">bintris-2018-05-22.d64</a></p>
<p>(Originally <a href="http://csdb.dk/release/index.php?id=164874">released on CSDb</a> but further updates will be posted here on the blog.)</p>
<p>Here’s a quick VICE video cap (real hardware capture is coming online very soon):</p>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/XRdg8u9umHo?rel=0&amp;controls=1&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<p>Here’s the game objective in a nutshell:</p>
<div class="screenshotMax">
<img src="/images/bintris_how_to_play2.png" title="BINTRIS HOWTO PLAY" />
</div>
<h2 id="next-in-series">Next in series</h2>
<p>The next post will discuss how the title screen mixes multicolor bitmap mode (the BINTRIS image) and text mode (the scroller).</p>]]></summary>
</entry>
<entry>
    <title>BINTRIS on the C64 (series part 1)</title>
    <link href="http://nurpax.github.com/posts/2018-05-19-bintris-on-c64-part-1.html" />
    <id>http://nurpax.github.com/posts/2018-05-19-bintris-on-c64-part-1.html</id>
    <published>2018-05-18T00:00:00Z</published>
    <updated>2018-05-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This is the first part of a blog series on making a small game called <a href="http://nurpax.com/bintris">BINTRIS</a> for the Commodore 64.</p>
<p>Here are a some of the topics I plan to cover in the series:</p>
<ul>
<li>Tooling</li>
<li>Sprite multiplexing</li>
<li>Mixed text and bitmap mode display</li>
<li>Vertical raster scroll and flexible line distance (FLD)</li>
<li>A line-by-line sprite sine-wave animation</li>
<li>SID sound effects</li>
</ul>
<p>As most of these are well-documented on the internet, my posts won’t be full-blown tutorials but rather examples of how to apply the above techniques in a game. I’ll start this series by covering tools.</p>
<h2 id="bintris">BINTRIS</h2>
<p>BINTRIS is a puzzle game that plays a little like Tetris but using binary numbers. Here’s a little gameplay video:</p>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/RSAlFunPlYI?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<p>The idea is that each row is a binary number (black is zero, white is one) and you need to build rows that match the numbers listed below the DECIMAL heading.</p>
<p>Here’s a little teaser showcasing the readme.prg file from the bintris disk image:</p>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/AYDKdRmlxFs?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<p>The game will be released any day now – I’ll update this post with a download link when it’s out. I’ll also post some more videos once I have the final version captured on real hardware.</p>
<h2 id="how-to-develop-for-the-c64">How to develop for the C64</h2>
<p>Probably the best choice for developing for the C64 is to use an emulator. I went with <a href="vice">VICE</a>.</p>
<p>I used <a href="kickass">KickAssembler</a> for compiling my assembly code. Its macro support is some seriously good stuff – I wish I had something like this when I used to work on PC demos.</p>
<p>For editing and compiling 6510 assembly source, I ended up going with the <a href="https://packagecontrol.io/packages/Kick%20Assembler%20(C64)">Sublime Text 3 and KickAssembler package</a>. This sets up your editor such that you can just press F7 and it will compile and run your code on VICE. It also supports building a debug version of your binary that allows setting breakpoints to break into the VICE monitor (read: debugger). The monitor can be remotely accessed with telnet from your host machine. Editing monitor commands on your host makes things like copy &amp; paste easier.</p>
<p>I had some problems with the VICE emulator though. For example, sound is pretty buggy on my MacBook Pro and sometimes buggy even on Windows 10. I also couldn’t get video capture to work on Mac at all, and on Windows h.264 export crashes the emulator right away. I found <a href="http://www.hoxs64.net/default.aspx">hoxs64</a> to have more stable sound but it’s otherwise not as featureful as VICE. I also tried to build my own VICE binary on Windows but that got ugly real quick when I tried to deal with the MinGW build environment.</p>
<p>Other tools used to develop BINTRIS:</p>
<ul>
<li><a href="multipaint">Multipaint</a> – for painting pixel graphics and sprites. (Although in the end, most sprites were done in Photoshop.)</li>
<li><a href="petscii">PETSCII editor</a> – for PETSCII “art” used in the readme.prg.</li>
<li><a href="https://github.com/nurpax/c64-sid-edit">SID sound editor</a> – I wrote this C64 sound editor to make it easier to tweak SID registers for my sound effects.</li>
<li><a href="https://github.com/nurpax/c64-sid-edit/blob/master/GrabSounds.hs">VICE snapshot parser</a> – a Haskell program I wrote for parsing memory snapshots. I used this to save/load the SID editor sounds. Rather than implementing save/load into my C64 app, I grabbed the sound data directly from RAM.</li>
<li><a href="https://sourceforge.net/projects/goattracker2/">GoatTracker</a> - for SID music.</li>
<li>Python - a bunch of LUT generators using numpy and PIL.</li>
</ul>
<h2 id="c64-learning-resources">C64 learning resources</h2>
<p>Here are some of my favorite C64 resources:</p>
<ul>
<li><a href="http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt">The MOS 6567/6569 video controller (VIC-II) and its application in the Commodore 64</a> – a pretty exchaustive document on the VIC-II graphics chip.</li>
<li><a href="https://www.c64-wiki.com/wiki/Main_Page">c64-wiki</a> – I often use this for looking up assembly instructions (see e.g. <a href="https://www.c64-wiki.com/wiki/BPL">BPL</a>. I’m not a huge fan of some of the pages though. For example, the instruction reference pages would be better if they specified how an instruction works with pseudo code.</li>
<li><a href="http://sta.c64.org/cbm64mem.html">C64 memory map</a> – this is a super helpful reference for C64 registers.</li>
<li><a href="http://codebase64.org/doku.php">codebase64</a> – found a bunch of good examples here (but also many bugs!)</li>
</ul>
<p>The list is missing a good starter guide for 6510 assembly.</p>
<h2 id="next-in-series">Next in series</h2>
<p>The next blog in the series will showcase the game itself, hopefully with final version captured on real hardware.</p>
<!--$snippet("includes/bintris-c64-series.html")$-->
<!--
Bug:

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">You can tell the release day is near when your game goes all wonky like this. <a href="https://twitter.com/hashtag/bintris?src=hash&amp;ref_src=twsrc%5Etfw">#bintris</a> <a href="https://twitter.com/hashtag/c64?src=hash&amp;ref_src=twsrc%5Etfw">#c64</a> <a href="https://t.co/Dr7orgnkSF">pic.twitter.com/Dr7orgnkSF</a></p>&mdash; Janne Hellsten (@nurpax) <a href="https://twitter.com/nurpax/status/993934121935228929?ref_src=twsrc%5Etfw">May 8, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
-->
<!--
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/8UjTcipfRJc?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
-->
<p>Thoughts? Questions? Let’s discuss on <a href="https://www.reddit.com/r/c64coding">/r/c64coding</a>.</p>]]></summary>
</entry>
<entry>
    <title>3D Starfield in React Native</title>
    <link href="http://nurpax.github.com/posts/2018-03-02-react-native-60fps-starfield.html" />
    <id>http://nurpax.github.com/posts/2018-03-02-react-native-60fps-starfield.html</id>
    <published>2018-03-12T00:00:00Z</published>
    <updated>2018-03-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve been working on an iOS port of my web game <a href="http://nurpax.com/bintris">Bintris</a>. I ported the HTML/Javascript version to React Native (RN) to make it run on iOS.</p>
<p>One of the game’s main visual ingredients is the real-time 3D starfield background. I originally put it in as a kind of placeholder but came to like it over time. So I had to figure out a performant way to implement it on RN.</p>
<p>The web Bintris uses a pure-CSS starfield effect that I borrowed from <a href="https://codepen.io/keithclark/pen/ibEnk">here</a>. Here’s how my RN re-implementation looks like:</p>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/thBijc6x7e0?rel=0&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<p>Both the CSS and RN versions use a trick to project the starfield random 3d-points onto a fixed number of xy-planes. This makes it quite a bit faster to animate and render than animating each 3D point separately. In the above video, the starfield consists of ten Animated.Views each containing 150 random stars. Each star is an absolutely positioned view with a white background color.</p>
<p>React renders the starfield only once upon mounting. All further frame updates are done purely using RN animation with the native animation driver enabled using <code>useNativeDriver:true</code>. This moves starfield rendering completely off the main JavaScript UI thread. This results in buttery smooth animation and frees up the UI thread from processing all the 1500 views that make up the individual stars.</p>
<p>If you want to see it running on your phone, install the Expo app on your phone and use it to scan the QR code from <a href="https://snack.expo.io/@nurpax/starfield">this Expo Snack</a>. The full source code to the starfield is contained within the Snack project.</p>
<h2 id="improvements-ideas">Improvements ideas</h2>
<p>Here are some thoughts on what could still be improved:</p>
<ul>
<li><p><code>shouldRasterizerIOS</code> should probably be used for any views rendered on top of the starfield. Should you have any views that are rendered on top of the starfield, RN will render them at 60 FPS. If the views are complex, you may run into performance or battery consumption problems. The <code>shouldRasterizeIOS</code> should help by first rendering the static views into an image and then compositing the images on top using alpha blending. Unfortunately, I didn’t find enough information on how exactly the RN and/or iOS view renderer works, so I didn’t enable this for my menus.</p></li>
<li><p>The starfield would look smoother and less aliased if, instead of a white rectangle, a circle shaped image was used to render each individual star.</p></li>
<li><p>RN stylesheet documentation recommends using <code>StyleSheet.create()</code> instead of inline styles. I’m now using inline styles everywhere. There may be a performance benefit to using <code>StyleSheet.create()</code>. In my case though, each individual star needs its own stylesheet as a star’s absolute position must be set using a stylesheet.</p></li>
</ul>
<p>Thoughts? Questions? Let’s discuss on <a href="https://www.reddit.com/r/reactjs/comments/83yrad/60_fps_3d_starfield_in_react_native/">Reddit</a>.</p>]]></summary>
</entry>

</feed>
