<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>nurpax.github.com blog</title>
    <link href="http://nurpax.github.com/rss.xml" rel="self" />
    <link href="http://nurpax.github.com" />
    <id>http://nurpax.github.com/rss.xml</id>
    <author>
        <name>Janne Hellsten</name>
        <email>jjhellst@gmail.com</email>
    </author>
    <updated>2016-11-01T00:00:00Z</updated>
    <entry>
    <title>React Redux Todo app running on a Haskell server</title>
    <link href="http://nurpax.github.com/posts/2016-11-01-react-redux-haskell-snap.html" />
    <id>http://nurpax.github.com/posts/2016-11-01-react-redux-haskell-snap.html</id>
    <published>2016-11-01T00:00:00Z</published>
    <updated>2016-11-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I put together a single-page web app (SPA) todo example for use in my personal projects. Its most noteworthy feature is end-to-end authentication implemented using <a href="https://github.com/mjrussell/redux-auth-wrapper">redux-auth-wrapper</a> and <a href="https://jwt.io/">JWT</a>. The project implements a simple todo application with user account support. Data is persisted on a server implemented in Haskell. It’s not super complex but it took quite a bit of reading to put all the pieces together, so I figured I might as well publish it for others to learn from.</p>
<p>You can find the application source code <a href="https://github.com/nurpax/snap-reactjs-todo/tree/blog-0.1">on github</a>.</p>
<p>The project uses the following tools, libraries and techniques:</p>
<ul>
<li><a href="https://facebook.github.io/react/">React</a>, <a href="https://github.com/reactjs/redux">Redux</a> and <a href="https://github.com/reactjs/react-redux">React-redux</a></li>
<li><a href="https://webpack.github.io/">Webpack</a> and <a href="https://babeljs.io/">Babel</a> (for JSX, ES6+ and CSS modules)</li>
<li><a href="https://github.com/gaearon/redux-thunk">Redux-thunk</a> for async fetching in Redux actions</li>
<li><a href="https://github.com/ReactTraining/react-router">React-router</a> and <a href="https://github.com/reactjs/react-router-redux">React-router-redux</a> for routing</li>
<li><a href="https://github.com/mjrussell/redux-auth-wrapper">Redux-auth-wrapper</a> for implementing robust authenticated routing and login screens</li>
<li><a href="https://jwt.io/">JWT</a>-based authentication that works well with Redux and routing</li>
<li>Haskell for the backend using the <a href="http://snapframework.com/">Snap web framework</a> to serve the REST API</li>
<li>Roll-my-own JWT authentication code for the Haskell backend</li>
</ul>
<p>The development setup does not implement hot module reloading (HMR) or server-side rendering (SSR). I imagine it’s possible to extend this setup for HMR. I don’t know if SSR is feasible without a Node.js based server.</p>
<p>I won’t explain each and every one of the above libraries in details. They all have fairly good documentation and a whole bunch of tutorials on the net. Instead, I will just highlight some of the most relevant parts.</p>
<h1 id="client-side">Client-side</h1>
<p>Client routes are setup in <a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/client/containers/Root.js">client/containers/Root.js</a>:</p>
<pre><code>const Root = () =&gt; (
  &lt;Provider store={store}&gt;
    &lt;Router history={history}&gt;
      &lt;Route path=&#39;/&#39; component={Main} /&gt;
      &lt;Route path=&#39;/todos&#39; component={UserIsAuthenticated(TodoList)} /&gt;
      &lt;Route path=&#39;/login&#39; component={Login} /&gt;
      &lt;Route path=&#39;/profile&#39; component={UserIsAuthenticated(Profile)} /&gt;
      &lt;Route path=&#39;/signup&#39; component={SignUp} /&gt;
    &lt;/Router&gt;
  &lt;/Provider&gt;)</code></pre>
<p>This sets up various routes like the home screen, todo list and login and logout routes. Notice the <code>UserIsAuthenticated</code> higher-order component that applies authentication constraints on the <code>TodoList</code> and <code>Profile</code> components. Those routes won’t be accessible unless the user is logged in.</p>
<p>See <a href="https://github.com/mjrussell/redux-auth-wrapper">redux-auth-wrapper</a> for more information on setting up authentication and redux.</p>
<h2 id="authenticated-fetch">Authenticated fetch</h2>
<p>Client-side JWT handling is implemented in <a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/client/auth.js">client/auth.js</a>. It implements Redux actions and reducers related to user authentication. It exports a function called <code>fetchWithAuth</code> which is used instead of <code>fetch</code> whenever accessing API endpoints that require authentication.</p>
<p>Here’s an example of how <code>fetchWithAuth</code> is used in <a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/client/actions.js">client/actions.js</a> to save a todo item:</p>
<pre><code>export function saveTodo (todo) {
  return function (dispatch, getState) {
    return fetchWithAuth(getState, &#39;/api/todo&#39;, { method: &#39;POST&#39;, body: todo })
      .then(json =&gt; dispatch(receiveTodo(json)))
  }
}</code></pre>
<p>The <code>fetchWithAuth</code> function is basically just a wrapper around <code>fetch</code> that inserts the JWT user token into the Authorization header when issuing a fetch call.</p>
<p>It currently does not handle expired tokens, though. It should be easy to extend it such that it will detect an expired token error, and issue an action that triggers a client-side redirect to the login screen.</p>
<h1 id="api-server">API server</h1>
<p>The backend is written in Haskell. It uses the Snap framework to get a basic web server running. It’s main functionality is to persist users and todo items and serve them via a JSON API. Apart from the one static <a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/static/index.html">index.html</a> used to bootstrap React, the server does not render any HTML.</p>
<p>The relevant source files are:</p>
<ul>
<li><a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/src/Site.hs">src/Site.hs</a> – Routes and API implementation</li>
<li><a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/src/Db.hs">src/Db.hs</a> – <a href="https://hackage.haskell.org/package/aeson">sqlite-simple</a> code for persisting todo items into a SQLite3 database</li>
<li><a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/src/Snap/Snaplet/SqliteJwt.hs">src/Snaplet/SqliteJwt.hs</a> – A Snap middleware that implements user accounts, password hashing and salting using BCrypt, and JWT for sessionless authentication.</li>
</ul>
<p>The request handler for todo items looks like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleRestTodos ::</span> <span class="dt">H</span> ()
handleRestTodos <span class="fu">=</span> (method <span class="dt">GET</span> listTodos) <span class="fu">&lt;|&gt;</span> (method <span class="dt">POST</span> saveTodo)
  <span class="kw">where</span>
<span class="ot">    listTodos ::</span> <span class="dt">H</span> ()
    listTodos <span class="fu">=</span> replyJson query
      <span class="kw">where</span>
        query (<span class="dt">J.User</span> uid _) <span class="fu">=</span> withTop db <span class="fu">$</span> Db.listTodos (<span class="dt">Db.UserId</span> uid)

    saveTodo <span class="fu">=</span> <span class="kw">do</span>
      ps <span class="ot">&lt;-</span> reqJSON
      replyJson (query ps)
      <span class="kw">where</span>
        query ps (<span class="dt">J.User</span> uid _) <span class="fu">=</span>
          <span class="co">-- If the input todo id is Nothing, create a new todo.  Otherwise update</span>
          <span class="co">-- an existing one.</span>
          <span class="kw">case</span> ptId ps <span class="kw">of</span>
            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
              withTop db <span class="fu">$</span> Db.newTodo (<span class="dt">Db.UserId</span> uid) (ptText ps)
            <span class="dt">Just</span> tid <span class="ot">-&gt;</span> <span class="kw">do</span>
              <span class="kw">let</span> newTodo <span class="fu">=</span> <span class="dt">Db.Todo</span> tid (ptSavedOn ps) (ptCompleted ps) (ptText ps)
              withTop db <span class="fu">$</span> Db.saveTodo (<span class="dt">Db.UserId</span> uid) newTodo

<span class="ot">    replyJson ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> (<span class="dt">J.User</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">J.SqliteJwt</span> a) <span class="ot">-&gt;</span> <span class="dt">H</span> ()
    replyJson action <span class="fu">=</span> <span class="kw">do</span>
      res <span class="ot">&lt;-</span> with jwt <span class="fu">$</span> J.requireAuth action
      writeJSON res</code></pre></div>
<p>Query parameters for the <code>saveTodo</code> POST requests are passed in as JSON and parsed with the <a href="https://hackage.haskell.org/package/aeson">aeson</a> JSON parser. Static type checking enforces that invalid request parameters don’t get past the JSON parser.</p>
<p>Server-side authentication is implemented in the <a href="https://github.com/nurpax/snap-reactjs-todo/blob/blog-0.1/src/Snap/Snaplet/SqliteJwt.hs">SqliteJwt</a> module. It exports the <code>requireAuth</code> function which is used above to wrap request handlers. A wrapped handler will either be passed down the currently authenticated user or the request is terminated if JWT authentication failed.</p>
<h1 id="future-work">Future work</h1>
<p>The Haskell SqliteJwt module is work-in-progress and certainly not ready for production. For example, it doesn’t currently support token expiration or revoking existing tokens. It also hardcodes the site secret used to sign JWTs. I am planning to develop this module further to support these features and maybe publish it on Hackage.</p>
<p>It’d also be interesting to plug in an external authentication mechanism like Google OAuth 2.0. I haven’t found good examples on how to do this robustly. There is discussion about this in redux-auth-wrapper <a href="https://github.com/mjrussell/redux-auth-wrapper/issues/46">github issue #46</a> but I haven’t tried toying around with those ideas yet. It will probably be quite a bit trickier than local authentication.</p>
<p>Thanks for reading!</p>]]></summary>
</entry>
<entry>
    <title>Fixing Emacs GDB mode, part 1</title>
    <link href="http://nurpax.github.com/posts/2014-10-12-fixing-gdb-many-windows-source-buffer.html" />
    <id>http://nurpax.github.com/posts/2014-10-12-fixing-gdb-many-windows-source-buffer.html</id>
    <published>2014-10-12T00:00:00Z</published>
    <updated>2014-10-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I like using use the Emacs <code>gud-mode</code> for my debugging sessions. Unfortunately, it’s pretty quirky in how it assigns source files to Emacs windows. This totally breaks my debugging flow. Today I decided to document this misbehavior and in a later post, explain how to fix it.</p>
<p>The problem occurs when stepping through a program in <code>gud-mode</code> with <code>gdb-many-windows</code> enabled. I’d expect Emacs to assign new source buffers into the dedicated middle-left source window. Instead, source buffers are (randomly?) assigned on top of other GDB buffers like the GDB comint window. The layout problem gets even worse with multiple Emacs frames. Here are my repro steps with a diagram of what happens and how I’d like Emacs to behave instead.</p>
<p>Here are the steps to reproduce the problem on Emacs 24.3.1.</p>
<p>Bind <code>gud-next</code> and <code>gud-step</code> to <code>[f7]</code> and <code>[f8]</code>:</p>
<div class="sourceCode"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span class="co">;; This goes into your .emacs</span>
(add-hook &#39;gud-mode-hook
          &#39;(<span class="kw">lambda</span> ()
             (global-set-key (kbd <span class="st">&quot;&lt;f7&gt;&quot;</span>) &#39;gud-next)
             (global-set-key (kbd <span class="st">&quot;&lt;f8&gt;&quot;</span>) &#39;gud-step)))</code></pre></div>
<p>Build my example program:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone https://gist.github.com/d94e2666ae05b58906c6.git emacs-gdb-proj
<span class="bu">cd</span> emacs-gdb-proj
<span class="fu">make</span></code></pre></div>
<p>Start Emacs and enter GDB:</p>
<pre><code>emacs &amp;
M-x gdb
M-x gdb-many-windows</code></pre>
<p>Use <code>*gud-test*</code> comint buffer to set a break point in <code>main()</code> and run the program:</p>
<pre><code>(gdb) b main
Breakpoint 1 at 0x4004b1: file main.c, line 6.
(gdb) r</code></pre>
<p>The window layout should now look something like this (the source window with <code>main.c</code> highlighted):</p>
<svg width="600" height="400">
<!-- gud-test, locals of test -->
<g transform="translate(0 0)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-size="20" font-family="Helvetica" fill="rgb(131,148,150)">*gud-test*</text> </g> <g transform="translate(300 0)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*locals of test*</text> </g> <!-- source window, output window --> <g transform="translate(0 133)"> <rect width="50%" height="33%" style="fill:rgb(101,123,131); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(0,43,53)">./main.c</text> </g> <g transform="translate(300 133)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*input/output of test*</text> </g> <!-- stack frame, breakpoints --> <g transform="translate(0 266)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*stack frames of test*</text> </g> <g transform="translate(300 266)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*breakpoints of test*</text> </g>
</svg>
<p>The contents of <code>main.c</code> look like this:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main() 
{
    foo();
    foo();
    foo();
}</code></pre></div>
<p>If you step into the <code>foo()</code> function with <code>[f8]</code>, you’re taken into the <code>b.c</code> source file, which opens as expected into left-middle source window.</p>
<p>However, if instead of directly stepping into <code>foo()</code> you open another source file in the source window, say, <code>C-x C-f</code>’ing the <code>Makefile</code> from the test project and hit <code>[f8]</code> again, BOOM, the <code>b.c</code> buffer opens in the comint <code>*gud-test*</code> window and not in the source window! The window layout now looks like this:</p>
<svg width="600" height="400">
<!-- b.c, locals of test -->
<g transform="translate(0 0)"> <rect width="50%" height="33%" style="fill:rgb(101,123,131); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(0,43,53)">./b.c</text> </g> <g transform="translate(300 0)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*locals of test*</text> </g> <!-- source window, output window --> <g transform="translate(0 133)"> <rect width="50%" height="33%" style="fill:rgb(101,123,131); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(0,43,53)">./Makefile</text> </g> <g transform="translate(300 133)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*input/output of test*</text> </g> <!-- stack frame, breakpoints --> <g transform="translate(0 266)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*stack frames of test*</text> </g> <g transform="translate(300 266)"> <rect width="50%" height="33%" style="fill:rgb(0,43,53); stroke-width:2; stroke:rgb(0,0,0)" /> <text x="5%" y="18%" font-family="Helvetica" font-size="20" fill="rgb(131,148,150)">*breakpoints of test*</text> </g>
</svg>
<p>Another way to trigger the same:</p>
<ol style="list-style-type: decimal">
<li>Start <code>gud-mode</code> + <code>gdb-many-windows</code> as above.</li>
<li>Step into <code>foo()</code>.</li>
<li>Open the <code>Makefile</code> into the source window.</li>
<li>Click on any of the functions/source files into bottom-left stack frame window.</li>
</ol>
<p>Again, the source file opens on top of the upper-left comint window.</p>
<p>I did find some related Stackoverflow posts. <a href="http://stackoverflow.com/questions/3473134/emacs-23-1-1-with-gdb-forcing-source-windows">This post</a> contains a <code>defadvice</code> trick that seems to work for the latter reproduction steps, but it didn’t make a difference in the former case. <a href="http://stackoverflow.com/questions/24386672/use-gdb-within-emacs-always-show-the-source-code.">Another post</a> discusses a related problem but concludes that there’s no problem if you just use <code>gdb-many-windows</code>.</p>
<p>I hope to resolve this soon and update this post with a solution.</p>]]></summary>
</entry>
<entry>
    <title>REST API testing in Haskell with wreq and test-framework</title>
    <link href="http://nurpax.github.com/posts/2014-05-03-rest-testing-with-wreq.html" />
    <id>http://nurpax.github.com/posts/2014-05-03-rest-testing-with-wreq.html</id>
    <published>2014-05-04T00:00:00Z</published>
    <updated>2014-05-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This blog post is about my experiences rewriting Node.js/JavaScript-based REST unit tests in Haskell using <a href="http://hackage.haskell.org/package/wreq">wreq</a> and <a href="https://batterseapower.github.io/test-framework/">test-framework</a>. I hope the test cases presented in this post are useful practical examples of using <code>test-framework</code> for IO-heavy testing.</p>
<p>The tests discussed in this post are for my <a href="https://github.com/nurpax/hswtrack">Hswtrack</a> project. Hswtrack is a web application for exercise tracking. The application server is built with <a href="http://snapframework.com/">Snap</a> and the UI in JavaScript with JQuery and <a href="http://handlebarsjs.com/">Handlebars.js</a>.</p>
<p>Here’s a summary of what type of REST entry points will be tested in this post:</p>
<table>
<thead>
<tr class="header">
<th>Entry point</th>
<th>Verb</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>/rest/login</code></td>
<td>POST</td>
<td>Login with <code>login</code> and <code>password</code> parameters.</td>
</tr>
<tr class="even">
<td><code>/rest/new_user</code></td>
<td>POST</td>
<td>Create a user with <code>login</code> and <code>password</code> parameters.</td>
</tr>
<tr class="odd">
<td><code>/rest/app</code></td>
<td>GET</td>
<td>Get logged in user login name and status.</td>
</tr>
<tr class="even">
<td><code>/rest/exercise</code></td>
<td>GET</td>
<td>List existing exercises.</td>
</tr>
<tr class="odd">
<td><code>/rest/exercise</code></td>
<td>POST</td>
<td>Create a new exercise with <code>name</code> and <code>type</code> parameters.</td>
</tr>
</tbody>
</table>
<p>Most entry point require a prior successful login. The response body is encoded as JSON. When called unauthenticated, the server returns an HTTP 403 error code.</p>
<p>As the server talks to the client in JSON, I initially thought JavaScript + NodeJS would be a nice combo for developing these tests. I first tried <a href="http://frisbyjs.com/">Frisby</a> which looked simple and had good looking documentation. Unfortunately it turned out to be cumbersome for the types of tests I wanted to write. I also tried writing my own test framework with Q promises but that came out like <a href="https://twitter.com/SlexAxton/status/455568049181958144">Tea party code</a> too. (You can view the source for my JavaScript tests <a href="https://github.com/nurpax/hswtrack/blob/0e820183ce28a6e62056c0dda7c99d5109ad3e68/test/rest/tests/workout.js">here</a>.)</p>
<p>Feeling dissatisfied about the state of my tests, I decided to rewrite my unit tests in Haskell.</p>
<h2 id="types-of-tests">Types of tests</h2>
<p>I wanted to develop the following types of tests:</p>
<ul>
<li>Test that user creation works</li>
<li>Test that login works</li>
<li>Test that REST entry points deny access if not logged in</li>
<li>Test object creation, update and deletion when logged in</li>
<li>Test that attempts to modify or delete other users’ data are rejected</li>
</ul>
<p>Any tests that modify or create objects need to run with an authenticated user. This means each such test would need to either log in as part of its init sequence or have its authentication cookies passed into it. I went for the latter approach as it allows logging in once and running multiple tests with the same cookies.</p>
<p>I define top-level test cases called <code>createUserTests</code> and <code>loginUserTests</code> which first perform user creation or login, followed by running a list of sub-tests with cookies acquired from the login process. The sequencing is explicitly declared by using <code>test-framework</code>’s <code>TestGroup</code>s and <code>Test</code>s.</p>
<p>Here’s the definition of <code>loginUserTests</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Login a user and run a list of subtests with cookies acquired</span>
<span class="co">-- from the login process.</span>
<span class="ot">loginUserTests ::</span> [(<span class="dt">String</span>, <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Assertion</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Test</span>
loginUserTests tests <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> post (mkUrl <span class="st">&quot;/rest/login&quot;</span>) [<span class="st">&quot;login&quot;</span> <span class="fu">:=</span> login, <span class="st">&quot;password&quot;</span> <span class="fu">:=</span> passwd]
  <span class="kw">let</span> opts <span class="fu">=</span> defaults <span class="fu">&amp;</span> cookies <span class="fu">.~</span> (r <span class="fu">^.</span> responseCookieJar)
  return
    <span class="fu">.</span> testGroup <span class="st">&quot;Tests with logged in user&quot;</span>
    <span class="fu">.</span> map (\(name, test) <span class="ot">-&gt;</span> testCase name (test opts)) <span class="fu">$</span> tests</code></pre></div>
<p>It performs a HTTP POST on <code>/rest/login</code> with the test user’s login credentials, grabs the authentication cookies with <code>defaults &amp; cookies .~ (r ^. responseCookieJar)</code> and passes them to sub-tests so that they can run authenticated.</p>
<p>Here’s how <code>loginUserTests</code> gets used:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Test case that tests that we&#39;re successfully logged in</span>
<span class="co">-- Options must contain the necessary login cookies.</span>
<span class="ot">testLoggedInOk ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Assertion</span>
testLoggedInOk opts <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> getWith opts (mkUrl <span class="st">&quot;/rest/app&quot;</span>)
  <span class="dt">Just</span> <span class="dt">True</span> <span class="fu">@=?</span> (r <span class="fu">^?</span> responseBody <span class="fu">.</span> key <span class="st">&quot;loggedIn&quot;</span> <span class="fu">.</span> _Bool)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  defaultMain
  [ buildTest <span class="fu">$</span> createUserTests [(<span class="st">&quot;logged in?&quot;</span>, testLoggedInOk)]
  , buildTest <span class="fu">$</span> loginUserTests  [(<span class="st">&quot;logged in?&quot;</span>, testLoggedInOk)]
  ]</code></pre></div>
<p>Function <code>testLoggedInOk</code> tests that it can HTTP GET <code>/rest/app</code> successfully. It also tests that the returned JSON object contains a field <code>loggedIn</code> with value <code>true</code>.</p>
<h2 id="negative-testing">Negative testing</h2>
<p>One shouldn’t forget about negative testing, so let’s develop a test for checking that entry points correctly respond with an error 403 on unauthenticated access:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- GET requests against &#39;url&#39; and expect to get error 403 back</span>
<span class="ot">testLoggedInFail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Assertion</span>
testLoggedInFail url opts <span class="fu">=</span> <span class="kw">do</span>
  E.try (getWith opts url) <span class="fu">&gt;&gt;=</span> check
  <span class="kw">where</span>
    check (<span class="dt">Left</span> (<span class="dt">HT.StatusCodeException</span> s _ _))
      <span class="fu">|</span> s <span class="fu">^.</span> statusCode <span class="fu">==</span> <span class="dv">403</span> <span class="fu">=</span> assertBool <span class="st">&quot;error ok&quot;</span> <span class="dt">True</span>
      <span class="fu">|</span> otherwise              <span class="fu">=</span> assertBool <span class="st">&quot;unexpected status code&quot;</span> <span class="dt">False</span>
    check (<span class="dt">Left</span> _)  <span class="fu">=</span> assertBool <span class="st">&quot;unexpected exception caught&quot;</span> <span class="dt">False</span>
    check (<span class="dt">Right</span> r) <span class="fu">=</span> assertBool <span class="st">&quot;req should&#39;ve failed&quot;</span> <span class="dt">False</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  defaultMain [testGroup <span class="st">&quot;Require auth fail&quot;</span> requireAuthFail]
  <span class="kw">where</span>
    requireAuthFail <span class="fu">=</span>
      map (\u <span class="ot">-&gt;</span> testCase u (testLoggedInFail (mkUrl u) defaults)) authReqd
    <span class="co">-- REST entry points which require user to be logged in</span>
    authReqd <span class="fu">=</span> [ <span class="st">&quot;/rest/app&quot;</span>
               , <span class="st">&quot;/rest/weights&quot;</span>
               , <span class="st">&quot;/rest/notes&quot;</span>
               , <span class="st">&quot;/rest/exercise&quot;</span>
               , <span class="st">&quot;/rest/workout/exercise&quot;</span>
               , <span class="st">&quot;/rest/workout&quot;</span>
               , <span class="st">&quot;/rest/workout&quot;</span>
               , <span class="st">&quot;/rest/stats/workout&quot;</span>
               ]</code></pre></div>
<h2 id="creating-objects">Creating objects</h2>
<p>Here we will test two entry points: one for creating a new exercise like “Chin-ups” and one for listing existing exercises. Creation is a HTTP POST to <code>/rest/exercise</code> and listing exercises is HTTP GET <code>/rest/exercise</code>.</p>
<p>A successful POST to <code>/rest/exercise</code> will create a new object on the server and return the object to the client as JSON. Here’s what that repsonse might look like:</p>
<pre><code>{ &quot;id&quot;:2, &quot;name&quot;: &quot;Chin-ups&quot;, &quot;type&quot;:&quot;BW&quot; }</code></pre>
<p>A successful GET of <code>/rest/exercise</code> will retrieve the full list of available exercises. It looks something like this:</p>
<pre><code>[
  { &quot;id&quot;:1, &quot;name&quot;: &quot;Push-ups&quot;, &quot;type&quot;:&quot;BW&quot; },
  { &quot;id&quot;:2, &quot;name&quot;: &quot;Chin-ups&quot;, &quot;type&quot;:&quot;BW&quot; }
]</code></pre>
<p>To test creating exercise objects, we’ll create an exercise, verify that its returned properties match what we gave on creation, and finally retrieve the complete exercise list and check that the object is listed.</p>
<p>Here’s the code for the above test strategy. The <a href="http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html">Aeson Lens API</a> is particularly handy for this type of ad hoc JSON value inspection!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testAddExercise ::</span> <span class="dt">Options</span> <span class="ot">-&gt;</span> <span class="dt">Assertion</span>
testAddExercise opts <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> name <span class="fu">=</span> <span class="st">&quot;Chin-ups&quot;</span><span class="ot"> ::</span> <span class="dt">T.Text</span>
      ty   <span class="fu">=</span> <span class="st">&quot;BW&quot;</span><span class="ot">       ::</span> <span class="dt">T.Text</span>
  r <span class="ot">&lt;-</span> postWith opts (mkUrl <span class="st">&quot;/rest/exercise&quot;</span>) [<span class="st">&quot;name&quot;</span> <span class="fu">:=</span> name, <span class="st">&quot;type&quot;</span> <span class="fu">:=</span> ty]
  <span class="co">-- Verify that the newly created object matches creation params</span>
  name <span class="fu">@=?</span> r <span class="fu">^.</span> responseBody <span class="fu">.</span> key <span class="st">&quot;name&quot;</span> <span class="fu">.</span> _String
  ty   <span class="fu">@=?</span> r <span class="fu">^.</span> responseBody <span class="fu">.</span> key <span class="st">&quot;type&quot;</span> <span class="fu">.</span> _String
  <span class="co">-- Verify that the object ended up in the global list of exercises</span>
  <span class="kw">let</span> (<span class="dt">Just</span> oid) <span class="fu">=</span> r <span class="fu">^?</span> responseBody <span class="fu">.</span> key <span class="st">&quot;id&quot;</span> <span class="fu">.</span> _Integer
  r <span class="ot">&lt;-</span> getWith opts (mkUrl <span class="st">&quot;/rest/exercise&quot;</span>)
  assertBool <span class="st">&quot;oid should be in list&quot;</span> (oid <span class="ot">`elem`</span> exercises r)
  <span class="kw">where</span>
    exercises r <span class="fu">=</span> r <span class="fu">^..</span> responseBody <span class="fu">.</span> values <span class="fu">.</span> key <span class="st">&quot;id&quot;</span> <span class="fu">.</span> _Integer</code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I only just got started developing these tests and so coverage is still poor. I’m pretty sure that as I develop new tests, interesting ways to restructure and generalize these tests will emerge.</p>
<p>You can find the full source code to these tests <a href="https://github.com/nurpax/hswtrack/blob/blog-may-version/test/Test.hs">here</a>.</p>
<p>Thanks for reading!</p>]]></summary>
</entry>
<entry>
    <title>Installing Haskell Platform on Debian testing</title>
    <link href="http://nurpax.github.com/posts/2014-02-20-haskell-platform-installation.html" />
    <id>http://nurpax.github.com/posts/2014-02-20-haskell-platform-installation.html</id>
    <published>2014-02-20T00:00:00Z</published>
    <updated>2014-02-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I usually hit some snags when installing Haskell Platform (HP) on either Ubuntu or Debian. I thought this time I would get lucky, and get it installed without trouble.</p>
<h2 id="first-attempt">First Attempt</h2>
<p>In anticipation of a great success, I first blew away all my local installs of HP and GHC, followed by direct <code>haskell-platform</code> package installation:</p>
<pre><code>apt-get install haskell-platform</code></pre>
<p>D’oh, Debian testing’s HP is at 2012.2.0.0. Too old, I want a later version.</p>
<p>HP 2013.2.0.0 requires GHC 7.6.3, so let’s install that. I follow the links on <a href="http://www.haskell.org/platform/linux.html">Haskell Platform for Linux</a> and find the GHC 7.6.3 binary release. Trying to install it according to its installation steps..</p>
<p>Hmm, a problem with <code>libgmp.so.3</code>:</p>
<pre><code>~/t/ghc-7.6.3$ ./configure 
checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: 
error while loading shared libraries: libgmp.so.3: cannot open shared object file: 
No such file or directory</code></pre>
<p>I try installing <code>libgmp.so.3</code>:</p>
<pre><code>apt-get install libgmp-dev</code></pre>
<p>Oh, it’s already at a newer version, i.e., at <code>libgmp.so.10</code>.</p>
<p>Googling.. Oh, symlink to fake that I have libgmp.so.3. Sounds dodgy. Well, I’ll install GHC from source instead.</p>
<p>So I download the GHC 7.6.3 source package, build it and install it. At this point you need to have <em>some</em> older version of GHC still installed. So I use GHC 7.4.1 from the Debian testing package.</p>
<p>With all this done, installing Haskell Platform from source is easy if you managed to correctly install all the prerequisites.</p>
<p>Then I try to update my <code>cabal-install</code>, so I do:</p>
<pre><code>cabal update
cabal install cabal-install</code></pre>
<p>Whoops:</p>
<pre><code>Building cabal-install-1.18.0.2...
Preprocessing executable &#39;cabal&#39; for cabal-install-1.18.0.2...

Main.hs:118:8:
    Could not find module `Distribution.Version&#39;
    There are files missing in the `Cabal-1.18.1.1&#39; package,
    try running &#39;ghc-pkg check&#39;.
    Use -v to see a list of the files searched for.</code></pre>
<p>Even though I had blown away my <code>.cabal</code> and previous HP installation directories from under my <code>$HOME</code>, I still had managed to leave in a <code>.ghc</code> directory. Nuking that fixed the last problem.</p>
<h2 id="final-installation-steps">Final Installation Steps</h2>
<p>For my future reference, here are the high-level steps I took to install the latest released Haskell Platform:</p>
<ol style="list-style-type: decimal">
<li>Prerequisites: some version of GHC installed. In my case GHC 7.4.1 from Debian. Various other packages are needed for HP, these are easy to google so not listing them here.</li>
<li>Download GHC 7.6.3 source release, standard <code>./configure &amp;&amp; make &amp;&amp;    make install</code> installation</li>
<li>Check that <code>ghc --version</code> is 7.6.3. If it’s not, your PATH points to the previous GHC version.
<ul>
<li>Not sure if it’s recommended to remove the previous GHC installation at this point. Will I get into trouble with conflicting GHC versions if I don’t remove it here?</li>
<li>Removed GHC 7.4.1 with <code>apt-get remove ghc</code> and <code>hash -r</code> to let bash know <code>ghc</code> is at a new location now.</li>
</ul></li>
<li>Download the Haskell Platform 2013.2.0.0 source tarball from <a href="http://www.haskell.org/platform/linux.html">haskell.org/platform/linux.html</a>
<ul>
<li>Install as per instructions while being careful to choose a global package database installation as opposed to a user local package db. Otherwise you may face issues like <a href="https://github.com/haskell/cabal/issues/1695">cabal-install #1695</a>.</li>
</ul></li>
</ol>
<p>Phew, now it’s all done.</p>]]></summary>
</entry>
<entry>
    <title>Benchmarking sqlite-simple</title>
    <link href="http://nurpax.github.com/posts/2013-08-17-sqlite-simple-benchmarking.html" />
    <id>http://nurpax.github.com/posts/2013-08-17-sqlite-simple-benchmarking.html</id>
    <published>2013-08-17T00:00:00Z</published>
    <updated>2013-08-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I recently benchmarked my Haskell SQLite bindings package <a href="https://github.com/nurpax/sqlite-simple">sqlite-simple</a>. I was curious to know how sqlite-simple performance compares to native C, Python and other Haskell database bindings. Initial results for sqlite-simple were extremely poor but improved significantly after optimizations. This post will present the results of this benchmarking. It also discusses some of the optimizations that resulted from this performance analysis.</p>
<p>Initially sqlite-simple scored barely over 50K rows/s. Optimizations brought this up to 1.8M rows/s, a nice 34x improvement.</p>
<h2 id="setup">Setup</h2>
<p>Here’s the setup I used for running my experiments:</p>
<ul>
<li>64-bit Debian running inside VirtualBox (with only a single core enabled)</li>
<li>Quad-core Intel Core i7 at 3.2GHz</li>
<li>GHC 7.4.2 from the Haskell Platform</li>
<li>MySQL 5.5.28, PostgreSQL 9.1.7</li>
<li>Package versions:
<ul>
<li><a href="http://hackage.haskell.org/package/direct-sqlite-2.3.3.1">direct-sqlite-2.3.3</a></li>
<li><a href="http://hackage.haskell.org/package/sqlite-simple-0.3.0.0">sqlite-simple-0.3.0.0</a></li>
<li><a href="http://hackage.haskell.org/package/mysql-simple-0.2.2.4">mysql-simple-0.2.2.4</a></li>
<li><a href="http://hackage.haskell.org/package/mysql-0.1.1.4">mysql-0.1.1.4</a></li>
<li><a href="http://hackage.haskell.org/package/postgresql-simple-0.2.4.1">postgresql-simple-0.2.4.1</a></li>
<li><a href="http://hackage.haskell.org/package/postgresql-libpq-0.8.2.1">postgresql-libpq-0.8.2.1</a></li>
</ul></li>
</ul>
<h2 id="what-was-benchmarked">What was benchmarked</h2>
<p>The high-level operation of the benchmark is:</p>
<ol style="list-style-type: decimal">
<li>Setup: Initialize a table <code>testdata</code> with 10000 rows of data</li>
<li>Measure the time it takes to query the first column of all these rows.</li>
</ol>
<p>The schema consists of a single <code>testdata</code> table, defined as:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> testdata (<span class="kw">id</span> <span class="dt">INTEGER</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, str TEXT, t <span class="dt">TIMESTAMP</span>)</code></pre></div>
<p>See <a href="https://github.com/nurpax/db-bench/tree/master/db-util">db-bench/db-util</a> for more details.</p>
<p>The sqlite-simple query being measured is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">selectInts ::</span> <span class="dt">S.Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
selectInts conn <span class="fu">=</span> <span class="kw">do</span>
  rows <span class="ot">&lt;-</span> S.query_ conn <span class="st">&quot;SELECT id FROM testdata&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> [(<span class="dt">S.Only</span> <span class="dt">Int</span>)]
  checksum <span class="fu">$</span> foldl&#39; (\acc (<span class="dt">S.Only</span> v) <span class="ot">-&gt;</span> v <span class="fu">+</span> acc) <span class="dv">0</span> rows</code></pre></div>
<p>Basically, it SELECTs all the rows from the <code>testdata</code> table and converts the result into a Haskell list of <code>Int</code>s and, as a sanity check, sums the resulting integers together.</p>
<p>Several variants of this function are benchmarked. The main variants for SQLite are:</p>
<ul>
<li>direct-sqlite <code>selectIntsDS</code>: Lowest possible API level - least memory allocated</li>
<li>sqlite-simple <code>selectIntsFold</code>: Convert rows into Haskell data but fold over rows to avoid allocating memory for all rows</li>
<li>sqlite-simple <code>selectInts</code>: Convert rows into Haskell list containing all the rows</li>
</ul>
<p>We’ll focus mostly on <code>selectInts</code> when comparing against other implementations.</p>
<p>You can find implementations of the same for various Haskell database libraries under <a href="https://github.com/nurpax/db-bench/tree/master/haskell">db-bench/haskell</a>. C and Python implementations are under <a href="https://github.com/nurpax/db-bench/tree/master/native">db-bench/native</a> and <a href="https://github.com/nurpax/db-bench/tree/master/python">db-bench/python</a>, respectively.</p>
<h2 id="establishing-performance-targets">Establishing performance targets</h2>
<p>My benchmarking goal was to figure out how much overhead the sqlite-simple library adds on top of raw SQLite performance. Ideally, a query should spend all its time in native SQLite and zero time in Haskell bindings.</p>
<p>To better focus optimization work, I first set out to establish some reasonable performance targets to compare against. Establishing targets was straightforward. As sqlite-simple runs on top of direct-sqlite, the sqlite-simple can only be as fast as direct-sqlite. As direct-sqlite runs on top of the native SQLite library, the fastest sqlite-simple and direct-sqlite can possibly go is as fast as SQLite.</p>
<p>To turn this into numbers, I implemented multiple versions of my query benchmark (in order of fastest to slowest):</p>
<ul>
<li>A native C benchmark on top of the SQLite library (<a href="https://github.com/nurpax/db-bench/tree/master/native/main.c">source</a>)</li>
<li>Haskell: A Haskell version using direct-sqlite (<a href="https://github.com/nurpax/db-bench/tree/master/haskell/Sqlite.hs">source</a>, see function <code>selectInts</code>)</li>
<li>A Haskell version using sqlite-simple (<a href="https://github.com/nurpax/db-bench/tree/master/haskell/Sqlite.hs">source</a>, see function <code>selectIntsDS</code>)</li>
</ul>
<p>Here’s how they perform:</p>
<div>
<h4 id="native-c-vs-haskell-bindings-rowss">Native C vs Haskell bindings (rows/s)</h4>
<div id="chart-c-vs-haskell" style="width:600px;height:360px;">

</div>
</div>
<h2 id="results-analysis">Results analysis</h2>
<p>The collected benchmark data was used to identify various performance improvement opportunities in sqlite-simple.</p>
<p>Original performance without optimizations was just barely over 50K rows/s. This was a performance bug I caused when I forked sqlite-simple from postgresql-simple. The problem was in a function called <code>stepStmt</code> that should’ve been tail recursive but wasn’t. Fixing this in <a href="https://github.com/nurpax/sqlite-simple/commit/d2b6f6a50e116e1bad28395eac4646c1e6b34c4b">d2b6f6a5</a> nicely bumped up the score from 53K to 750K rows/s.</p>
<p>The next couple of optimizations dealt mostly with clean up to reduce allocation rate. With <a href="https://github.com/nurpax/sqlite-simple/commit/3239d474f033b2ab048744c9ea177b1e36930cce">3239d474f0</a> and <a href="https://github.com/nurpax/sqlite-simple/commit/0ee050807ded66b2eb34238f2a8d91cde6be8aa1">0ee050807d</a>, the benchmark score went up from 750K to 764K rows/s.</p>
<p>At this point I ran out of low hanging fruit in sqlite-simple and started to look elsewhere for optimizations. A low-level direct-sqlite benchmark was clocking around 2.43M rows/s which seemed a little low when a C implementation of the same was processing rows at almost 6.9M rows/s. Even a Python reimplementation of my benchmark case was faster at 2.5M rows/s. To highlight how large the performance delta between C and direct-sqlite were, it’s helpful to turn the comparison into absolute clock cycles. On my 3.2GHz machine, 6.9M rows/s means SQLite spends roughly 460 clock cycles per row.</p>
<p>Similarly, at 2.43M rows/s on direct-sqlite, each row cost roughly 1300 clock cycles out of which 460 was spent in the native SQLite library. Somehow roughly 840 clock cycles per row were spent in Haskell SQLite bindings. The overhead of just calling into SQLite from Haskell was higher than the actual cost of computing the result set inside SQLite! Yet, there wasn’t much going on in the wrapper library.</p>
<p>Consider the innerloop of the direct-sqlite benchmark:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumRowsColumnInt64 ::</span> <span class="dt">DS.Statement</span> <span class="ot">-&gt;</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span>
sumRowsColumnInt64 stmt <span class="fu">!</span>acc <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> DS.step stmt
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">DS.Row</span> <span class="ot">-&gt;</span>
      <span class="kw">do</span>
        i <span class="ot">&lt;-</span> DS.columnInt64 stmt <span class="dv">0</span>
        sumRowsColumnInt64 stmt (acc <span class="fu">+</span> i)
    <span class="dt">DS.Done</span> <span class="ot">-&gt;</span>
      return acc</code></pre></div>
<p>The direct-sqlite calls <code>DS.step</code> and <code>DS.columnInt64</code> map quite directly to their native SQLite counterparts <code><a href="http://www.sqlite.org/c3ref/step.html">sqlite3_step</a></code> and <code><a href="http://www.sqlite.org/c3ref/column_blob.html">sqlite3_column_int</a></code>. Thus the expectation is that their cost should be roughly the same as in the C version of this benchmark.</p>
<p>No matter how bad a compiler you might have, there’s no way the simple Haskell code around <code>sqlite3_step</code> and <code>sqlite3_column_int</code> would add up to 840 clocks per row.</p>
<p>Turns out FFI call overhead dominated this benchmark. It was possible to reduce this overhead by using the <code>unsafe</code> FFI calling convention for some of the SQLite column accessors. This change was made in direct-sqlite <a href="https://github.com/IreneKnapp/direct-sqlite/pull/20">pull request #20</a>. As the name <code>unsafe</code> implies, it’s not OK to simply mark all FFI functions as unsafe – please refer to the pull request discussion for details. The tl;dr of the FFI discussion was that it’s OK to mark result data accessors like <code>sqlite3_column_int64</code> and <code>sqlite3_column_count</code> as <code>unsafe</code> but that any functions doing the actual query heavy lifting like <code>sqlite3_step</code> should be kept safe.</p>
<p>The FFI optimizations were a big deal: the direct-sqlite benchmark score went up from 2.43M to 3.6M rows/s. As expected, this bumped up the sqlite-simple score up to 1.8M rows/s.</p>
<p>The following chart summarizes how performance progressed through the above optimizations:</p>
<div>
<h4 id="optimization-progress-rowss">Optimization progress (rows/s)</h4>
<div id="chart-opt-progress" style="width:600px;height:360px;">

</div>
</div>
<h2 id="comparing-to-other-implementations-and-databases">Comparing to other implementations and databases</h2>
<p>As an extra bonus, I also compared my results to other databases and to other Haskell database bindings. Furthermore, I wanted to know how well Python fares with its built-in sqlite3 module. I thus implemented a few more variants of my benchmark:</p>
<ul>
<li>mysql-simple (<a href="https://github.com/nurpax/db-bench/tree/master/haskell/Mysql.hs">source</a>)</li>
<li>postgresql-simple (<a href="https://github.com/nurpax/db-bench/tree/master/haskell/Psql.hs">source</a>)</li>
<li>HDBC-sqlite3 (<a href="https://github.com/nurpax/db-bench/tree/master/haskell/Hdbc.hs">source</a>)</li>
<li>Python sqlite3 (<a href="https://github.com/nurpax/db-bench/tree/master/python/bench.py">source</a>)</li>
</ul>
<div>
<h4 id="databaselibrary-comparison-rowss">Database/library comparison (rows/s)</h4>
<div id="chart-cross-db" style="width:600px;height:360px;">

</div>
</div>
<p>I didn’t do any performance analysis for non-sqlite benchmark results, and wouldn’t draw too many conclusions about the results. These results do seem to confirm though that the HDBC library adds a fairly significant overhead to database row access. Comparing HDBC against sqlite-simple, we get 105K vs 1.8M rows/s.</p>
<h2 id="next-steps">Next steps</h2>
<p>There are still many areas that would need further analysis:</p>
<ul>
<li>Use more columns in the result set</li>
<li>Use other column types than <code>Int</code>s</li>
<li>Per-query overhead</li>
</ul>
<p>I expect low per-query overhead to be particularly important for web applications. The typical usage in web apps would be that a single page load performs several queries with relatively low number of rows returned by each query.</p>
<p>Thanks to <a href="https://github.com/Emm">Emmanuel Surleau</a>, <a href="https://github.com/IreneKnapp">Irene Knapp</a> and <a href="https://github.com/joeyadams">Joey Adams</a> for their optimization ideas, contributions and code reviews.</p>
<p>Until next time.</p>
<script type="text/javascript">
function barchart(divname, legendPos, data)
{
    var i = 0;
    var d1 = data.map(function(elt) { return { label: elt[1], data: [[i++, elt[0]]]}; });
/*
    i = 0;
    var xaxisLabels = data.map(function(elt) { return [i++, elt[1]]; });
*/

    var options = {
         series: {
             bars: {
                 show: true,
                 lineWidth:0,
                 fill:true,
                 barWidth: 0.9,
                 fillColor: { colors: [ { opacity: 1.0 }, { opacity: 1.0 } ] },
                 align: 'center'
             },
         },
         legend: { position: legendPos, },
         xaxis: { min:-1, max:i, ticks: [] },
     };

    $.plot($(divname), d1, options);
}

$(function () {
     var data = [
         [6891798, "native sqlite (C)"],
         [3600395, "direct-sqlite"],
         [2208862, "sqlite-simple (fold_)"],
         [1808292, "sqlite-simple (query_)"],
         [2500000, "Python"],
         [944227,  "mysql-simple"],
         [466932,  "postgresql-simple"],
         [105529,  "HDBC-sqlite3"]
         ];


     var dataNativeVsHaskell = [
           [6891798, "Native C"],
           [3600395, "direct-sqlite"],
           [1808292, "sqlite-simple (optimized)"],
           [53106,   "sqlite-simple (unoptimized)"]
         ]

     var dataProgression = [
         [53106, "Original (w/o optimizations)"],
         [749883, "Tail call optimization"],
         [889363, "Cleanup, strictness, less allocs"],
         [1808292, "With full optimizations (incl. unsafe FFI)"]
         ]

     barchart("#chart-cross-db", "ne", data);
     barchart("#chart-c-vs-haskell", "ne", dataNativeVsHaskell);
     barchart("#chart-opt-progress", "nw", dataProgression);
});
</script>]]></summary>
</entry>
<entry>
    <title>AngularJS with Haskell</title>
    <link href="http://nurpax.github.com/posts/2013-01-13-angularjs-and-haskell.html" />
    <id>http://nurpax.github.com/posts/2013-01-13-angularjs-and-haskell.html</id>
    <published>2013-01-13T00:00:00Z</published>
    <updated>2013-01-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I recently wrote a simple To-Do app in <a href="http://angularjs.org/">AngularJS</a> using the Haskell web development framework called <a href="http://snapframework.com/">Snap</a>. I started with the To-Do example I found on the <a href="http://angularjs.org/">AngularJS’s homepage</a> and added the necessary JavaScript plumbing to enable talking to a Haskell web server over a REST API. I figured someone might find my little app a useful starting point for developing web applications with AngularJS and Snap, and so I decided to upload the <a href="https://github.com/nurpax/snap-examples/tree/master/angularjs-todo">code on github</a> and write this code walkthrough.</p>
<p>To get started, you can try to build &amp; run the app:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone git://github.com/nurpax/snap-examples
<span class="bu">cd</span> snap-examples/angularjs-todo
<span class="ex">cabal-dev</span> install
<span class="ex">./cabal-dev/bin/angularjs-todo</span>
<span class="co"># browse to http://localhost:8000</span></code></pre></div>
<p>You should see something like this:</p>
<div class="screenshot white-bg">
<div class="figure">
<img src="/images/angular-todo1.png" title="AngularJS ToDo app with Haskell" />

</div>
</div>
<p>I will not go into much detail about AngularJS usage here – you should read more about it on their <a href="http://angularjs.org/">homepage</a>. This post will focus on what’s needed in order to build an AngularJS app with a Haskell backend.</p>
<p>In an AngularJS app, a major part of the application is JavaScript and runs in the the browser. These applications are usually backed by a central server. In our case, the backend is written in Haskell. This server takes care of user management, authentication and persistence. The frontend talks to the backend via a REST API. The REST API communicates things like adding or listing to-do items.</p>
<h2 id="frontend-javascript-parts">Frontend JavaScript parts</h2>
<p>The main client-side source files are:</p>
<ul>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/index.html">static/index.html</a> - Application frontpage</li>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/todo.js">static/todo.js</a> - Controller for to-do items</li>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/services.js">static/services.js</a> - Model definition</li>
</ul>
<p>The “AngularJS application” is defined <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/index.html">static/index.html</a>. It contains definitions on how to display the main page, how to list to-do items and how to hook up UI events to controller actions.</p>
<p>The application calls into a <code>TodoCtrl</code> controller defined in <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/todo.js">static/todo.js</a>. The controller mostly deals with UI events. The controller talks to the backend via a <code>Todo</code> service.</p>
<p>The <code>Todo</code> service is defined <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/services.js">static/services.js</a>. It defines the client-server interface for accessing user’s to-do items, providing methods such as <code>Todo.query()</code> and <code>Todo.save()</code>.</p>
<h2 id="the-haskell-backend">The Haskell backend</h2>
<p>The most interesting server parts can be found in the following source files:</p>
<ul>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Site.hs">src/Site.hs</a> - Main server module (login, authentication, REST)</li>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Db.hs">src/Db.hs</a> - Model definition (types, JSON serialization, database persistence)</li>
</ul>
<p>The model definition of our to-do app is quite simple. The main type is the <code>Todo</code> item:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Todo</span> <span class="fu">=</span>
  <span class="dt">Todo</span>
  {<span class="ot"> todoId   ::</span> <span class="dt">Maybe</span> <span class="dt">Int64</span>  <span class="co">-- database row id</span>
  ,<span class="ot"> todoText ::</span> <span class="dt">T.Text</span>       <span class="co">-- todo text</span>
  ,<span class="ot"> todoDone ::</span> <span class="dt">Bool</span>         <span class="co">-- completed?</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>The <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Db.hs">Db</a> module defines how these objects can be serialized to/from JSON using the <a href="http://hackage.haskell.org/package/aeson">aeson package</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Todo</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Object</span> v) <span class="fu">=</span>
    <span class="dt">Todo</span> <span class="fu">&lt;$&gt;</span> optional (v <span class="fu">.:</span> <span class="st">&quot;id&quot;</span>)
         <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;text&quot;</span>
         <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;done&quot;</span>
  parseJSON _ <span class="fu">=</span> mzero

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Todo</span> <span class="kw">where</span>
  toJSON (<span class="dt">Todo</span> i text done) <span class="fu">=</span>
    object [ <span class="st">&quot;id&quot;</span> <span class="fu">.=</span> fromJust i
           , <span class="st">&quot;text&quot;</span> <span class="fu">.=</span> text
           , <span class="st">&quot;done&quot;</span> <span class="fu">.=</span> done
           ]</code></pre></div>
<p>The rest of the module is about persisting <code>Todo</code>s in an SQLite database.</p>
<p>The final piece of the puzzle is the <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Site.hs">Site</a> module which plugs all of the above server bits together. It manages routing, authentication and serves to-do items over a REST API. The server-side routing is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Render main page</span>
<span class="ot">mainPage ::</span> <span class="dt">H</span> ()
mainPage <span class="fu">=</span> withLoggedInUser (const <span class="fu">$</span> serveDirectory <span class="st">&quot;static&quot;</span>)

<span class="co">-- | The application&#39;s routes.</span>
<span class="ot">routes ::</span> [(<span class="dt">ByteString</span>, <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ())]
routes <span class="fu">=</span> [ (<span class="st">&quot;/login&quot;</span>,        with auth handleLoginSubmit)
         , (<span class="st">&quot;/logout&quot;</span>,       with auth handleLogout)
         , (<span class="st">&quot;/new_user&quot;</span>,     with auth handleNewUser)
         , (<span class="st">&quot;/api/todo&quot;</span>,     with auth handleTodos)
         , (<span class="st">&quot;/&quot;</span>,             with auth mainPage)
         , (<span class="st">&quot;/static&quot;</span>,       serveDirectory <span class="st">&quot;static&quot;</span>)
         ]</code></pre></div>
<p>There’s a couple of things to note about the above routing table:</p>
<ul>
<li>The REST interface is at <code>/api/todo</code> and gets handled by <code>handleTodos</code></li>
<li>Serving the main page is just a matter of serving static files. This is because all the important templating happens on client-side in <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/index.html">static/index.html</a>.</li>
</ul>
<p>The actual implementation of the <code>/api/todo</code> handler is straightforward (esp. with the hidden gem that is <a href="http://hackage.haskell.org/package/snap-extras">snap-extras</a>):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleTodos ::</span> <span class="dt">H</span> ()
handleTodos <span class="fu">=</span>
  method <span class="dt">GET</span>  (withLoggedInUser getTodos) <span class="fu">&lt;|&gt;</span>
  method <span class="dt">POST</span> (withLoggedInUser saveTodo)
  <span class="kw">where</span>
    getTodos user <span class="fu">=</span> <span class="kw">do</span>
      todos <span class="ot">&lt;-</span> withDb <span class="fu">$</span> \conn <span class="ot">-&gt;</span> Db.listTodos conn user
      writeJSON todos

    saveTodo user <span class="fu">=</span> <span class="kw">do</span>
      newTodo <span class="ot">&lt;-</span> getJSON
      either (const <span class="fu">$</span> return ()) persist newTodo
        <span class="kw">where</span>
          persist todo <span class="fu">=</span> <span class="kw">do</span>
            savedTodo <span class="ot">&lt;-</span> withDb <span class="fu">$</span> \conn <span class="ot">-&gt;</span> Db.saveTodo conn user todo
            writeJSON savedTodo</code></pre></div>
<p>Function <code>handleTodos</code> handles either <code>GET</code> or <code>POST</code> requests, for retrieving and modifying todo items. All its request parameters come in as JSON – these are turned into Haskell objects using <code>getJSON</code> from <a href="http://hackage.haskell.org/packages/archive/snap-extras/0.3/doc/html/Snap-Extras-JSON.html">Snap.Extras.JSON</a>. Similarly, we use <code>writeJSON</code> for outputting the request response. Automatic JSON encode and decode is made possible by the <code>FromJSON</code> and <code>ToJSON</code> instances defined in the <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Db.hs">Db</a> module.</p>
<h2 id="debugging-json-responses">Debugging JSON responses</h2>
<p>A good way to debug your REST APIs is to use Chrome’s Developer Tools. Open the Developer console and click on the Network tab. When you load a page, you can see what requests are being made and you can inspect what JSON gets sent by clicking on the individual <code>/api/todo</code> requests. Here’s an example of what traffic gets generated when complete a to-do:</p>
<div class="screenshot white-bg">
<div class="figure">
<img src="/images/angular-todo2-check.png" title="Chrome dev tool view" />

</div>
</div>
<p>This is the result of a <code>todo.$save()</code> AJAX call.</p>
<h2 id="what-next">What next?</h2>
<p>Well.. The easy part is over. If you want to learn more about using AngularJS with Snap, I suggest that you:</p>
<ul>
<li>Read the <a href="http://angularjs.org/">AngularJS docs</a></li>
<li>Read the <a href="http://snapframework.com/">Snap Framework docs</a></li>
<li>Read the <a href="https://github.com/nurpax/snap-examples/tree/master/angularjs-todo">example source</a></li>
<li>Compile, run and play with the example</li>
</ul>
<p>HTH.</p>]]></summary>
</entry>
<entry>
    <title>Note to self</title>
    <link href="http://nurpax.github.com/posts/2013-01-04-note-to-self.html" />
    <id>http://nurpax.github.com/posts/2013-01-04-note-to-self.html</id>
    <published>2013-01-04T00:00:00Z</published>
    <updated>2013-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Note to self: Don’t use SQLite3 from multiple Haskell threads – at least not with <a href="http://hackage.haskell.org/package/sqlite-simple">sqlite-simple</a>.</p>
<p>I recently implemented a To-Do app (the “Hello World” of web apps) using <a href="http://angularjs.org/">AngularJS</a> on the frontend and <a href="http://snapframework.com/">Snap</a> on the backend. If you haven’t heard about AngularJS, I highly recommend you to check it out – it’s got a very clean approach to developing modern single-page web apps.</p>
<p>In my app, the Snap-based server was used mainly for authentication and persistence. The rest of the app runs client-side in JavaScript and talks to the server over a simple REST API. Getting all this up and running was surprisingly easy.</p>
<p>Anyhow.. Turns out it’s easy to write an AngularJS app that sends a lot of concurrent requests to the server, even in the single user case. As an example, you can iterate through a list of todo-items in JavaScript, persisting each item with a call to <code>item.$save()</code>:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="va">$scope</span>.<span class="at">archive</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
        <span class="kw">var</span> oldTodos <span class="op">=</span> <span class="va">$scope</span>.<span class="at">todos</span><span class="op">;</span>
        <span class="va">$scope</span>.<span class="at">todos</span> <span class="op">=</span> []<span class="op">;</span>
        <span class="va">angular</span>.<span class="at">forEach</span>(oldTodos<span class="op">,</span> <span class="kw">function</span>(todo) <span class="op">{</span>
            <span class="cf">if</span> (<span class="op">!</span><span class="va">todo</span>.<span class="at">done</span>)
                <span class="va">$scope</span>.<span class="va">todos</span>.<span class="at">push</span>(todo)<span class="op">;</span>

            <span class="va">todo</span>.<span class="at">$save</span>()<span class="op">;</span>
        <span class="op">}</span>)<span class="op">;</span>
    <span class="op">};</span></code></pre></div>
<p>Each <code>$save()</code> triggers an AJAX call and the server will see these as multiple concurrent requests.</p>
<p>Unfortunately though, I started seeing lot of SQLITE_BUSY errors on the server side with this usage. Turns out accessing a single SQLite3 database from multiple threads, each with its own connection is not as simple as I thought. If you’re in the middle of reading rows from a SELECT and you issue an INSERT from another connection, the INSERT will fail with an SQLITE_BUSY error. Here’s Haskell code that reproduces this problem:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Direct</span> (
  directSqliteTest
  ) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Database.SQLite3.Direct</span>

<span class="ot">directSqliteTest ::</span> <span class="dt">IO</span> ()
directSqliteTest <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">Right</span> conn1 <span class="ot">&lt;-</span> open <span class="st">&quot;test.db&quot;</span>
  <span class="dt">Right</span> conn2 <span class="ot">&lt;-</span> open <span class="st">&quot;test.db&quot;</span>

  exec conn1 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>
  exec conn1 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>

  <span class="dt">Right</span> (<span class="dt">Just</span> sr) <span class="ot">&lt;-</span> prepare conn1 <span class="st">&quot;SELECT * from a&quot;</span>
  a <span class="ot">&lt;-</span> step sr
  a <span class="ot">&lt;-</span> step sr
  print a
  x <span class="ot">&lt;-</span> exec conn2 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>
  <span class="co">-- ^^ SQLITE_BUSY is triggered</span>
  finalize sr
  print x

  void <span class="fu">$</span> close conn1
  void <span class="fu">$</span> close conn2</code></pre></div>
<p>The above code will print:</p>
<pre><code>$ ./dist/build/sqlite-test/sqlite-test
Right Row
Right Row
Left (ErrorBusy,Utf8 &quot;database is locked&quot;)</code></pre>
<p>As <a href="http://hackage.haskell.org/package/snaplet-sqlite-simple">snaplet-sqlite-simple</a> does connection pooling, the above pattern is very likely to happen. The SQLite snaplet maintains a connection pool which is used to service connections to request handlers. Concurrent requests will each be handed their own connection instead of using a single shared connection. A request can be in the middle of reading database rows from the while another request tries to write to the database using another connection, and <em>boom</em>, the above SQLITE_BUSY scenario triggers.</p>
<p>As a quick band-aid fix, I changed snaplet-sqlite-simple to not use a connection pool but instead allocate a single database handle on init and servicing the same handle sequentially to anyone that asks (<a href="https://github.com/nurpax/snaplet-sqlite-simple/commit/3957f722cce6abf7e1059f481668379e05b62286">commit 3957f722</a>). For extra safety, I also stuck the connection inside an <code>MVar</code> so that all SQLite operations get serialized within the Snap application.</p>
<p>Hopefully I’ll be able to switch to a more concurrent model in the future, but at least the current v0.4.0 release works without SQLITE_BUSY errors.</p>]]></summary>
</entry>
<entry>
    <title>Reading TCX in Haskell</title>
    <link href="http://nurpax.github.com/posts/2012-12-27-playing-with-hxt.html" />
    <id>http://nurpax.github.com/posts/2012-12-27-playing-with-hxt.html</id>
    <published>2012-12-27T00:00:00Z</published>
    <updated>2012-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I use a Garmin GPS/heart-rate monitor watch to track my running. I also upload this GPS data to a service called <a href="http://www.runkeeper.com">RunKeeper</a> to keep a history of my runs. While I’ve generally been happy with RunKeeper, my experience uploading Garmin GPS data to RunKeeper has been less than stellar. My biggest complaint is that usually the original GPS data changes significantly when uploaded to RunKeeper. For example, a 10.0 km run (according to Garmin) can become 10.2 km in RunKeeper.</p>
<p>I decided to do a bit of data mining on Garmin GPS files to figure out how RunKeeper interprets it differently. Garmin’s tools can export GPS data as both GPX and <a href="http://en.wikipedia.org/wiki/Training_Center_XML">TCX</a>. The latter format is developed by Garmin and quite likely the closest match to the their native format. Both GPX and TCX are XML.</p>
<p>I didn’t get very far with actual GPS track analysis but I did write a TCX file reader in Haskell using the <a href="http://hackage.haskell.org/package/hxt">Haskell XML Toolbox (hxt)</a> library. As there seems to be a bit of a lack of Haskell XML parsing examples on the Internet, I decided to post my TCX reader here as an example of parsing Real World XML data in Haskell.</p>
<p>Here’s a short sample of what a TCX file looks like (some elements have been omitted and xmlns URLs truncated for brevity):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class="kw">?&gt;</span>
<span class="co">&lt;!-- Some elements omitted for brevity --&gt;</span>
<span class="kw">&lt;TrainingCenterDatabase</span>
<span class="ot">  xsi:schemaLocation=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/...d&quot;</span>
<span class="ot">  xmlns:ns5=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/ActivityGoals/v1&quot;</span>
<span class="ot">  xmlns:ns3=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/ActivityExtension/v2&quot;</span>
<span class="ot">  xmlns:ns2=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/UserProfile/v2&quot;</span>
<span class="ot">  xmlns=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2&quot;</span>
<span class="ot">  xmlns:xsi=</span><span class="st">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><span class="ot"> xmlns:ns4=</span><span class="st">&quot;...&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;Activities&gt;</span>
    <span class="kw">&lt;Activity</span><span class="ot"> Sport=</span><span class="st">&quot;Biking&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;Id&gt;</span>2012-12-22T13:47:50.000Z<span class="kw">&lt;/Id&gt;</span>
      <span class="kw">&lt;Lap</span><span class="ot"> StartTime=</span><span class="st">&quot;2012-12-22T13:47:50.000Z&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;DistanceMeters&gt;</span>1000.0<span class="kw">&lt;/DistanceMeters&gt;</span>
        <span class="kw">&lt;Track&gt;</span>
          <span class="kw">&lt;Trackpoint&gt;</span>
            <span class="kw">&lt;Time&gt;</span>2012-12-22T13:47:49.000Z<span class="kw">&lt;/Time&gt;</span>
            <span class="kw">&lt;AltitudeMeters&gt;</span>-2.799999952316284<span class="kw">&lt;/AltitudeMeters&gt;</span>
            <span class="kw">&lt;DistanceMeters&gt;</span>0.0<span class="kw">&lt;/DistanceMeters&gt;</span>
            <span class="kw">&lt;HeartRateBpm&gt;</span>
              <span class="kw">&lt;Value&gt;</span>134<span class="kw">&lt;/Value&gt;</span>
            <span class="kw">&lt;/HeartRateBpm&gt;</span></code></pre></div>
<p>The Haskell code for TCX file reading can be found below (also up on <a href="https://github.com/nurpax/hs-tcx">github</a> with a .cabal file). Here’s an outline of what it does:</p>
<ul>
<li>The input XML document is read from a file called <code>test-act.tcx</code></li>
<li>The XML document is massaged into Haskell objects using HXT combinators</li>
<li>The resulting Haskell objects (<code>Activity</code>, <code>Lap</code> and <code>Trackpoint</code>) are traversed and output to stdout</li>
</ul>
<p>Note: As is probably obvious, this code is not meant to be comprehensive library for accessing TCX data – it’s really just an example of how to get started with HXT and TCX.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Arrows, NoMonomorphismRestriction #-}</span>

<span class="kw">import </span><span class="dt">Text.XML.HXT.Core</span>
<span class="kw">import </span><span class="dt">Data.Time</span> (<span class="dt">UTCTime</span>, readTime)
<span class="kw">import </span><span class="dt">System.Locale</span> (defaultTimeLocale)

<span class="kw">data</span> <span class="dt">Activity</span> <span class="fu">=</span> <span class="dt">Activity</span> [<span class="dt">Lap</span>]
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Lap</span> <span class="fu">=</span> <span class="dt">Lap</span> {
<span class="ot">    lapDistance ::</span> <span class="dt">Float</span>
  ,<span class="ot"> lapTrackpoints ::</span> [<span class="dt">Trackpoint</span>]
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Trackpoint</span> <span class="fu">=</span> <span class="dt">Trackpoint</span> {
<span class="ot">    tpTime ::</span> <span class="dt">UTCTime</span>
  ,<span class="ot"> tpBpm ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">atTag ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">XmlTree</span>
atTag tag <span class="fu">=</span> deep (isElem <span class="fu">&gt;&gt;&gt;</span> hasName tag)

<span class="ot">text ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">String</span>
text <span class="fu">=</span> getChildren <span class="fu">&gt;&gt;&gt;</span> getText

<span class="co">-- Note: the hardcoded .000 part is kludge but for my inputs this was</span>
<span class="co">-- an easy way to get timestamps to parse.</span>
<span class="ot">readt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>
readt <span class="fu">=</span> readTime defaultTimeLocale <span class="st">&quot;%FT%T.000%Z&quot;</span>

<span class="ot">getTrackpoint ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Trackpoint</span>
getTrackpoint <span class="fu">=</span> atTag <span class="st">&quot;Trackpoint&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    time <span class="ot">&lt;-</span> text <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Time&quot;</span> <span class="fu">-&lt;</span> x
    bpm <span class="ot">&lt;-</span> text <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Value&quot;</span> <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;HeartRateBpm&quot;</span> <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Trackpoint</span> (readt time) bpm

<span class="ot">getLap ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Lap</span>
getLap <span class="fu">=</span> getChildren <span class="fu">&gt;&gt;&gt;</span> isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;Lap&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    pts <span class="ot">&lt;-</span> listA getTrackpoint <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Track&quot;</span> <span class="fu">-&lt;</span> x
    dist <span class="ot">&lt;-</span> getChildren <span class="fu">&gt;&gt;&gt;</span> isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;DistanceMeters&quot;</span> <span class="fu">&gt;&gt;&gt;</span> text <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Lap</span> (read dist) pts

<span class="ot">getActivity ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Activity</span>
getActivity <span class="fu">=</span> atTag <span class="st">&quot;Activity&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    laps <span class="ot">&lt;-</span> listA getLap <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Activity</span> laps

<span class="ot">getActivities ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> [<span class="dt">Activity</span>]
getActivities <span class="fu">=</span> deep (isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;TrainingCenterDatabase&quot;</span> <span class="fu">/&gt;</span> hasName <span class="st">&quot;Activities&quot;</span>) <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    activities <span class="ot">&lt;-</span> listA getActivity <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> activities

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  activities <span class="ot">&lt;-</span> runX (readDocument [withValidate no] <span class="st">&quot;test-act.tcx&quot;</span> <span class="fu">&gt;&gt;&gt;</span> getActivities)
  mapM_ printActivity (head activities)
  <span class="kw">where</span>
    printActivity (<span class="dt">Activity</span> laps) <span class="fu">=</span> <span class="kw">do</span>
      putStrLn <span class="st">&quot;Activity:&quot;</span>
      mapM_ printLaps laps

    printLaps (<span class="dt">Lap</span> distance trackpts) <span class="fu">=</span> <span class="kw">do</span>
      putStrLn <span class="st">&quot;  Lap:&quot;</span>
      putStrLn (<span class="st">&quot;    Distance: &quot;</span> <span class="fu">++</span> show distance)
      mapM_ printTrackpoint trackpts

    printTrackpoint (<span class="dt">Trackpoint</span> time bpm) <span class="fu">=</span>
      putStrLn (<span class="st">&quot;    time: &quot;</span> <span class="fu">++</span> show time <span class="fu">++</span> <span class="st">&quot; bpm: &quot;</span> <span class="fu">++</span> show bpm)</code></pre></div>]]></summary>
</entry>
<entry>
    <title>Snap with SQLite</title>
    <link href="http://nurpax.github.com/posts/2012-12-20-snaplet-sqlite-simple-example.html" />
    <id>http://nurpax.github.com/posts/2012-12-20-snaplet-sqlite-simple-example.html</id>
    <published>2012-12-20T00:00:00Z</published>
    <updated>2012-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently released <a href="http://hackage.haskell.org/package/snaplet-sqlite-simple">snaplet-sqlite-simple 0.3</a>, a compatibility update for the recently released <a href="http://hackage.haskell.org/package/snap">Snap 0.10</a>. This library is glue for hooking up a Snap application to an <a href="http://www.sqlite.org/">SQLite</a> database using the <a href="http://hackage.haskell.org/package/sqlite-simple">sqlite-simple</a> library. Using SQLite with Snap is a handy, light-weight approach for quickly prototyping database-backed web apps – you don’t need to configure a separate SQL server just to run your web app.</p>
<p>While the new snaplet-sqlite-simple 0.3 release doesn’t add any significant new functionality, I thought a few things in its <a href="https://github.com/nurpax/snaplet-sqlite-simple/tree/master/example/src">example project</a> would be worth a mention.</p>
<p>This example project implements a simple web app that has a login screen (with new user registration) and a main page where logged in users can drop comments. Users and comments are both persisted into an SQLite database.</p>
<p>Here’s a couple of screenshots to show how it looks like. Let’s start with the login screen:</p>
<div class="screenshot white-bg">
<div class="figure">
<img src="/images/snaplet-sqlite-simple-example-login.png" title="Login screen" />

</div>
</div>
<p>If you create a new user and login to the app, you’re taken to the main page. Here the logged in user can add comments. The comments get persisted into a database and are associated with the current user (e.g., other users can’t see them.) Here’s how the main page looks like:</p>
<div class="screenshot white-bg">
<div class="figure">
<img src="/images/snaplet-sqlite-simple-example-comments.png" title="Main page" />

</div>
</div>
<p>The example demonstrates a few basic concepts in a complete example:</p>
<ul>
<li>Connecting to an SQLite database</li>
<li>Creating database tables (if not created) on web app’s init</li>
<li>Associating your own user data with Snap’s <a href="http://hackage.haskell.org/packages/archive/snap/0.10.0.1/doc/html/Snap-Snaplet-Auth.html">Snap.Snaplet.Auth</a> user objects</li>
<li>Making simple database queries and rendering the results on the main screen</li>
</ul>
<p>Setting up the connection is easy, see the <code>app</code> function in <a href="https://github.com/nurpax/snaplet-sqlite-simple/blob/master/example/src/Site.hs">Site.hs</a>.</p>
<p>Creating the database schema on app startup is perhaps less obvious. This also happens on app init:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The application initializer.</span>
<span class="ot">app ::</span> <span class="dt">SnapletInit</span> <span class="dt">App</span> <span class="dt">App</span>
<span class="co">-- ...</span>
    <span class="co">-- Grab the DB connection pool from the sqlite snaplet and call</span>
    <span class="co">-- into the Model to create all the DB tables if necessary.</span>
    <span class="kw">let</span> connPool <span class="fu">=</span> sqlitePool <span class="fu">$</span> d <span class="fu">^#</span> snapletValue
    liftIO <span class="fu">$</span> withResource connPool <span class="fu">$</span> \conn <span class="ot">-&gt;</span> Db.createTables conn</code></pre></div>
<p>The actual table creation is done in <a href="https://github.com/nurpax/snaplet-sqlite-simple/blob/master/example/src/Db.hs">Db.hs</a>. This module also contains query functions for saving and listing comments for a given user.</p>
<p>Everything on the main page requires a logged in user. Requiring a logged in user is ensured using <code>withLoggedInUser</code> which either calls a handler with the currently logged in user or redirects to the login screen. It’s defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Run actions with a logged in user or go back to the login screen</span>
<span class="ot">withLoggedInUser ::</span> (<span class="dt">Db.User</span> <span class="ot">-&gt;</span> <span class="dt">H</span> ()) <span class="ot">-&gt;</span> <span class="dt">H</span> ()
withLoggedInUser action <span class="fu">=</span>
  currentUser <span class="fu">&gt;&gt;=</span> go
  <span class="kw">where</span>
    go <span class="dt">Nothing</span>  <span class="fu">=</span> handleLogin (<span class="dt">Just</span> <span class="st">&quot;Must be logged in to view the main page&quot;</span>)
    go (<span class="dt">Just</span> u) <span class="fu">=</span> maybeWhen (userId u) (action <span class="fu">.</span> user)
      <span class="kw">where</span>
        user uid <span class="fu">=</span> <span class="dt">Db.User</span> (read <span class="fu">.</span> T.unpack <span class="fu">$</span> unUid uid) (userLogin u)</code></pre></div>
<p>You can use it anywhere you need to access the currently logged in user. For example, here’s how the main page handler deals with the current user:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mainPage ::</span> <span class="dt">H</span> ()
mainPage <span class="fu">=</span> withLoggedInUser go
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Db.User</span> <span class="ot">-&gt;</span> <span class="dt">H</span> ()
    go user <span class="fu">=</span> <span class="kw">do</span>
      comments <span class="ot">&lt;-</span> withTop db <span class="fu">$</span> Db.listComments user
      heistLocal (splices comments) <span class="fu">$</span> render <span class="st">&quot;/index&quot;</span>
    splices cs <span class="fu">=</span>
      I.bindSplices [(<span class="st">&quot;comments&quot;</span>, I.mapSplices renderComment cs)]</code></pre></div>
<p>To learn more about using sqlite-simple with Snap, I recommend you clone the code from Git, build the example, play with the app and read the <a href="https://github.com/nurpax/snaplet-sqlite-simple/tree/master/example/src">example source code</a>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone git://github.com/nurpax/snaplet-sqlite-simple.git
<span class="bu">cd</span> example
<span class="ex">cabal-dev</span> install
<span class="ex">./cabal-dev/bin/example</span>
<span class="co"># browse to http://localhost:8000</span></code></pre></div>]]></summary>
</entry>

</feed>
