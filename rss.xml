<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>nurpax.github.com blog</title>
        <link>http://nurpax.github.com</link>
        <description><![CDATA[Notes on programming in Haskell]]></description>
        <atom:link href="http://nurpax.github.com/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 04 Jan 2013 00:00:00 UT</lastBuildDate>
        <item>
    <title>Note to self</title>
    <link>http://nurpax.github.com/posts/2013-01-04-note-to-self.html</link>
    <description><![CDATA[<p>Note to self: Don’t use SQLite3 from multiple Haskell threads – at least not with <a href="http://hackage.haskell.org/package/sqlite-simple">sqlite-simple</a>.</p>
<p>I recently implemented a To-Do app (the “Hello World” of web apps) using <a href="http://angularjs.org/">AngularJS</a> on the frontend and <a href="http://snapframework.com/">Snap</a> on the backend. If you haven’t heard about AngularJS I highly recommend you to check it out – it’s got a very clean approach to developing modern single-page web apps.</p>
<p>In my app, the Snap-based server was used mainly for authentication and persistence. The rest of the app runs client-side in JavaScript and talks to the server over a simple REST API. Getting all this up and running was surprisingly easy.</p>
<p>Anyhow.. Turns out it’s easy to write an AngularJS app that sends a lot of concurrent requests to the server, even in the single user case. As an example, you can iterate through a list of todo-items in JavaScript, persisting each item with a call to <code>item.$save()</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">    $<span class="kw">scope</span>.<span class="fu">archive</span> = <span class="kw">function</span>() {
        <span class="kw">var</span> oldTodos = $<span class="kw">scope</span>.<span class="fu">todos</span>;
        $<span class="kw">scope</span>.<span class="fu">todos</span> = [];
        <span class="kw">angular</span>.<span class="fu">forEach</span>(oldTodos, <span class="kw">function</span>(todo) {
            <span class="kw">if</span> (!<span class="kw">todo</span>.<span class="fu">done</span>)
                $<span class="kw">scope.todos</span>.<span class="fu">push</span>(todo);

            <span class="kw">todo</span>.$<span class="fu">save</span>();
        });
    };</code></pre>
<p>Each <code>$save()</code> triggers an AJAX call and the server will see these as multiple concurrent requests.</p>
<p>Unfortunately though, I started seeing lot of SQLITE_BUSY errors on the server side with this usage. Turns out accessing a single SQLite3 database from multiple threads, each with its own connection is not as simple as I thought. If you’re in the middle of reading rows from a SELECT and you issue an INSERT from another connection, the INSERT will fail with an SQLITE_BUSY error. Here’s Haskell code that reproduces this problem:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Direct</span> (
  directSqliteTest
  ) <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">Control.Monad</span>
<span class="kw">import</span> <span class="dt">Database.SQLite3.Direct</span>

<span class="ot">directSqliteTest ::</span> <span class="dt">IO</span> ()
directSqliteTest <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">Right</span> conn1 <span class="ot">&lt;-</span> open <span class="st">&quot;test.db&quot;</span>
  <span class="kw">Right</span> conn2 <span class="ot">&lt;-</span> open <span class="st">&quot;test.db&quot;</span>

  exec conn1 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>
  exec conn1 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>

  <span class="kw">Right</span> (<span class="kw">Just</span> sr) <span class="ot">&lt;-</span> prepare conn1 <span class="st">&quot;SELECT * from a&quot;</span>
  a <span class="ot">&lt;-</span> step sr
  a <span class="ot">&lt;-</span> step sr
  <span class="fu">print</span> a
  x <span class="ot">&lt;-</span> exec conn2 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>
  <span class="co">-- ^^ SQLITE_BUSY is triggered</span>
  finalize sr
  <span class="fu">print</span> x

  void <span class="fu">$</span> close conn1
  void <span class="fu">$</span> close conn2</code></pre>
<p>The above code will print:</p>
<pre><code>$ ./dist/build/sqlite-test/sqlite-test
Right Row
Right Row
Left (ErrorBusy,Utf8 &quot;database is locked&quot;)</code></pre>
<p>As <a href="http://hackage.haskell.org/package/snaplet-sqlite-simple">snaplet-sqlite-simple</a> does connection pooling, the above pattern is very likely to happen. The SQLite snaplet maintains a connection pool which is used to service connections to request handlers. Concurrent requests will each be handed their own connection instead of using a single shared connection. A request can be in the middle of reading rows from the database while another request tries to write to the database using another connection, and <em>boom</em>, the above SQLITE_BUSY scenario triggers.</p>
<p>As a quick band-aid fix, I changed snaplet-sqlite-simple to not use a connection pool but instead allocate a single database handle on init and servicing the same handle sequentially to anyone that asks (<a href="https://github.com/nurpax/snaplet-sqlite-simple/commit/3957f722cce6abf7e1059f481668379e05b62286">commit 3957f722</a>). For extra safety, I also stuck the connection inside an <code>MVar</code> so that all SQLite operations get serialized within the Snap application.</p>
<p>Hopefully I’ll be able to switch to a more concurrent model in the future, but at least the current v0.4.0 release works without SQLITE_BUSY errors.</p>]]></description>
    <pubDate>Fri, 04 Jan 2013 00:00:00 UT</pubDate>
    <guid>http://nurpax.github.com/posts/2013-01-04-note-to-self.html</guid>
</item>
<item>
    <title>Reading TCX in Haskell</title>
    <link>http://nurpax.github.com/posts/2012-12-27-playing-with-hxt.html</link>
    <description><![CDATA[<p>I use a Garmin GPS/heart-rate monitor watch to track my running. I also upload this GPS data to a service called <a href="http://www.runkeeper.com">RunKeeper</a> to keep a history of my runs. While I’ve generally been happy with RunKeeper, my experience uploading Garmin GPS data to RunKeeper has been less than stellar. My biggest complaint is that usually the original GPS data changes significantly when uploaded to RunKeeper. For example, a 10.0 km run (according to Garmin) can become 10.2 km in RunKeeper.</p>
<p>I decided to do a bit of data mining on Garmin GPS files to figure out how RunKeeper interprets it differently. Garmin’s tools can export GPS data as both GPX and <a href="http://en.wikipedia.org/wiki/Training_Center_XML">TCX</a>. The latter format is developed by Garmin and quite likely the closest match to the their native format. Both GPX and TCX are XML.</p>
<p>I didn’t get very far with actual GPS track analysis but I did write a TCX file reader in Haskell using the <a href="http://hackage.haskell.org/package/hxt">Haskell XML Toolbox (hxt)</a> library. As there seems to be a bit of a lack of Haskell XML parsing examples on the Internet, I decided to post my TCX reader here as an example of parsing Real World XML data in Haskell.</p>
<p>Here’s a short sample of what a TCX file looks like (some elements have been omitted and xmlns URLs truncated for brevity):</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class="kw">?&gt;</span>
<span class="co">&lt;!-- Some elements omitted for brevity --&gt;</span>
<span class="kw">&lt;TrainingCenterDatabase</span>
<span class="ot">  xsi:schemaLocation=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/...d&quot;</span>
<span class="ot">  xmlns:ns5=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/ActivityGoals/v1&quot;</span>
<span class="ot">  xmlns:ns3=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/ActivityExtension/v2&quot;</span>
<span class="ot">  xmlns:ns2=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/UserProfile/v2&quot;</span>
<span class="ot">  xmlns=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2&quot;</span>
<span class="ot">  xmlns:xsi=</span><span class="st">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><span class="ot"> xmlns:ns4=</span><span class="st">&quot;...&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;Activities&gt;</span>
    <span class="kw">&lt;Activity</span><span class="ot"> Sport=</span><span class="st">&quot;Biking&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;Id&gt;</span>2012-12-22T13:47:50.000Z<span class="kw">&lt;/Id&gt;</span>
      <span class="kw">&lt;Lap</span><span class="ot"> StartTime=</span><span class="st">&quot;2012-12-22T13:47:50.000Z&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;DistanceMeters&gt;</span>1000.0<span class="kw">&lt;/DistanceMeters&gt;</span>
        <span class="kw">&lt;Track&gt;</span>
          <span class="kw">&lt;Trackpoint&gt;</span>
            <span class="kw">&lt;Time&gt;</span>2012-12-22T13:47:49.000Z<span class="kw">&lt;/Time&gt;</span>
            <span class="kw">&lt;AltitudeMeters&gt;</span>-2.799999952316284<span class="kw">&lt;/AltitudeMeters&gt;</span>
            <span class="kw">&lt;DistanceMeters&gt;</span>0.0<span class="kw">&lt;/DistanceMeters&gt;</span>
            <span class="kw">&lt;HeartRateBpm&gt;</span>
              <span class="kw">&lt;Value&gt;</span>134<span class="kw">&lt;/Value&gt;</span>
            <span class="kw">&lt;/HeartRateBpm&gt;</span></code></pre>
<p>The Haskell code for TCX file reading can be found below (also up on <a href="https://github.com/nurpax/hs-tcx">github</a> with a .cabal file). Here’s an outline of what it does:</p>
<ul>
<li>The input XML document is read from a file called <code>test-act.tcx</code></li>
<li>The XML document is massaged into Haskell objects using HXT combinators</li>
<li>The resulting Haskell objects (<code>Activity</code>, <code>Lap</code> and <code>Trackpoint</code>) are traversed and output to stdout</li>
</ul>
<p>Note: As is probably obvious, this code is not meant to be comprehensive library for accessing TCX data – it’s really just an example of how to get started with HXT and TCX.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Arrows, NoMonomorphismRestriction #-}</span>

<span class="kw">import</span> <span class="dt">Text.XML.HXT.Core</span>
<span class="kw">import</span> <span class="dt">Data.Time</span> (<span class="dt">UTCTime</span>, readTime)
<span class="kw">import</span> <span class="dt">System.Locale</span> (defaultTimeLocale)

<span class="kw">data</span> <span class="dt">Activity</span> <span class="fu">=</span> <span class="dt">Activity</span> [<span class="dt">Lap</span>]
  <span class="kw">deriving</span> (<span class="kw">Show</span>)

<span class="kw">data</span> <span class="dt">Lap</span> <span class="fu">=</span> <span class="dt">Lap</span> {
<span class="ot">    lapDistance ::</span> <span class="dt">Float</span>
  ,<span class="ot"> lapTrackpoints ::</span> [<span class="dt">Trackpoint</span>]
  } <span class="kw">deriving</span> (<span class="kw">Show</span>)

<span class="kw">data</span> <span class="dt">Trackpoint</span> <span class="fu">=</span> <span class="dt">Trackpoint</span> {
<span class="ot">    tpTime ::</span> <span class="dt">UTCTime</span>
  ,<span class="ot"> tpBpm ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> (<span class="kw">Show</span>)

<span class="ot">atTag ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">XmlTree</span>
atTag tag <span class="fu">=</span> deep (isElem <span class="fu">&gt;&gt;&gt;</span> hasName tag)

<span class="ot">text ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">String</span>
text <span class="fu">=</span> getChildren <span class="fu">&gt;&gt;&gt;</span> getText

<span class="co">-- Note: the hardcoded .000 part is kludge but for my inputs this was</span>
<span class="co">-- an easy way to get timestamps to parse.</span>
<span class="ot">readt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>
readt <span class="fu">=</span> readTime defaultTimeLocale <span class="st">&quot;%FT%T.000%Z&quot;</span>

<span class="ot">getTrackpoint ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Trackpoint</span>
getTrackpoint <span class="fu">=</span> atTag <span class="st">&quot;Trackpoint&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    time <span class="ot">&lt;-</span> text <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Time&quot;</span> <span class="fu">-&lt;</span> x
    bpm <span class="ot">&lt;-</span> text <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Value&quot;</span> <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;HeartRateBpm&quot;</span> <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Trackpoint</span> (readt time) bpm

<span class="ot">getLap ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Lap</span>
getLap <span class="fu">=</span> getChildren <span class="fu">&gt;&gt;&gt;</span> isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;Lap&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    pts <span class="ot">&lt;-</span> listA getTrackpoint <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Track&quot;</span> <span class="fu">-&lt;</span> x
    dist <span class="ot">&lt;-</span> getChildren <span class="fu">&gt;&gt;&gt;</span> isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;DistanceMeters&quot;</span> <span class="fu">&gt;&gt;&gt;</span> text <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Lap</span> (<span class="fu">read</span> dist) pts

<span class="ot">getActivity ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Activity</span>
getActivity <span class="fu">=</span> atTag <span class="st">&quot;Activity&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    laps <span class="ot">&lt;-</span> listA getLap <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Activity</span> laps

<span class="ot">getActivities ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> [<span class="dt">Activity</span>]
getActivities <span class="fu">=</span> deep (isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;TrainingCenterDatabase&quot;</span> <span class="fu">/&gt;</span> hasName <span class="st">&quot;Activities&quot;</span>) <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    activities <span class="ot">&lt;-</span> listA getActivity <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> activities

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  activities <span class="ot">&lt;-</span> runX (readDocument [withValidate no] <span class="st">&quot;test-act.tcx&quot;</span> <span class="fu">&gt;&gt;&gt;</span> getActivities)
  <span class="fu">mapM_</span> printActivity (<span class="fu">head</span> activities)
  <span class="kw">where</span>
    printActivity (<span class="dt">Activity</span> laps) <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">putStrLn</span> <span class="st">&quot;Activity:&quot;</span>
      <span class="fu">mapM_</span> printLaps laps

    printLaps (<span class="dt">Lap</span> distance trackpts) <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">putStrLn</span> <span class="st">&quot;  Lap:&quot;</span>
      <span class="fu">putStrLn</span> (<span class="st">&quot;    Distance: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> distance)
      <span class="fu">mapM_</span> printTrackpoint trackpts

    printTrackpoint (<span class="dt">Trackpoint</span> time bpm) <span class="fu">=</span>
      <span class="fu">putStrLn</span> (<span class="st">&quot;    time: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> time <span class="fu">++</span> <span class="st">&quot; bpm: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> bpm)</code></pre>]]></description>
    <pubDate>Thu, 27 Dec 2012 00:00:00 UT</pubDate>
    <guid>http://nurpax.github.com/posts/2012-12-27-playing-with-hxt.html</guid>
</item>
<item>
    <title>Snap with SQLite</title>
    <link>http://nurpax.github.com/posts/2012-12-20-snaplet-sqlite-simple-example.html</link>
    <description><![CDATA[<p>I recently released <a href="http://hackage.haskell.org/package/snaplet-sqlite-simple">snaplet-sqlite-simple 0.3</a>, a compatibility update for the recently released <a href="http://hackage.haskell.org/package/snap">Snap 0.10</a>. This library is glue for hooking up a Snap application to an <a href="http://www.sqlite.org/">SQLite</a> database using the <a href="http://hackage.haskell.org/package/sqlite-simple">sqlite-simple</a> library. Using SQLite with Snap is a handy, light-weight approach for quickly prototyping database-backed web apps – you don’t need to configure a separate SQL server just to run your web app.</p>
<p>While the new snaplet-sqlite-simple 0.3 release doesn’t add any significant new functionality, I thought a few things in its <a href="https://github.com/nurpax/snaplet-sqlite-simple/tree/master/example/src">example project</a> would be worth a mention.</p>
<p>This example project implements a simple web app that has a login screen (with new user registration) and a main page where logged in users can drop comments. Users and comments are both persisted into an SQLite database.</p>
<p>Here’s a couple of screenshots to show how it looks like. Let’s start with the login screen:</p>
<div class="screenshot white-bg">
<img src="/images/snaplet-sqlite-simple-example-login.png" title="Login screen" />
</div>

<p>If you create a new user and login to the app, you’re taken to the main page. Here the logged in user can add comments. The comments get persisted into a database and are associated with the current user (e.g., other users can’t see them.) Here’s how the main page looks like:</p>
<div class="screenshot white-bg">
<img src="/images/snaplet-sqlite-simple-example-comments.png" title="Main page" />
</div>

<p>The example demonstrates a few basic concepts in a complete example:</p>
<ul>
<li>Connecting to an SQLite database</li>
<li>Creating database tables (if not created) on web app’s init</li>
<li>Associating your own user data with Snap’s <a href="http://hackage.haskell.org/packages/archive/snap/0.10.0.1/doc/html/Snap-Snaplet-Auth.html">Snap.Snaplet.Auth</a> user objects</li>
<li>Making simple database queries and rendering the results on the main screen</li>
</ul>
<p>Setting up the connection is easy, see the <code>app</code> function in <a href="https://github.com/nurpax/snaplet-sqlite-simple/blob/master/example/src/Site.hs">Site.hs</a>.</p>
<p>Creating the database schema on app startup is perhaps less obvious. This also happens on app init:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The application initializer.</span>
<span class="ot">app ::</span> <span class="dt">SnapletInit</span> <span class="dt">App</span> <span class="dt">App</span>
<span class="co">-- ...</span>
    <span class="co">-- Grab the DB connection pool from the sqlite snaplet and call</span>
    <span class="co">-- into the Model to create all the DB tables if necessary.</span>
    <span class="kw">let</span> connPool <span class="fu">=</span> sqlitePool <span class="fu">$</span> d <span class="fu">^#</span> snapletValue
    liftIO <span class="fu">$</span> withResource connPool <span class="fu">$</span> \conn <span class="ot">-&gt;</span> Db.createTables conn</code></pre>
<p>The actual table creation is done in <a href="https://github.com/nurpax/snaplet-sqlite-simple/blob/master/example/src/Db.hs">Db.hs</a>. This module also contains query functions for saving and listing comments for a given user.</p>
<p>Everything on the main page requires a logged in user. Requiring a logged in user is ensured using <code>withLoggedInUser</code> which either calls a handler with the currently logged in user or redirects to the login screen. It’s defined as:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Run actions with a logged in user or go back to the login screen</span>
<span class="ot">withLoggedInUser ::</span> (<span class="dt">Db.User</span> <span class="ot">-&gt;</span> <span class="dt">H</span> ()) <span class="ot">-&gt;</span> <span class="dt">H</span> ()
withLoggedInUser action <span class="fu">=</span>
  currentUser <span class="fu">&gt;&gt;=</span> go
  <span class="kw">where</span>
    go <span class="kw">Nothing</span>  <span class="fu">=</span> handleLogin (<span class="kw">Just</span> <span class="st">&quot;Must be logged in to view the main page&quot;</span>)
    go (<span class="kw">Just</span> u) <span class="fu">=</span> maybeWhen (userId u) (action <span class="fu">.</span> user)
      <span class="kw">where</span>
        user uid <span class="fu">=</span> <span class="dt">Db.User</span> (<span class="fu">read</span> <span class="fu">.</span> T.unpack <span class="fu">$</span> unUid uid) (userLogin u)</code></pre>
<p>You can use it anywhere you need to access the currently logged in user. For example, here’s how the main page handler deals with the current user:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mainPage ::</span> <span class="dt">H</span> ()
mainPage <span class="fu">=</span> withLoggedInUser go
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Db.User</span> <span class="ot">-&gt;</span> <span class="dt">H</span> ()
    go user <span class="fu">=</span> <span class="kw">do</span>
      comments <span class="ot">&lt;-</span> withTop db <span class="fu">$</span> Db.listComments user
      heistLocal (splices comments) <span class="fu">$</span> render <span class="st">&quot;/index&quot;</span>
    splices cs <span class="fu">=</span>
      I.bindSplices [(<span class="st">&quot;comments&quot;</span>, I.mapSplices renderComment cs)]</code></pre>
<p>To learn more about using sqlite-simple with Snap, I recommend you clone the code from Git, build the example, play with the app and read the <a href="https://github.com/nurpax/snaplet-sqlite-simple/tree/master/example/src">example source code</a>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">git clone git://github.com/nurpax/snaplet-sqlite-simple.git
<span class="kw">cd</span> example
cabal-dev <span class="kw">install</span>
./cabal-dev/bin/example
<span class="co"># browse to http://localhost:8000</span></code></pre>]]></description>
    <pubDate>Thu, 20 Dec 2012 00:00:00 UT</pubDate>
    <guid>http://nurpax.github.com/posts/2012-12-20-snaplet-sqlite-simple-example.html</guid>
</item>

    </channel> 
</rss>
