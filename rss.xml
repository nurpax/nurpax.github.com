<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>nurpax.github.com blog</title>
    <link href="http://nurpax.github.com/rss.xml" rel="self" />
    <link href="http://nurpax.github.com" />
    <id>http://nurpax.github.com/rss.xml</id>
    <author>
        <name>Janne Hellsten</name>
        <email>jjhellst@gmail.com</email>
    </author>
    <updated>2013-01-13T00:00:00Z</updated>
    <entry>
    <title>AngularJS with Haskell</title>
    <link href="http://nurpax.github.com/posts/2013-01-13-angularjs-and-haskell.html" />
    <id>http://nurpax.github.com/posts/2013-01-13-angularjs-and-haskell.html</id>
    <published>2013-01-13T00:00:00Z</published>
    <updated>2013-01-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I recently wrote a simple To-Do app in <a href="http://angularjs.org/">AngularJS</a> using the Haskell web development framework called <a href="http://snapframework.com/">Snap</a>. I started with the To-Do example I found on the <a href="http://angularjs.org/">AngularJS’s homepage</a> and added the necessary JavaScript plumbing to enable talking to a Haskell web server over a REST API. I figured someone might find my little app a useful starting point for developing web applications with AngularJS and Snap, and so I decided to upload the <a href="https://github.com/nurpax/snap-examples/tree/master/angularjs-todo">code on github</a> and write this code walkthrough.</p>
<p>To get started, you can try to build &amp; run the app:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone git://github.com/nurpax/snap-examples
<span class="kw">cd</span> snap-examples/angularjs-todo
<span class="kw">cabal-dev</span> install
<span class="kw">./cabal-dev/bin/angularjs-todo</span>
<span class="co"># browse to http://localhost:8000</span></code></pre>
<p>You should see something like this:</p>
<div class="screenshot white-bg">
<img src="/images/angular-todo1.png" title="AngularJS ToDo app with Haskell" />
</div>

<p>I will not go into much detail about AngularJS usage here – you should read more about it on their <a href="http://angularjs.org/">homepage</a>. This post will focus on what’s needed in order to build an AngularJS app with a Haskell backend.</p>
<p>In an AngularJS app, a major part of the application is JavaScript and runs in the the browser. These applications are usually backed by a central server. In our case, the backend is written in Haskell. This server takes care of user management, authentication and persistence. The frontend talks to the backend via a REST API. The REST API communicates things like adding or listing to-do items.</p>
<h2 id="frontend-javascript-parts">Frontend JavaScript parts</h2>
<p>The main client-side source files are:</p>
<ul>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/index.html">static/index.html</a> - Application frontpage</li>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/todo.js">static/todo.js</a> - Controller for to-do items</li>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/services.js">static/services.js</a> - Model definition</li>
</ul>
<p>The “AngularJS application” is defined <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/index.html">static/index.html</a>. It contains definitions on how to display the main page, how to list to-do items and how to hook up UI events to controller actions.</p>
<p>The application calls into a <code>TodoCtrl</code> controller defined in <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/todo.js">static/todo.js</a>. The controller mostly deals with UI events. The controller talks to the backend via a <code>Todo</code> service.</p>
<p>The <code>Todo</code> service is defined <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/services.js">static/services.js</a>. It defines the client-server interface for accessing user’s to-do items, providing methods such as <code>Todo.query()</code> and <code>Todo.save()</code>.</p>
<h2 id="the-haskell-backend">The Haskell backend</h2>
<p>The most interesting server parts can be found in the following source files:</p>
<ul>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Site.hs">src/Site.hs</a> - Main server module (login, authentication, REST)</li>
<li><a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Db.hs">src/Db.hs</a> - Model definition (types, JSON serialization, database persistence)</li>
</ul>
<p>The model definition of our to-do app is quite simple. The main type is the <code>Todo</code> item:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Todo</span> <span class="fu">=</span>
  <span class="dt">Todo</span>
  {<span class="ot"> todoId   ::</span> <span class="dt">Maybe</span> <span class="dt">Int64</span>  <span class="co">-- database row id</span>
  ,<span class="ot"> todoText ::</span> <span class="dt">T.Text</span>       <span class="co">-- todo text</span>
  ,<span class="ot"> todoDone ::</span> <span class="dt">Bool</span>         <span class="co">-- completed?</span>
  } <span class="kw">deriving</span> (<span class="kw">Show</span>)</code></pre>
<p>The <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Db.hs">Db</a> module defines how these objects can be serialized to/from JSON using the <a href="http://hackage.haskell.org/package/aeson">aeson package</a>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Todo</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Object</span> v) <span class="fu">=</span>
    <span class="dt">Todo</span> <span class="fu">&lt;$&gt;</span> optional (v <span class="fu">.:</span> <span class="st">&quot;id&quot;</span>)
         <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;text&quot;</span>
         <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;done&quot;</span>
  parseJSON _ <span class="fu">=</span> mzero

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Todo</span> <span class="kw">where</span>
  toJSON (<span class="dt">Todo</span> i text done) <span class="fu">=</span>
    object [ <span class="st">&quot;id&quot;</span> <span class="fu">.=</span> fromJust i
           , <span class="st">&quot;text&quot;</span> <span class="fu">.=</span> text
           , <span class="st">&quot;done&quot;</span> <span class="fu">.=</span> done
           ]</code></pre>
<p>The rest of the module is about persisting <code>Todo</code>s in an SQLite database.</p>
<p>The final piece of the puzzle is the <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Site.hs">Site</a> module which plugs all of the above server bits together. It manages routing, authentication and serves to-do items over a REST API. The server-side routing is defined as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Render main page</span>
<span class="ot">mainPage ::</span> <span class="dt">H</span> ()
mainPage <span class="fu">=</span> withLoggedInUser (<span class="fu">const</span> <span class="fu">$</span> serveDirectory <span class="st">&quot;static&quot;</span>)

<span class="co">-- | The application&#39;s routes.</span>
<span class="ot">routes ::</span> [(<span class="dt">ByteString</span>, <span class="dt">Handler</span> <span class="dt">App</span> <span class="dt">App</span> ())]
routes <span class="fu">=</span> [ (<span class="st">&quot;/login&quot;</span>,        with auth handleLoginSubmit)
         , (<span class="st">&quot;/logout&quot;</span>,       with auth handleLogout)
         , (<span class="st">&quot;/new_user&quot;</span>,     with auth handleNewUser)
         , (<span class="st">&quot;/api/todo&quot;</span>,     with auth handleTodos)
         , (<span class="st">&quot;/&quot;</span>,             with auth mainPage)
         , (<span class="st">&quot;/static&quot;</span>,       serveDirectory <span class="st">&quot;static&quot;</span>)
         ]</code></pre>
<p>There’s a couple of things to note about the above routing table:</p>
<ul>
<li>The REST interface is at <code>/api/todo</code> and gets handled by <code>handleTodos</code></li>
<li>Serving the main page is just a matter of serving static files. This is because all the important templating happens on client-side in <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/static/index.html">static/index.html</a>.</li>
</ul>
<p>The actual implementation of the <code>/api/todo</code> handler is straightforward (esp. with the hidden gem that is <a href="http://hackage.haskell.org/package/snap-extras">snap-extras</a>):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">handleTodos ::</span> <span class="dt">H</span> ()
handleTodos <span class="fu">=</span>
  method <span class="dt">GET</span>  (withLoggedInUser getTodos) <span class="fu">&lt;|&gt;</span>
  method <span class="dt">POST</span> (withLoggedInUser saveTodo)
  <span class="kw">where</span>
    getTodos user <span class="fu">=</span> <span class="kw">do</span>
      todos <span class="ot">&lt;-</span> withDb <span class="fu">$</span> \conn <span class="ot">-&gt;</span> Db.listTodos conn user
      writeJSON todos

    saveTodo user <span class="fu">=</span> <span class="kw">do</span>
      newTodo <span class="ot">&lt;-</span> getJSON
      <span class="fu">either</span> (<span class="fu">const</span> <span class="fu">$</span> <span class="fu">return</span> ()) persist newTodo
        <span class="kw">where</span>
          persist todo <span class="fu">=</span> <span class="kw">do</span>
            savedTodo <span class="ot">&lt;-</span> withDb <span class="fu">$</span> \conn <span class="ot">-&gt;</span> Db.saveTodo conn user todo
            writeJSON savedTodo</code></pre>
<p>Function <code>handleTodos</code> handles either <code>GET</code> or <code>POST</code> requests, for retrieving and modifying todo items. All its request parameters come in as JSON – these are turned into Haskell objects using <code>getJSON</code> from <a href="http://hackage.haskell.org/packages/archive/snap-extras/0.3/doc/html/Snap-Extras-JSON.html">Snap.Extras.JSON</a>. Similarly, we use <code>writeJSON</code> for outputting the request response. Automatic JSON encode and decode is made possible by the <code>FromJSON</code> and <code>ToJSON</code> instances defined in the <a href="https://github.com/nurpax/snap-examples/blob/master/angularjs-todo/src/Db.hs">Db</a> module.</p>
<h2 id="debugging-json-responses">Debugging JSON responses</h2>
<p>A good way to debug your REST APIs is to use Chrome’s Developer Tools. Open the Developer console and click on the Network tab. When you load a page, you can see what requests are being made and you can inspect what JSON gets sent by clicking on the individual <code>/api/todo</code> requests. Here’s an example of what traffic gets generated when complete a to-do:</p>
<div class="screenshot white-bg">
<img src="/images/angular-todo2-check.png" title="Chrome dev tool view" />
</div>

<p>This is the result of a <code>todo.$save()</code> AJAX call.</p>
<h2 id="what-next">What next?</h2>
<p>Well.. The easy part is over. If you want to learn more about using AngularJS with Snap, I suggest that you:</p>
<ul>
<li>Read the <a href="http://angularjs.org/">AngularJS docs</a></li>
<li>Read the <a href="http://snapframework.com/">Snap Framework docs</a></li>
<li>Read the <a href="https://github.com/nurpax/snap-examples/tree/master/angularjs-todo">example source</a></li>
<li>Compile, run and play with the example</li>
</ul>
<p>HTH.</p>]]></summary>
</entry>
<entry>
    <title>Note to self</title>
    <link href="http://nurpax.github.com/posts/2013-01-04-note-to-self.html" />
    <id>http://nurpax.github.com/posts/2013-01-04-note-to-self.html</id>
    <published>2013-01-04T00:00:00Z</published>
    <updated>2013-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Note to self: Don’t use SQLite3 from multiple Haskell threads – at least not with <a href="http://hackage.haskell.org/package/sqlite-simple">sqlite-simple</a>.</p>
<p>I recently implemented a To-Do app (the “Hello World” of web apps) using <a href="http://angularjs.org/">AngularJS</a> on the frontend and <a href="http://snapframework.com/">Snap</a> on the backend. If you haven’t heard about AngularJS, I highly recommend you to check it out – it’s got a very clean approach to developing modern single-page web apps.</p>
<p>In my app, the Snap-based server was used mainly for authentication and persistence. The rest of the app runs client-side in JavaScript and talks to the server over a simple REST API. Getting all this up and running was surprisingly easy.</p>
<p>Anyhow.. Turns out it’s easy to write an AngularJS app that sends a lot of concurrent requests to the server, even in the single user case. As an example, you can iterate through a list of todo-items in JavaScript, persisting each item with a call to <code>item.$save()</code>:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="ot">$scope</span>.<span class="fu">archive</span> = <span class="kw">function</span>() {
        <span class="kw">var</span> oldTodos = <span class="ot">$scope</span>.<span class="fu">todos</span>;
        <span class="ot">$scope</span>.<span class="fu">todos</span> = [];
        <span class="ot">angular</span>.<span class="fu">forEach</span>(oldTodos, <span class="kw">function</span>(todo) {
            <span class="kw">if</span> (!<span class="ot">todo</span>.<span class="fu">done</span>)
                <span class="ot">$scope</span>.<span class="ot">todos</span>.<span class="fu">push</span>(todo);

            <span class="ot">todo</span>.<span class="fu">$save</span>();
        });
    };</code></pre>
<p>Each <code>$save()</code> triggers an AJAX call and the server will see these as multiple concurrent requests.</p>
<p>Unfortunately though, I started seeing lot of SQLITE_BUSY errors on the server side with this usage. Turns out accessing a single SQLite3 database from multiple threads, each with its own connection is not as simple as I thought. If you’re in the middle of reading rows from a SELECT and you issue an INSERT from another connection, the INSERT will fail with an SQLITE_BUSY error. Here’s Haskell code that reproduces this problem:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Direct</span> (
  directSqliteTest
  ) <span class="kw">where</span>

<span class="kw">import</span> Control.Monad
<span class="kw">import</span> Database.SQLite3.Direct

<span class="ot">directSqliteTest ::</span> <span class="dt">IO</span> ()
directSqliteTest <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">Right</span> conn1 <span class="ot">&lt;-</span> open <span class="st">&quot;test.db&quot;</span>
  <span class="kw">Right</span> conn2 <span class="ot">&lt;-</span> open <span class="st">&quot;test.db&quot;</span>

  exec conn1 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>
  exec conn1 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>

  <span class="kw">Right</span> (<span class="kw">Just</span> sr) <span class="ot">&lt;-</span> prepare conn1 <span class="st">&quot;SELECT * from a&quot;</span>
  a <span class="ot">&lt;-</span> step sr
  a <span class="ot">&lt;-</span> step sr
  <span class="fu">print</span> a
  x <span class="ot">&lt;-</span> exec conn2 <span class="st">&quot;INSERT INTO a (text) VALUES (&#39;foo&#39;)&quot;</span>
  <span class="co">-- ^^ SQLITE_BUSY is triggered</span>
  finalize sr
  <span class="fu">print</span> x

  void <span class="fu">$</span> close conn1
  void <span class="fu">$</span> close conn2</code></pre>
<p>The above code will print:</p>
<pre><code>$ ./dist/build/sqlite-test/sqlite-test
Right Row
Right Row
Left (ErrorBusy,Utf8 &quot;database is locked&quot;)</code></pre>
<p>As <a href="http://hackage.haskell.org/package/snaplet-sqlite-simple">snaplet-sqlite-simple</a> does connection pooling, the above pattern is very likely to happen. The SQLite snaplet maintains a connection pool which is used to service connections to request handlers. Concurrent requests will each be handed their own connection instead of using a single shared connection. A request can be in the middle of reading database rows from the while another request tries to write to the database using another connection, and <em>boom</em>, the above SQLITE_BUSY scenario triggers.</p>
<p>As a quick band-aid fix, I changed snaplet-sqlite-simple to not use a connection pool but instead allocate a single database handle on init and servicing the same handle sequentially to anyone that asks (<a href="https://github.com/nurpax/snaplet-sqlite-simple/commit/3957f722cce6abf7e1059f481668379e05b62286">commit 3957f722</a>). For extra safety, I also stuck the connection inside an <code>MVar</code> so that all SQLite operations get serialized within the Snap application.</p>
<p>Hopefully I’ll be able to switch to a more concurrent model in the future, but at least the current v0.4.0 release works without SQLITE_BUSY errors.</p>]]></summary>
</entry>
<entry>
    <title>Reading TCX in Haskell</title>
    <link href="http://nurpax.github.com/posts/2012-12-27-playing-with-hxt.html" />
    <id>http://nurpax.github.com/posts/2012-12-27-playing-with-hxt.html</id>
    <published>2012-12-27T00:00:00Z</published>
    <updated>2012-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I use a Garmin GPS/heart-rate monitor watch to track my running. I also upload this GPS data to a service called <a href="http://www.runkeeper.com">RunKeeper</a> to keep a history of my runs. While I’ve generally been happy with RunKeeper, my experience uploading Garmin GPS data to RunKeeper has been less than stellar. My biggest complaint is that usually the original GPS data changes significantly when uploaded to RunKeeper. For example, a 10.0 km run (according to Garmin) can become 10.2 km in RunKeeper.</p>
<p>I decided to do a bit of data mining on Garmin GPS files to figure out how RunKeeper interprets it differently. Garmin’s tools can export GPS data as both GPX and <a href="http://en.wikipedia.org/wiki/Training_Center_XML">TCX</a>. The latter format is developed by Garmin and quite likely the closest match to the their native format. Both GPX and TCX are XML.</p>
<p>I didn’t get very far with actual GPS track analysis but I did write a TCX file reader in Haskell using the <a href="http://hackage.haskell.org/package/hxt">Haskell XML Toolbox (hxt)</a> library. As there seems to be a bit of a lack of Haskell XML parsing examples on the Internet, I decided to post my TCX reader here as an example of parsing Real World XML data in Haskell.</p>
<p>Here’s a short sample of what a TCX file looks like (some elements have been omitted and xmlns URLs truncated for brevity):</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class="kw">?&gt;</span>
<span class="co">&lt;!-- Some elements omitted for brevity --&gt;</span>
<span class="kw">&lt;TrainingCenterDatabase</span>
<span class="ot">  xsi:schemaLocation=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/...d&quot;</span>
<span class="ot">  xmlns:ns5=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/ActivityGoals/v1&quot;</span>
<span class="ot">  xmlns:ns3=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/ActivityExtension/v2&quot;</span>
<span class="ot">  xmlns:ns2=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/UserProfile/v2&quot;</span>
<span class="ot">  xmlns=</span><span class="st">&quot;http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2&quot;</span>
<span class="ot">  xmlns:xsi=</span><span class="st">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><span class="ot"> xmlns:ns4=</span><span class="st">&quot;...&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;Activities&gt;</span>
    <span class="kw">&lt;Activity</span><span class="ot"> Sport=</span><span class="st">&quot;Biking&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;Id&gt;</span>2012-12-22T13:47:50.000Z<span class="kw">&lt;/Id&gt;</span>
      <span class="kw">&lt;Lap</span><span class="ot"> StartTime=</span><span class="st">&quot;2012-12-22T13:47:50.000Z&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;DistanceMeters&gt;</span>1000.0<span class="kw">&lt;/DistanceMeters&gt;</span>
        <span class="kw">&lt;Track&gt;</span>
          <span class="kw">&lt;Trackpoint&gt;</span>
            <span class="kw">&lt;Time&gt;</span>2012-12-22T13:47:49.000Z<span class="kw">&lt;/Time&gt;</span>
            <span class="kw">&lt;AltitudeMeters&gt;</span>-2.799999952316284<span class="kw">&lt;/AltitudeMeters&gt;</span>
            <span class="kw">&lt;DistanceMeters&gt;</span>0.0<span class="kw">&lt;/DistanceMeters&gt;</span>
            <span class="kw">&lt;HeartRateBpm&gt;</span>
              <span class="kw">&lt;Value&gt;</span>134<span class="kw">&lt;/Value&gt;</span>
            <span class="kw">&lt;/HeartRateBpm&gt;</span></code></pre>
<p>The Haskell code for TCX file reading can be found below (also up on <a href="https://github.com/nurpax/hs-tcx">github</a> with a .cabal file). Here’s an outline of what it does:</p>
<ul>
<li>The input XML document is read from a file called <code>test-act.tcx</code></li>
<li>The XML document is massaged into Haskell objects using HXT combinators</li>
<li>The resulting Haskell objects (<code>Activity</code>, <code>Lap</code> and <code>Trackpoint</code>) are traversed and output to stdout</li>
</ul>
<p>Note: As is probably obvious, this code is not meant to be comprehensive library for accessing TCX data – it’s really just an example of how to get started with HXT and TCX.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Arrows, NoMonomorphismRestriction #-}</span>

<span class="kw">import</span> Text.XML.HXT.Core
<span class="kw">import</span> Data.Time (UTCTime, readTime)
<span class="kw">import</span> System.Locale (defaultTimeLocale)

<span class="kw">data</span> <span class="dt">Activity</span> <span class="fu">=</span> <span class="dt">Activity</span> [<span class="dt">Lap</span>]
  <span class="kw">deriving</span> (<span class="kw">Show</span>)

<span class="kw">data</span> <span class="dt">Lap</span> <span class="fu">=</span> <span class="dt">Lap</span> {
<span class="ot">    lapDistance ::</span> <span class="dt">Float</span>
  ,<span class="ot"> lapTrackpoints ::</span> [<span class="dt">Trackpoint</span>]
  } <span class="kw">deriving</span> (<span class="kw">Show</span>)

<span class="kw">data</span> <span class="dt">Trackpoint</span> <span class="fu">=</span> <span class="dt">Trackpoint</span> {
<span class="ot">    tpTime ::</span> <span class="dt">UTCTime</span>
  ,<span class="ot"> tpBpm ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> (<span class="kw">Show</span>)

<span class="ot">atTag ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">XmlTree</span>
atTag tag <span class="fu">=</span> deep (isElem <span class="fu">&gt;&gt;&gt;</span> hasName tag)

<span class="ot">text ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">String</span>
text <span class="fu">=</span> getChildren <span class="fu">&gt;&gt;&gt;</span> getText

<span class="co">-- Note: the hardcoded .000 part is kludge but for my inputs this was</span>
<span class="co">-- an easy way to get timestamps to parse.</span>
<span class="ot">readt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>
readt <span class="fu">=</span> readTime defaultTimeLocale <span class="st">&quot;%FT%T.000%Z&quot;</span>

<span class="ot">getTrackpoint ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Trackpoint</span>
getTrackpoint <span class="fu">=</span> atTag <span class="st">&quot;Trackpoint&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    time <span class="ot">&lt;-</span> text <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Time&quot;</span> <span class="fu">-&lt;</span> x
    bpm <span class="ot">&lt;-</span> text <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Value&quot;</span> <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;HeartRateBpm&quot;</span> <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Trackpoint</span> (readt time) bpm

<span class="ot">getLap ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Lap</span>
getLap <span class="fu">=</span> getChildren <span class="fu">&gt;&gt;&gt;</span> isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;Lap&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    pts <span class="ot">&lt;-</span> listA getTrackpoint <span class="fu">&lt;&lt;&lt;</span> atTag <span class="st">&quot;Track&quot;</span> <span class="fu">-&lt;</span> x
    dist <span class="ot">&lt;-</span> getChildren <span class="fu">&gt;&gt;&gt;</span> isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;DistanceMeters&quot;</span> <span class="fu">&gt;&gt;&gt;</span> text <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Lap</span> (<span class="fu">read</span> dist) pts

<span class="ot">getActivity ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> <span class="dt">Activity</span>
getActivity <span class="fu">=</span> atTag <span class="st">&quot;Activity&quot;</span> <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    laps <span class="ot">&lt;-</span> listA getLap <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> <span class="dt">Activity</span> laps

<span class="ot">getActivities ::</span> <span class="dt">ArrowXml</span> a <span class="ot">=&gt;</span> a <span class="dt">XmlTree</span> [<span class="dt">Activity</span>]
getActivities <span class="fu">=</span> deep (isElem <span class="fu">&gt;&gt;&gt;</span> hasName <span class="st">&quot;TrainingCenterDatabase&quot;</span> <span class="fu">/&gt;</span> hasName <span class="st">&quot;Activities&quot;</span>) <span class="fu">&gt;&gt;&gt;</span>
  proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
    activities <span class="ot">&lt;-</span> listA getActivity <span class="fu">-&lt;</span> x
    returnA <span class="fu">-&lt;</span> activities

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  activities <span class="ot">&lt;-</span> runX (readDocument [withValidate no] <span class="st">&quot;test-act.tcx&quot;</span> <span class="fu">&gt;&gt;&gt;</span> getActivities)
  <span class="fu">mapM_</span> printActivity (<span class="fu">head</span> activities)
  <span class="kw">where</span>
    printActivity (<span class="dt">Activity</span> laps) <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">putStrLn</span> <span class="st">&quot;Activity:&quot;</span>
      <span class="fu">mapM_</span> printLaps laps

    printLaps (<span class="dt">Lap</span> distance trackpts) <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">putStrLn</span> <span class="st">&quot;  Lap:&quot;</span>
      <span class="fu">putStrLn</span> (<span class="st">&quot;    Distance: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> distance)
      <span class="fu">mapM_</span> printTrackpoint trackpts

    printTrackpoint (<span class="dt">Trackpoint</span> time bpm) <span class="fu">=</span>
      <span class="fu">putStrLn</span> (<span class="st">&quot;    time: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> time <span class="fu">++</span> <span class="st">&quot; bpm: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> bpm)</code></pre>]]></summary>
</entry>
<entry>
    <title>Snap with SQLite</title>
    <link href="http://nurpax.github.com/posts/2012-12-20-snaplet-sqlite-simple-example.html" />
    <id>http://nurpax.github.com/posts/2012-12-20-snaplet-sqlite-simple-example.html</id>
    <published>2012-12-20T00:00:00Z</published>
    <updated>2012-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I recently released <a href="http://hackage.haskell.org/package/snaplet-sqlite-simple">snaplet-sqlite-simple 0.3</a>, a compatibility update for the recently released <a href="http://hackage.haskell.org/package/snap">Snap 0.10</a>. This library is glue for hooking up a Snap application to an <a href="http://www.sqlite.org/">SQLite</a> database using the <a href="http://hackage.haskell.org/package/sqlite-simple">sqlite-simple</a> library. Using SQLite with Snap is a handy, light-weight approach for quickly prototyping database-backed web apps – you don’t need to configure a separate SQL server just to run your web app.</p>
<p>While the new snaplet-sqlite-simple 0.3 release doesn’t add any significant new functionality, I thought a few things in its <a href="https://github.com/nurpax/snaplet-sqlite-simple/tree/master/example/src">example project</a> would be worth a mention.</p>
<p>This example project implements a simple web app that has a login screen (with new user registration) and a main page where logged in users can drop comments. Users and comments are both persisted into an SQLite database.</p>
<p>Here’s a couple of screenshots to show how it looks like. Let’s start with the login screen:</p>
<div class="screenshot white-bg">
<img src="/images/snaplet-sqlite-simple-example-login.png" title="Login screen" />
</div>

<p>If you create a new user and login to the app, you’re taken to the main page. Here the logged in user can add comments. The comments get persisted into a database and are associated with the current user (e.g., other users can’t see them.) Here’s how the main page looks like:</p>
<div class="screenshot white-bg">
<img src="/images/snaplet-sqlite-simple-example-comments.png" title="Main page" />
</div>

<p>The example demonstrates a few basic concepts in a complete example:</p>
<ul>
<li>Connecting to an SQLite database</li>
<li>Creating database tables (if not created) on web app’s init</li>
<li>Associating your own user data with Snap’s <a href="http://hackage.haskell.org/packages/archive/snap/0.10.0.1/doc/html/Snap-Snaplet-Auth.html">Snap.Snaplet.Auth</a> user objects</li>
<li>Making simple database queries and rendering the results on the main screen</li>
</ul>
<p>Setting up the connection is easy, see the <code>app</code> function in <a href="https://github.com/nurpax/snaplet-sqlite-simple/blob/master/example/src/Site.hs">Site.hs</a>.</p>
<p>Creating the database schema on app startup is perhaps less obvious. This also happens on app init:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The application initializer.</span>
<span class="ot">app ::</span> <span class="dt">SnapletInit</span> <span class="dt">App</span> <span class="dt">App</span>
<span class="co">-- ...</span>
    <span class="co">-- Grab the DB connection pool from the sqlite snaplet and call</span>
    <span class="co">-- into the Model to create all the DB tables if necessary.</span>
    <span class="kw">let</span> connPool <span class="fu">=</span> sqlitePool <span class="fu">$</span> d <span class="fu">^#</span> snapletValue
    liftIO <span class="fu">$</span> withResource connPool <span class="fu">$</span> \conn <span class="ot">-&gt;</span> Db.createTables conn</code></pre>
<p>The actual table creation is done in <a href="https://github.com/nurpax/snaplet-sqlite-simple/blob/master/example/src/Db.hs">Db.hs</a>. This module also contains query functions for saving and listing comments for a given user.</p>
<p>Everything on the main page requires a logged in user. Requiring a logged in user is ensured using <code>withLoggedInUser</code> which either calls a handler with the currently logged in user or redirects to the login screen. It’s defined as:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Run actions with a logged in user or go back to the login screen</span>
<span class="ot">withLoggedInUser ::</span> (<span class="dt">Db.User</span> <span class="ot">-&gt;</span> <span class="dt">H</span> ()) <span class="ot">-&gt;</span> <span class="dt">H</span> ()
withLoggedInUser action <span class="fu">=</span>
  currentUser <span class="fu">&gt;&gt;=</span> go
  <span class="kw">where</span>
    go <span class="kw">Nothing</span>  <span class="fu">=</span> handleLogin (<span class="kw">Just</span> <span class="st">&quot;Must be logged in to view the main page&quot;</span>)
    go (<span class="kw">Just</span> u) <span class="fu">=</span> maybeWhen (userId u) (action <span class="fu">.</span> user)
      <span class="kw">where</span>
        user uid <span class="fu">=</span> <span class="dt">Db.User</span> (<span class="fu">read</span> <span class="fu">.</span> T.unpack <span class="fu">$</span> unUid uid) (userLogin u)</code></pre>
<p>You can use it anywhere you need to access the currently logged in user. For example, here’s how the main page handler deals with the current user:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mainPage ::</span> <span class="dt">H</span> ()
mainPage <span class="fu">=</span> withLoggedInUser go
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Db.User</span> <span class="ot">-&gt;</span> <span class="dt">H</span> ()
    go user <span class="fu">=</span> <span class="kw">do</span>
      comments <span class="ot">&lt;-</span> withTop db <span class="fu">$</span> Db.listComments user
      heistLocal (splices comments) <span class="fu">$</span> render <span class="st">&quot;/index&quot;</span>
    splices cs <span class="fu">=</span>
      I.bindSplices [(<span class="st">&quot;comments&quot;</span>, I.mapSplices renderComment cs)]</code></pre>
<p>To learn more about using sqlite-simple with Snap, I recommend you clone the code from Git, build the example, play with the app and read the <a href="https://github.com/nurpax/snaplet-sqlite-simple/tree/master/example/src">example source code</a>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone git://github.com/nurpax/snaplet-sqlite-simple.git
<span class="kw">cd</span> example
<span class="kw">cabal-dev</span> install
<span class="kw">./cabal-dev/bin/example</span>
<span class="co"># browse to http://localhost:8000</span></code></pre>]]></summary>
</entry>

</feed>
