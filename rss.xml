<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>nurpax.github.com blog</title>
    <link href="http://nurpax.github.com/rss.xml" rel="self" />
    <link href="http://nurpax.github.com" />
    <id>http://nurpax.github.com/rss.xml</id>
    <author>
        <name>Janne Hellsten</name>
        
        <email>jjhellst@gmail.com</email>
        
    </author>
    <updated>2023-01-01T00:00:00Z</updated>
    <entry>
    <title>A quick blog update</title>
    <link href="http://nurpax.github.com/posts/2023-01-01-updated.html" />
    <id>http://nurpax.github.com/posts/2023-01-01-updated.html</id>
    <published>2023-01-01T00:00:00Z</published>
    <updated>2023-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wanted to push an update to this blog as I finally ripped out Google Analytics from these pages. The GA scripts got out of date and I didn‚Äôt need the analytics anyway. Haven‚Äôt touched the blog code since 2021 so it took some catching up to get the Haskell Hakyll based blog to build.</p>
<p>If you‚Äôve followed me on Twitter, you may have noticed I‚Äôve gone silent there. I‚Äôm not a fan of the X site so you may find me on <a href="https://mastodon.gamedev.place/@nurpax">mastodon.gamedev.place/<span class="citation" data-cites="nurpax">@nurpax</span></a> or on <a href="https://bsky.app/profile/nurpax.bsky.social">bsky.app/profile/nurpax.bsky.social</a> instead.</p>
<p>I‚Äôve lately been interested in the <a href="https://ziglang.org/">Zig programming language</a>. Here‚Äôs a couple of Zig projects that I‚Äôve either authored or have been involved in somehow:</p>
<ul>
<li><p><a href="https://github.com/nurpax/zigrograd">Zigrograd</a> - scalar-valued autograd written in Zig. Inspired by Andrej Karpathy‚Äôs <a href="https://github.com/karpathy/micrograd">micrograd</a>, I decided to port micrograd to Zig. It contains a mini-implementation of Numpy (ehh, zigpy?) and the autograd engine is tensor based now. It‚Äôs actually pretty fast for a CPU-only implementation. I‚Äôve been adding convolutional layers to it too but haven‚Äôt released it yet as the GEMM routine at the core of those layers is not fast enough yet. It‚Äôs just a coding playground type of project, not intended to be really useful for anything.</p></li>
<li><p><a href="https://github.com/natecraddock/ziglua">Ziglua</a> - Zig bindings for Lua/(soon to be released) Luau. I didn‚Äôt author this, have just been reviewing and suggesting changes to it to add Luau support. I‚Äôm interested in using Luau in some personal gamedev projects.</p></li>
<li><p><a href="https://github.com/nurpax/zig-imgui">Zig-imgui</a> - Sokol gfx + imgui setup for Zig. Very much WIP and very likely to fail to build (<em>‚ÄúThe build breaks will continue until morale improves‚Äù</em> as they say in the Zig circles..).</p></li>
</ul>
<p>I think I‚Äôll write more about Ziglua here later.</p>
<p>Happy New Year!</p>]]></summary>
</entry>
<entry>
    <title>Debugging C64jasm projects with VICE and C64Debugger</title>
    <link href="http://nurpax.github.com/posts/2021-02-22-c64jasm-debug-info.html" />
    <id>http://nurpax.github.com/posts/2021-02-22-c64jasm-debug-info.html</id>
    <published>2021-02-22T00:00:00Z</published>
    <updated>2021-02-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is a tutorial on how to export debug info from projects compiled with <a href="https://nurpax.github.io/c64jasm/">c64jasm</a> for use with <a href="https://vice-emu.sourceforge.io/">VICE</a> and <a href="https://sourceforge.net/projects/c64-debugger/">C64Debugger</a>.</p>
<p>C64jasm 0.9.1 added debug symbol output support for VICE and C64Debugger. The debug info files come in two flavors:</p>
<ul>
<li><code>--vice-moncommands</code>: VICE monitor commands file to show label names in the monitor.</li>
<li><code>--c64debugger-symbols</code>: KickAss debug symbols for C64Debugger. Maps program addresses to source locations enabling source level debugging.</li>
</ul>
<p>Both flavors support setting breakpoints in the assembly source with the <code>!break</code> directive.</p>
<h1 id="vice-monitor-commands">VICE monitor commands</h1>
<p>To enable easier debugging with VICE, you can use the <code>--vice-moncommands</code> option to generate a program address to label name mapping script (moncommands). This script also includes break commands if any of the source files used the <code>!break</code> directive to set breakpoints.</p>
<p>Here‚Äôs how to output and use a moncommands script. You can try this with the c64jasm git repository or your own assembly project.</p>
<pre><code>git clone https://github.com/nurpax/c64jasm.git
cd c64jasm/examples/content-pipe</code></pre>
<p>Edit src/main.asm and add a <code>!break</code> as below:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>+basic_start<span class="op">(</span>entry<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">;--------------------------------------------------------------</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">; Execution starts here</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">;--------------------------------------------------------------</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">entry:</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    !<span class="pp">break</span>          <span class="co">; üëà add breakpoint here!</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    jsr music<span class="op">.</span>init</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    sei</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#$</span><span class="bn">35</span>        <span class="co">; Bank out kernal and basic</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span><span class="bn">01</span>         <span class="co">; $e000-$ffff</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    +setup_irq<span class="op">(</span>irq_top<span class="op">,</span> irq_top_line<span class="op">)</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">cli</span></span></code></pre></div>
<p>Then compile the project:</p>
<pre><code>c64jasm src/main.asm --vice-moncommands=main.vs --out main.prg</code></pre>
<p>This produces two files: <code>main.prg</code> and <code>main.vs</code>. The contents of <code>main.vs</code> should look something like this:</p>
<pre><code>al C:080d .entry
al C:0854 .entry::frame_loop
al C:0857 .entry::vsync
al C:0868 .animate_sprites
al C:086d .animate_sprites::anim_sprites
al C:0891 .animate_sprites::anim_sprites_x
[bunch of lines omitted..]
al C:20e8 .pet_rle::decode::decode_line::dst
al C:20f2 .background_petscii_rle</code></pre>
<p>You can use these files in VICE like so:</p>
<pre><code>x64 -moncommands main.vs main.prg</code></pre>
<p>If everything went fine, VICE should break into the monitor at the start of the example project. Depending on your VICE build and configuration, you will see the monitor either in a separate window (preferred) or in the VICE C64 window like on my MBP:</p>
<div class="center">
<img width="100%" src="/images/c64/c64jasm/vice-monitor-disasm.png" />
</div>
<p>You can step through instructions with <code>step</code>, disassemble from the current program counter with <code>disass</code> or continue execution with <code>g</code>. (You should be able to enter the monitor also using a keyboard shortcut <code>ALT-H</code> but I keep pressing it and nothing happens. ü§∑‚Äç‚ôÄÔ∏è)</p>
<h1 id="c64debugger-and-source-level-debugging">C64Debugger and source-level debugging</h1>
<p>Using the same example project from above, here‚Äôs how you will build the project and produce C64Debugger compatible debug symbols:</p>
<pre><code>c64jasm src/main.asm --c64debugger-symbols=main.dbg --out main.prg</code></pre>
<p>You can start C64Debugger with the below command. (It takes a bit of time for the debugger to start ‚Äì there may be better way to run a .prg with C64Debugger.)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This invocation assumes KickAss debug symbols reside in main.dbg, as generated</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># above with c64jasm.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ex">c64debugger</span> <span class="at">-wait</span> 2500 <span class="at">-autojmp</span> <span class="at">-layout</span> 9 <span class="at">-prg</span> main.prg</span></code></pre></div>
<p>C64Debugger should break at the start of the example project and you should see something like this:</p>
<div class="center">
<img width="100%" src="/images/c64/c64jasm/c64debugger-entry-break.png" />
</div>
<p>This is where it gets interesting. C64Debugger supports source-level debugging so that you can see a side-by-side view of your program‚Äôs disassembly and original assembly source code. You can enter this mode with <code>CTRL-SHIFT-F3</code> and your C64Debugger should show a view like this:</p>
<div class="center">
<img width="100%" src="/images/c64/c64jasm/c64debugger-source-debug.png" />
</div>
<p>You can step through instructions by pressing <code>F10</code> and continue execution with <code>F11</code>.</p>
<p>Here‚Äôs a nice summary of C64Debugger keyboard shortcuts: <a href="https://github.com/sunsided/c64-debugger/blob/github/Docs/C64%20Debugger%20shortcuts%20v06458.pdf">C64 Debugger shortcuts v06458.pdf</a>. I couldn‚Äôt find this nicely formatted PDF from their project page.</p>
<p>This is it for this debug info tutorial. Happy debugging!</p>]]></summary>
</entry>
<entry>
    <title>Python argparse</title>
    <link href="http://nurpax.github.com/posts/2019-12-04-argparse.html" />
    <id>http://nurpax.github.com/posts/2019-12-04-argparse.html</id>
    <published>2019-12-04T00:00:00Z</published>
    <updated>2019-12-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>How I use argparse.</p>
<h2 id="basic-main-stub">Basic main() stub</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> argparse</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>_examples <span class="op">=</span> <span class="st">&#39;&#39;&#39;examples:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">  # Run x, y, z</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">  python </span><span class="sc">%(prog)s</span><span class="st"> --output=tmp</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;&#39;&#39;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    parser <span class="op">=</span> argparse.ArgumentParser(</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">&#39;Argparse test&#39;</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        epilog<span class="op">=</span>_examples,</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        formatter_class<span class="op">=</span>argparse.RawDescriptionHelpFormatter</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    parser.add_argument(<span class="st">&#39;--output&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify output dir&#39;</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    args <span class="op">=</span> parser.parse_args()</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="bu">vars</span>(args))</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    main()</span></code></pre></div>
<h2 id="argument-default-values">Argument default values</h2>
<p>Use <code>default=</code> to set a default value for an argument.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--format&#39;</span>, default<span class="op">=</span><span class="st">&#39;html&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify output format&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;FMT&#39;</span>)</span></code></pre></div>
<p>To show default values in your help strings, use <code>%(default)s</code> interpolation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--format&#39;</span>, default<span class="op">=</span><span class="st">&#39;html&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify output format (default: </span><span class="sc">%(default)s</span><span class="st">)&#39;</span>)</span></code></pre></div>
<p>If the default value is type <code>str</code>, it will be run through your <code>type</code> callback, otherwise it‚Äôs returned directly. This can be helpful when authoring help strings containing <code>%(default)s</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--enable-x&#39;</span>, <span class="bu">type</span><span class="op">=</span>_str_to_bool, default<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Enable feature x (default: </span><span class="sc">%(default)s</span><span class="st">)&#39;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># outputs: --enable-x ENABLE_X   Enable feature x (default: True)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--enable-y&#39;</span>, <span class="bu">type</span><span class="op">=</span>_str_to_bool, default<span class="op">=</span><span class="st">&#39;y&#39;</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Enable feature y (default: </span><span class="sc">%(default)s</span><span class="st">)&#39;</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># outputs: --enable-y ENABLE_Y   Enable feature y (default: y)</span></span></code></pre></div>
<h2 id="argument-types">Argument types</h2>
<p>Use <code>type=</code> to set your own type conversion function. A <code>type</code> is just a function that converts a string to some output type.</p>
<p><strong>Numbers.</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--int-val&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">int</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify integer&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;N&#39;</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--flt-val&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">float</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify float&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;N&#39;</span>)</span></code></pre></div>
<p><strong>Booleans.</strong> You can‚Äôt use <code>type=bool</code> for booleans (try running <code>bool('True')</code> in the REPL if you want to know why.) Do this instead:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _str_to_bool(v):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(v, <span class="bu">bool</span>):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> v.lower() <span class="kw">in</span> (<span class="st">&#39;yes&#39;</span>, <span class="st">&#39;true&#39;</span>, <span class="st">&#39;t&#39;</span>, <span class="st">&#39;y&#39;</span>, <span class="st">&#39;1&#39;</span>):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> v.lower() <span class="kw">in</span> (<span class="st">&#39;no&#39;</span>, <span class="st">&#39;false&#39;</span>, <span class="st">&#39;f&#39;</span>, <span class="st">&#39;n&#39;</span>, <span class="st">&#39;0&#39;</span>):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> argparse.ArgumentTypeError(<span class="st">&#39;Boolean value expected.&#39;</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--enable-output&#39;</span>, <span class="bu">type</span><span class="op">=</span>_str_to_bool, default<span class="op">=</span><span class="va">False</span>, metavar<span class="op">=</span><span class="st">&#39;BOOL&#39;</span>)</span></code></pre></div>
<p><strong>Comma-separated list of values.</strong> How to specify a list of strings like <code>python foo.py --tags=apple,fruit</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parse_comma_sep(s):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (s <span class="kw">is</span> <span class="va">None</span>) <span class="kw">or</span> (s <span class="op">==</span> <span class="st">&#39;&#39;</span>):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s.split(<span class="st">&#39;,&#39;</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>parser.add_argument(<span class="st">&#39;--tags&#39;</span>, <span class="bu">type</span><span class="op">=</span>_parse_comma_sep, default<span class="op">=</span><span class="st">&#39;&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;TAGS&#39;</span>)</span></code></pre></div>
<h2 id="subcommands">Subcommands</h2>
<p>Add a subcommand called <code>log</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> argparse</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>_examples <span class="op">=</span> <span class="st">&#39;&#39;&#39;examples:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="st">  # Show log in html format</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="st">  python </span><span class="sc">%(prog)s</span><span class="st"> log --format=html</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;&#39;&#39;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    parser <span class="op">=</span> argparse.ArgumentParser(</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        description<span class="op">=</span><span class="st">&#39;Argparse test&#39;</span>,</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        epilog<span class="op">=</span>_examples,</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        formatter_class<span class="op">=</span>argparse.RawDescriptionHelpFormatter</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    subparsers <span class="op">=</span> parser.add_subparsers(<span class="bu">help</span><span class="op">=</span><span class="st">&#39;Sub-commands&#39;</span>, dest<span class="op">=</span><span class="st">&#39;command&#39;</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    parser_log <span class="op">=</span> subparsers.add_parser(<span class="st">&#39;log&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Show log&#39;</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    parser_log.add_argument(<span class="st">&#39;--format&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify format&#39;</span>, choices<span class="op">=</span>[<span class="st">&#39;raw&#39;</span>, <span class="st">&#39;html&#39;</span>])</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    args <span class="op">=</span> parser.parse_args()</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> (<span class="bu">vars</span>(args))</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    main()</span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>Dirty tricks 6502 programmers use</title>
    <link href="http://nurpax.github.com/posts/2019-08-18-dirty-tricks-6502-programmers-use.html" />
    <id>http://nurpax.github.com/posts/2019-08-18-dirty-tricks-6502-programmers-use.html</id>
    <published>2019-08-18T00:00:00Z</published>
    <updated>2019-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post recaps some of the C64 coding tricks used in my little <a href="https://twitter.com/nurpax/status/1159192477598965766">Commodore 64 coding competition</a>. The competition rules were simple: make a C64 executable (PRG) that draws two lines to form the below image. The objective was to do this in as few bytes as possible.</p>
<div class="center">
<img width="75%" class="img-pixelated" src="/images/c64/lines/lines-2x.png" />
</div>
<p>Entries were posted as Twitter replies and DMs, containing only the PRG byte-length and an MD5 hash of the PRG file.</p>
<p>Here‚Äôs a list of participants with source code links to their submissions:</p>
<ul>
<li><a href="https://twitter.com/fsphil">Philip Heron</a> (<a href="https://github.com/fsphil/tinyx">code</a> - 34 bytes - compo winner)</li>
<li><a href="https://twitter.com/GeirSigmund">Geir Straume</a> (<a href="https://c64prg.appspot.com/downloads/lines34b.zip">code</a> - 34 bytes)</li>
<li><a href="https://twitter.com/petrih3">Petri H√§kkinen</a> (<a href="https://github.com/petrihakkinen/c64-lines">code</a> - 37 bytes)</li>
<li><a href="https://twitter.com/laubzega">Mathlev Raxenblatz</a> (<a href="https://gist.github.com/laubzega/fb59ee6a3d482feb509dae7b77e925cf">code</a> - 38 bytes)</li>
<li><a href="https://twitter.com/achrenico">Jan Achrenius</a> (<a href="https://twitter.com/achrenico/status/1161383381835362305">code</a> - 48 bytes)</li>
<li><a href="https://twitter.com/jamie30dbs">Jamie Fuller</a> (<a href="https://github.com/30dbs/c64x">code</a> - 50 bytes)</li>
<li><a href="https://twitter.com/dagershman">David A. Gershman</a> (<a href="http://c64.dagertech.net/cgi-bin/cgiwrap/c64/index.cgi?p=xchallenge/.git;a=tree">code</a> - 53 bytes)</li>
<li><a href="https://twitter.com/nurpax">Janne Hellsten</a> (<a href="https://gist.github.com/nurpax/d429be441c7a9f4a6ceffbddc35a0003">code</a> - 56 bytes)</li>
</ul>
<p>(If I missed someone, please let me know and I‚Äôll update the post.)</p>
<p>The rest of this post focuses on some of the assembly coding tricks used in the compo submissions.</p>
<h2 id="basics">Basics</h2>
<p>The C64 default graphics mode is the 40x25 charset mode. The framebuffer is split into two arrays in RAM:</p>
<ul>
<li><code>$0400</code> (Screen RAM, 40x25 bytes)</li>
<li><code>$d800</code> (Color RAM, 40x25 bytes)</li>
</ul>
<p>To set a character, you store a byte into screen RAM at <code>$0400</code> (e.g., <code>$0400+y*40+x</code>). Color RAM is by default initialized to light blue (color 14) which happens to be the same color we use for the lines ‚Äì meaning we can leave color RAM untouched.</p>
<p>You can control the border and background colors with memory mapped I/O registers at <code>$d020</code> (border) and <code>$d021</code> (background).</p>
<p>Drawing the two lines is pretty easy as we can hardcode for the fixed line slope. Here‚Äôs a C implementation that draws the lines and dumps screen contents on stdout (register writes stubbed out and screen RAM is <code>malloc()</code>‚Äôd to make it run on PC):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dump<span class="op">(</span><span class="dt">const</span> <span class="dt">uint8_t</span><span class="op">*</span> screen<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">uint8_t</span><span class="op">*</span> s <span class="op">=</span> screen<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> y <span class="op">&lt;</span> <span class="dv">25</span><span class="op">;</span> y<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++,</span> s<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>s <span class="op">==</span> <span class="bn">0xa0</span> <span class="op">?</span> <span class="ch">&#39;#&#39;</span> <span class="op">:</span> <span class="ch">&#39;.&#39;</span><span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> setreg<span class="op">(</span><span class="dt">uintptr_t</span> dst<span class="op">,</span> <span class="dt">uint8_t</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">//  *((uint8_t *)dst) = v;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">//  uint8_t* screenRAM = (uint_8*)0x0400;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span><span class="op">*</span> screenRAM <span class="op">=</span> <span class="op">(</span><span class="dt">uint8_t</span> <span class="op">*)</span>calloc<span class="op">(</span><span class="dv">40</span><span class="op">*</span><span class="dv">25</span><span class="op">,</span> <span class="bn">0x20</span><span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    setreg<span class="op">(</span><span class="bn">0xd020</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Set border color</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    setreg<span class="op">(</span><span class="bn">0xd021</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Set background color</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yslope <span class="op">=</span> <span class="op">(</span><span class="dv">25</span><span class="op">&lt;&lt;</span><span class="dv">8</span><span class="op">)/</span><span class="dv">40</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yf <span class="op">=</span> yslope<span class="op">/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> yi <span class="op">=</span> yf <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// First line</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        screenRAM<span class="op">[</span>x <span class="op">+</span> yi<span class="op">*</span><span class="dv">40</span><span class="op">]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Second line (X-mirrored)</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        screenRAM<span class="op">[(</span><span class="dv">39</span><span class="op">-</span>x<span class="op">)</span> <span class="op">+</span> yi<span class="op">*</span><span class="dv">40</span><span class="op">]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        yf <span class="op">+=</span> yslope<span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    dump<span class="op">(</span>screenRAM<span class="op">);</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The screen codes used above are: <code>$20</code> (blank) and <code>$a0</code> (8x8 filled block). If you run it, you should see ASCII art for the two lines:</p>
<pre class="narrowlines"><code>##....................................##
..#..................................#..
...##..............................##...
.....#............................#.....
......##........................##......
........##....................##........
..........#..................#..........
...........##..............##...........
.............#............#.............
..............##........##..............
................##....##................
..................#..#..................
...................##...................
..................#..#..................
................##....##................
..............##........##..............
.............#............#.............
...........##..............##...........
..........#..................#..........
........##....................##........
......##........................##......
.....#............................#.....
...##..............................##...
..#..................................#..
##....................................##</code></pre>
<p>Using 6502 assembly and assembly pseudos, we can trivially implement the same in assembly:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>!<span class="bu">include</span> <span class="st">&quot;c64.asm&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>+c64<span class="op">::</span>basic_start<span class="op">(</span>entry<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">entry:</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span>      <span class="co">; black color</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d020   <span class="co">; set border to 0</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d021   <span class="co">; set background to 0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">; clear the screen</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    ldx <span class="op">#</span><span class="dv">0</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#$</span><span class="bn">20</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="fu">clrscr:</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>!for i in <span class="op">[</span><span class="dv">0</span><span class="op">,</span> <span class="op">$</span><span class="bn">100</span><span class="op">,</span> <span class="op">$</span><span class="bn">200</span><span class="op">,</span> <span class="op">$</span><span class="bn">300</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> i<span class="op">,</span> x</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    inx</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    bne clrscr</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">; line drawing, completely unrolled</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">; with assembly pseudos</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#$</span>a0</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    !for i in range<span class="op">(</span><span class="dv">40</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        !let y0 <span class="op">=</span> Math<span class="op">.</span>floor<span class="op">(</span><span class="dv">25</span><span class="op">/</span><span class="dv">40</span><span class="op">*(</span>i<span class="op">+</span><span class="fl">0.5</span><span class="op">))</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> y0<span class="op">*</span><span class="dv">40</span> <span class="op">+</span> i</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="op">(</span><span class="dv">24</span><span class="op">-</span>y0<span class="op">)*</span><span class="dv">40</span> <span class="op">+</span> i</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span> <span class="cf">jmp</span> inf  <span class="co">; halt</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This completely unrolls the line drawing part resulting in a fairly large 286 byte PRG.</p>
<p>Before diving into optimized variants, let‚Äôs make a couple of observations:</p>
<p>First, we‚Äôre running on the C64 with the ROM routines banked in. There‚Äôs a bunch of subroutines in ROM that may be useful for our little program. For example, you can clear the screen with <code>JSR $E544</code>.</p>
<p>Second, address calculations on an 8-bit CPU like the 6502 can be cumbersome and cost a lot of bytes. This CPU also doesn‚Äôt have a multiplier, so computing something like <code>y*40+i</code> usually involves either a bunch of logical shifts or a lookup table, again costing bytes. To avoid multiplying by 40, we can instead advance the screen pointer incrementally:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yslope <span class="op">=</span> <span class="op">(</span><span class="dv">25</span><span class="op">&lt;&lt;</span><span class="dv">8</span><span class="op">)/</span><span class="dv">40</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> yf <span class="op">=</span> yslope<span class="op">/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span><span class="op">*</span> dst <span class="op">=</span> screenRAM<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        dst<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        dst<span class="op">[(</span><span class="dv">39</span><span class="op">-</span>x<span class="op">)]</span> <span class="op">=</span> <span class="bn">0xa0</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        yf <span class="op">+=</span> yslope<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>yf <span class="op">&amp;</span> <span class="dv">256</span><span class="op">)</span> <span class="op">{</span> <span class="co">// Carry set?</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            dst <span class="op">+=</span> <span class="dv">40</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            yf <span class="op">&amp;=</span> <span class="dv">255</span><span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>We keep adding the line slope to a fixed point counter <code>yf</code> and when the 8-bit addition sets the carry flag, add 40.</p>
<p>Here‚Äôs the incremental approach implemented in assembly:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>!<span class="bu">include</span> <span class="st">&quot;c64.asm&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>+c64<span class="op">::</span>basic_start<span class="op">(</span>entry<span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>!let screenptr <span class="op">=</span> <span class="op">$</span><span class="bn">20</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>!let x0 <span class="op">=</span> <span class="op">$</span><span class="bn">40</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>!let x1 <span class="op">=</span> <span class="op">$</span><span class="bn">41</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>!let yf <span class="op">=</span> <span class="op">$</span><span class="bn">60</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="fu">entry:</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        sta x0</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span>d020</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span>d021</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">; kernal clear screen</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e544</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">; set screenptr = $0400</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&lt;$</span><span class="bn">0400</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">0</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&gt;$</span><span class="bn">0400</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">80</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        ldy x0</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">; screenRAM[x] = 0xA0</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">(</span>screenptr<span class="op">),</span> y</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        ldy x1</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">; screenRAM[39-x] = 0xA0</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">(</span>screenptr<span class="op">),</span> y</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">clc</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">160</span>  <span class="co">; line slope</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        bcc no_add</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">; advance screen ptr by 40</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">clc</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        lda screenptr</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">40</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>        sta screenptr</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        lda screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a><span class="fu">no_add:</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> x0</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        bpl xloop</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    <span class="cf">jmp</span> inf</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>At 82 bytes, this is still pretty hefty. A couple of obvious size problems arise from 16-bit address computations:</p>
<p>Setting up the <code>screenptr</code> value for indirect-indexed addressing:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">; set screenptr = $0400</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&lt;$</span><span class="bn">0400</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#&gt;$</span><span class="bn">0400</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span></code></pre></div>
<p>Advancing <code>screenptr</code> to the next row by adding 40:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">; advance screen ptr by 40</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">clc</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        lda screenptr</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">40</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        sta screenptr</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        lda screenptr<span class="op">+</span><span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        sta screenptr<span class="op">+</span><span class="dv">1</span></span></code></pre></div>
<p>Sure this code could probably be made smaller but what if we didn‚Äôt need manipulate 16-bit addresses in the first place? Let‚Äôs see this can be avoided.</p>
<h2 id="trick-1-scrolling">Trick 1: Scrolling!</h2>
<p>Instead of plotting the line across the screen RAM, we draw only on the last Y=24 screen row, and scroll the whole screen up by calling a ‚Äúscroll up‚Äù ROM function with <code>JSR $E8EA</code>!</p>
<p>The x-loop becomes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        sta x0</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        ldx x0</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">; hardcoded absolute address to last screen line</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        bcc no_scroll</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">; scroll screen up!</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e8ea</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="fu">no_scroll:</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> x0</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        bpl xloop</span></code></pre></div>
<p>Here‚Äôs how the line renderer progresses with this trick:</p>
<div class="center">
<img width="75%" class="img-pixelated" src="/images/c64/lines/lines-scroll.gif" />
</div>
<p>This trick was one of my favorites in this compo. It was also independently discovered by pretty much every participant.</p>
<h2 id="trick-2-self-modifying-code">Trick 2: Self-modifying code</h2>
<p>The code to store the pixel values ends up being roughly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">; hardcoded absolute address to last screen line</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        ldx x0</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> x0</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span></code></pre></div>
<p>This encodes into the following 14 byte sequence:</p>
<pre><code>0803: A6 22               LDX $22
0805: 9D C0 07            STA $07C0,X
0808: A6 20               LDX $20
080A: 9D C0 07            STA $07C0,X
080D: E6 22               INC $22
080F: C6 20               DEC $20</code></pre>
<p>There‚Äôs a more compact way to write this using self-modifying code (SMC)..</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">addr0:</span>  sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">; advance the second x-coord with SMC</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> addr0<span class="op">+</span><span class="dv">1</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span></code></pre></div>
<p>..which encodes to 13 bytes:</p>
<pre><code>0803: A6 22               LDX $22
0805: 9D C0 07            STA $07C0,X
0808: 8D C0 07            STA $07C0
080B: EE 09 08            INC $0809
080E: C6 22               DEC $22</code></pre>
<h2 id="trick-3-exploiting-the-power-on-state">Trick 3: Exploiting the power on state</h2>
<p>Making wild assumptions about the running environment was considered OK in this compo: the line drawing PRG is the first thing that‚Äôs run after C64 power on, and there was no requirement to exit cleanly back to the BASIC prompt. So anything you find from the initial environment upon entry to your PRG, you can and should use to your advantage. Here are some of the things that were considered ‚Äúconstant‚Äù upon entry to the PRG:</p>
<ul>
<li>A, X, Y registers were assumed to be all zeros</li>
<li>All CPU flags cleared</li>
<li>Zeropage (addresses <code>$00</code>-<code>$ff</code>) contents</li>
</ul>
<p>Similarly, if you called any KERNAL ROM routines, you could totally take advantage of any side-effects they might have: returned CPU flags, temporary values set into zeropage, etc.</p>
<p>After the first few size-optimization passes, everyone turned their eyes on this machine monitor view to look for any interesting values:</p>
<div class="center overflow">
<img class="img-pixelated" src="/images/c64/lines/monitor-screenshot.png" />
</div>
<p>The zeropage indeed contains some useful values for our purposes:</p>
<ul>
<li><code>$d5</code>: 39/$27 == line length - 1</li>
<li><code>$22</code>: 64/$40 == initial value for line slope counter</li>
</ul>
<p>You can use these to shave off a few bytes at init time. For example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>!let x0 <span class="op">=</span> <span class="op">$</span><span class="bn">20</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span>      <span class="co">; 0801: A9 27    LDA #$27</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        sta x0       <span class="co">; 0803: 85 20    STA $20</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x0       <span class="co">; 0805: C6 20    DEC $20</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        bpl xloop    <span class="co">; 0807: 10 FC    BPL $0805</span></span></code></pre></div>
<p>As <code>$d5</code> contains a value 39, you can map your <code>x0</code> counter to point to <code>$d5</code> and skip the LDA/STA pair:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>!let x0 <span class="op">=</span> <span class="op">$</span>d5</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">; nothing here!</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x0       <span class="co">; 0801: C6 D5    DEC $D5</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        bpl xloop    <span class="co">; 0803: 10 FC    BPL $0801</span></span></code></pre></div>
<p>Philip‚Äôs <a href="https://github.com/fsphil/tinyx/blob/master/x34/x34.s">winning entry</a> takes this to the extreme. Recall the address of the last char row <code>$07C0</code> (==<code>$0400+24*40</code>). This value does not exist in the zeropage on init. However, as a side-effect of how the ROM ‚Äúscroll up‚Äù subroutine uses zeropage temporaries, addresses <code>$D1-$D2</code> will contain <code>$07C0</code> on return from this function. So instead of <code>STA $07C0,x</code> to store a pixel, you can use the one byte shorter indirect-indexed addressing mode store <code>STA ($D1),y</code>.</p>
<h2 id="trick-4-smaller-startup">Trick 4: Smaller startup</h2>
<p>A typical C64 PRG binary file contains the following:</p>
<ul>
<li>First 2 bytes: loading address (usually <code>$0801</code>)</li>
<li>12 bytes of BASIC startup sequence</li>
</ul>
<p>The BASIC startup sequence looks like this (addresses <code>$801-$80C</code>):</p>
<pre><code>0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00
080D: 8D 20 D0     STA $D020</code></pre>
<p>Without going into details about <a href="https://www.c64-wiki.com/wiki/BASIC_token">tokenized BASIC memory layout</a>, this sequence more or less amounts to ‚Äú10 SYS 2061‚Äù. Address <code>2061</code> (<code>$080D</code>) is where our actual machine code program starts when the BASIC interpreter executes the SYS command.</p>
<p>14 bytes just to get going feels excessive. Philip, Mathlev and Geir had used some clever tricks to get rid of the BASIC sequence altogether. This requires that the PRG is loaded with <code>LOAD "*",8,1</code> as <code>LOAD "*",8</code> ignores the PRG loading address (the first two bytes) and always loads to <code>$0801</code>.</p>
<div class="center">
<img width="75%" class="img-pixelated" src="/images/c64/lines/vice-screen-sys.png" />
</div>
<p>Two methods were used:</p>
<ul>
<li>The stack trick</li>
<li>The BASIC warm reset vector trick</li>
</ul>
<h3 id="the-stack-trick">The stack trick</h3>
<p>The trick is to stomp the CPU stack at <code>$01F8</code> with a value that points to our desired entry point. This is done by crafting a PRG that starts with a 16-bit pointer pointing to our code and loading the PRG into <code>$01F8</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    * = $01F8</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    !<span class="dt">word</span> scroll <span class="op">-</span> <span class="dv">1</span>  <span class="co">; overwrite stack</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">scroll:</span>	jsr <span class="op">$</span>E8EA</span></code></pre></div>
<p>Once the BASIC loader (see <a href="https://www.pagetable.com/c64disasm/#F4A5">disassembly</a>) has finished loading and returns to its caller with <code>RTS</code>, instead of returning to whoever called LOAD, it returns right into our PRG.</p>
<h3 id="the-basic-warm-reset-vector-trick">The BASIC warm reset vector trick</h3>
<p>This is a little easier to explain by just looking at the PRG disassembly.</p>
<pre><code>02E6: 20 EA E8    JSR $E8EA
02E9: A4 D5       LDY $D5
02EB: A9 A0       LDA #$A0
02ED: 99 20 D0    STA $D020,Y
02F0: 91 D1       STA ($D1),Y
02F2: 9D B5 07    STA $07B5,X
02F5: E6 D6       INC $D6
02F7: 65 90       ADC $90
02F9: 85 90       STA $90
02FB: C6 D5       DEC $D5
02FD: 30 FE       BMI $02FD
02FF: 90 E7       BCC $02E8
0301: 4C E6 02    JMP $02E6</code></pre>
<p>Notice the last line (<code>JMP $02E6</code>). The JMP instruction starts at address <code>$0301</code> with the branch target stored in addresses <code>$0302-$0303</code>.</p>
<p>When this code is loaded into memory starting at address <code>$02E6</code>, a value of <code>$02E6</code> is written to addresses <code>$0302-$0303</code>. Well, location <code>$0302-$0303</code> has a special meaning: it contains a pointer to the ‚ÄúBASIC idle loop‚Äù (see <a href="http://sta.c64.org/cbm64mem.html">C64 memory map</a> for details). Loading the PRG overwrote this location with <code>$02E6</code> and so when the BASIC interpreter tries to jump to the idle loop after warm reset, it never enters the idle loop but instead ends up in the line renderer!</p>
<h3 id="other-basic-startup-related-tricks">Other BASIC startup related tricks</h3>
<p>Petri had discovered <a href="https://github.com/petrihakkinen/c64-lines/blob/master/main37.asm">another BASIC start trick</a> which allows injecting your own constants into the zeropage. In this method, you hand-craft your own tokenized BASIC start sequence and encode your constants into the BASIC program line number. The BASIC line number, ahem, your constants, will be stored in addresses <code>$39-$3A</code> upon entry. Very clever!</p>
<h2 id="trick-5-unconventional-control-flow">Trick 5: Unconventional control flow</h2>
<p>Here‚Äôs a somewhat simplified version of the x-loop that draws only a single line and then halts execution once the line is done:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        bcc no_scroll</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">; scroll screen up!</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e8ea</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="fu">no_scroll:</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        bpl xloop</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">; intentionally halt at the end</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    <span class="cf">jmp</span> inf</span></code></pre></div>
<p>This has a bug in it, though. When we‚Äôve drawn the last pixel of a line, we should NOT scroll the screen up anymore. Thus we need more branching to skip scrolling on the last pixel write:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">; skip scrolling if last pixel</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        bmi done</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        bcc no_scroll</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">; scroll screen up!</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        jsr <span class="op">$</span>e8ea</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="fu">no_scroll:</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">jmp</span> xloop</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="fu">done:</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">; intentionally halt at the end</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    <span class="cf">jmp</span> inf</span></code></pre></div>
<p>The control flow looks a lot like what a C compiler would output from a structured program. The code to skip the last scroll introduced a new <code>JMP abs</code> instruction that takes up 3 bytes. Conditional branches are only two bytes as they encode the branch target using a relative 8-bit immediate.</p>
<p>The ‚Äúskip last scroll‚Äù JMP can be avoided by moving the scroll up call to the top of the loop, and restructuring the control flow a bit. This is the pattern Philip had come up with:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">39</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>        sta x1</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">scroll:</span> jsr <span class="op">$</span>e8ea</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="fu">xloop:</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>a0</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        ldx x1</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">0400</span> <span class="op">+</span> <span class="dv">24</span><span class="op">*</span><span class="dv">40</span><span class="op">,</span> x</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> yf</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        sta yf</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> x1     <span class="co">; doesn&#39;t set carry!</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="fu">inf:</span>    bmi inf    <span class="co">; hang here if last pixel!</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        bcc xloop  <span class="co">; next pixel if no scroll</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        bcs scroll <span class="co">; scroll up and continue</span></span></code></pre></div>
<p>This completely eliminates one 3 byte JMP and converts another JMP to a 2 byte conditional branch, saving 4 bytes in total.</p>
<h2 id="trick-6-bitpacked-line-drawing">Trick 6: Bitpacked line drawing</h2>
<p>Some of the entries didn‚Äôt use a line slope counter but rather they had bit-packed the line pattern into an 8-bit constant. This packing comes out of a realisation that the pixel position along the line follows a repeating 8 pixel pattern:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mask <span class="op">=</span> <span class="bn">0xB6</span><span class="op">;</span> <span class="co">// 10110110</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">uint8_t</span><span class="op">*</span> dst <span class="op">=</span> screenRAM<span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">40</span><span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    dst<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="bn">0xA0</span><span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>mask <span class="op">&amp;</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>x<span class="op">&amp;</span><span class="dv">7</span><span class="op">)))</span> <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        dst <span class="op">+=</span> <span class="dv">40</span><span class="op">;</span> <span class="co">// go down a row</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This translates to pretty compact assembly. The slope counter variants tended to be even smaller, though.</p>
<h2 id="winner-entry">Winner entry</h2>
<p>This is the <a href="https://github.com/fsphil/tinyx/blob/master/x34/x34.s">winning 34 byte entry</a> from Philip. Most of the above really comes together nicely in his code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>ov <span class="op">=</span> <span class="op">$</span><span class="bn">22</span> <span class="co">; == $40, initial value for the overflow counter</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>ct <span class="op">=</span> <span class="op">$</span>D5 <span class="co">; == $27 / 39, number of passes. Decrementing, finished at -1</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>lp <span class="op">=</span> <span class="op">$</span>D1 <span class="co">; == $07C0, pointer to bottom line. Set by the kernal scroller</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">; Overwrite the return address of the kernal loader on the stack</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">; with a pointer to our own code</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        * = $01F8</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        .<span class="dt">word</span> scroll <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="fu">scroll:</span> jsr <span class="op">$</span>E8EA    <span class="co">; Kernal scroll up, also sets lp pointer to $07C0</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="fu">loop:</span>   ldy ct	     <span class="co">; Load the decrementing counter into Y (39 &gt; -1)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#$</span>A0     <span class="co">; Load the PETSCII block / black col / ov step value</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span>D020<span class="op">,</span> y <span class="co">; On the last two passes, sets the background black</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="fu">p1:</span>     sta <span class="op">$</span><span class="bn">07C0</span>    <span class="co">; Draw first block (left &gt; right line)</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">(</span>lp<span class="op">),</span> y  <span class="co">; Draw second block (right &gt; left line)</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span> p1 <span class="op">+</span> <span class="dv">1</span>   <span class="co">; Increment pointer for the left &gt; right line</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span> ov	     <span class="co">; Add step value $A0 to ov</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        sta ov</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span> ct	     <span class="co">; Decrement the Y counter</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        bmi <span class="op">*</span>	     <span class="co">; If it goes negative, we&#39;re finished</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        bcc loop     <span class="co">; Repeat. If ov didn&#39;t overflow, don&#39;t scroll</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        bcs scroll   <span class="co">; Repeat. If ov overflowed, scroll</span></span></code></pre></div>
<h2 id="why-stop-at-34-bytes-though">Why stop at 34 bytes, though?</h2>
<p>Once the competition was over, everyone shared code and notes, and a number of lively conversations took place on how to do even better. Several smaller variants were posted after the deadline:</p>
<ul>
<li><a href="https://gist.github.com/fsphil/05deaa06804b9b2054260b616cafed4b">Philip - 33 bytes</a></li>
<li><a href="https://gist.github.com/fsphil/01bda1a9dd58c219002ddd6e18b36c3f">Philip - 32 bytes</a></li>
<li><a href="https://github.com/petrihakkinen/c64-lines/blob/master/main31.asm">Petri - 31 bytes</a></li>
<li><a href="https://gist.github.com/fsphil/7655a394ec5f953c910e9d9369dced56">Philip - 29 bytes</a></li>
</ul>
<p>You should check them out ‚Äì there are some real gems to be found.</p>
<p>‚Ä¶</p>
<p>Thanks for reading. And most of all, thanks Mathlev, Phil, Geir, Petri, Jamie, Jan and David for your participation. (I hope I didn‚Äôt miss anyone ‚Äì it was really difficult to keep track of these in Twitter mentions!)</p>
<p>PS. Petri had named my compo ‚Äú<span class="citation" data-cites="nurpax">@nurpax</span>‚Äôs annual C64 size optimization compo‚Äù, so uhm, see you next year, I guess.</p>]]></summary>
</entry>
<entry>
    <title>C64jasm object literals</title>
    <link href="http://nurpax.github.com/posts/2019-07-27-c64jasm-object-literals.html" />
    <id>http://nurpax.github.com/posts/2019-07-27-c64jasm-object-literals.html</id>
    <published>2019-07-27T00:00:00Z</published>
    <updated>2019-07-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The latest <a href="https://nurpax.github.io/c64jasm/">c64jasm</a> v0.6.0 added support for JavaScript style object literals. This turned out to be surprisingly useful! Here we‚Äôll go over this feature and some tricks that it enables.</p>
<p>This post assumes you‚Äôre already familiar with the c64jasm assembler (see: <a href="https://nurpax.github.io/c64jasm/">c64jasm manual</a>).</p>
<h2 id="object-literals">Object literals</h2>
<p>An object in JavaScript and c64jasm is just a dict that maps keys to values. For example, in JavaScript:</p>
<pre><code>const options = {
    filename: &quot;main.asm&quot;,
    indent: 4
};</code></pre>
<p>The equivalent in c64jasm syntax would be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>!let options <span class="op">=</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filename:</span> &quot;main<span class="op">.</span>asm<span class="st">&quot;,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">indent:</span> 4</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="how-is-this-useful-in-assembler">How is this useful in assembler?</h2>
<p>Turns out object literals can be quite useful for a few things:</p>
<ul>
<li>Named parameters for macro calls</li>
<li>Keeping track of zeropage addresses</li>
<li>Implicitly parametrize macro expansion</li>
</ul>
<p><strong>Named parameters</strong>: C64jasm supports only positional arguments in macro calls. However, just like in JavaScript, objects are a great substitute for named parameters:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>!<span class="pp">macro</span> clear_screen_named<span class="op">(</span>args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>args<span class="op">.</span>clearByte</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    ldx <span class="op">#</span><span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    !let screen <span class="op">=</span> args<span class="op">.</span>screen</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    sta screen<span class="op">,</span> x</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    sta screen <span class="op">+</span> <span class="op">$</span><span class="bn">100</span><span class="op">,</span> x</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    sta screen <span class="op">+</span> <span class="op">$</span><span class="bn">200</span><span class="op">,</span> x</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    sta screen <span class="op">+</span> <span class="op">$</span><span class="bn">300</span><span class="op">,</span> x</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    inx</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    bne loop</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>+clear_screen_named<span class="op">({</span> screen<span class="op">:</span> <span class="op">$</span><span class="bn">0400</span><span class="op">,</span> clearByte<span class="op">:</span> <span class="op">$</span>a0 <span class="op">})</span></span></code></pre></div>
<p><strong>Zero-page addresses</strong>: If you‚Äôve written any decent amounts of 6502 assembly, you may have ran into problems keeping track of what‚Äôs in the zeropage. Perhaps you first started out by just keeping all the addresses in your head or code comments:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span><span class="bn">20</span>    <span class="co">; sprite index</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">2</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span><span class="bn">21</span>    <span class="co">; num sprites</span></span></code></pre></div>
<p>This is hard to read and easily breaks on modification. Instead, I tend to declare my zeropage allocation in variables:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>!let zp_sprite_idx <span class="op">=</span> <span class="op">$</span><span class="bn">20</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>!let zp_num_sprites <span class="op">=</span> <span class="op">$</span><span class="bn">21</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    sta zp_sprite_idx</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">2</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    sta zp_num_sprites</span></code></pre></div>
<p>You can express the above equivalently using an object literal:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>!let zp <span class="op">=</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sprite_idx:</span> $20,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">num_sprites:</span> $21</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    sta zp<span class="op">.</span>sprite_idx</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">2</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    sta zp<span class="op">.</span>num_sprites</span></code></pre></div>
<p>Turns out, the latter form combines well with macro expansion.</p>
<h2 id="macros-and-zeropage-temporaries">Macros and zeropage temporaries</h2>
<p>Consider the below <code>mul_imm</code> macro that multiplies a 16-bit value by 3. It needs 2 bytes of zeropage memory to hold a temporary value (<code>zp_tmp0</code>). It‚Äôs hardcoded to store the tempory in zeropage addresses <code>$20-$21</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>!<span class="pp">macro</span> add16<span class="op">(</span>res<span class="op">,</span> n1<span class="op">,</span> n2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">clc</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    lda n1</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">adc</span> n2</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    sta res<span class="op">+</span><span class="dv">0</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    lda n1<span class="op">+</span><span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">adc</span> n2<span class="op">+</span><span class="dv">1</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    sta res<span class="op">+</span><span class="dv">1</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>!<span class="pp">macro</span> mul_imm<span class="op">(</span>m<span class="op">,</span> imm<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    !let zp_tmp0 <span class="op">=</span> <span class="op">$</span><span class="bn">20</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    !<span class="pp">if</span> <span class="op">(</span>imm <span class="op">==</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        +add16<span class="op">(</span>zp_tmp0<span class="op">,</span> m<span class="op">,</span> m<span class="op">)</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        +add16<span class="op">(</span>m<span class="op">,</span> zp_tmp0<span class="op">,</span> m<span class="op">)</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="pp">else</span> <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        !error <span class="st">&quot;only imm=3 is supported&quot;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="fu">func:</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    +mul_imm<span class="op">(</span>num1<span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="fu">irq_func:</span> <span class="op">{</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    +mul_imm<span class="op">(</span>num1<span class="op">,</span> <span class="dv">3</span><span class="op">)</span>  <span class="co">; Ouch! Clobbers $20-21!</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="fu">num1:</span> !<span class="dt">word</span> <span class="dv">27</span></span></code></pre></div>
<p>What if the code calling this macro is also using zeropage <code>$20-$21</code>? The values in <code>$20-$21</code> will get clobbered by the macro. You also probably cannot use this macro in an IRQ as the IRQ might then clobber <code>$20-21</code> while your main code is running and using the same memory.</p>
<p>We could of course pass in a 3rd parameter <code>zp_tmp0</code> that‚Äôd specify the temp zeropage location. But this is ugly even with one 16-bit zeropage temp and only gets worse in macros needing many temporaries.</p>
<p>Let‚Äôs parametrize zeropage temp locations in <code>mul_imm</code> by adding a <code>zp</code> macro argument that holds the zeropage allocation:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>!<span class="pp">macro</span> mul_imm<span class="op">(</span>zp<span class="op">,</span> m<span class="op">,</span> imm<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    !<span class="pp">if</span> <span class="op">(</span>imm <span class="op">==</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        +add16<span class="op">(</span>zp<span class="op">.</span>tmp0<span class="op">,</span> m<span class="op">,</span> m<span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        +add16<span class="op">(</span>m<span class="op">,</span> zp<span class="op">.</span>tmp0<span class="op">,</span> m<span class="op">)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="fu">func:</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    !let temps <span class="op">=</span> <span class="op">{</span> tmp0<span class="op">:</span> <span class="op">$</span><span class="bn">20</span> <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    +mul_imm<span class="op">(</span>temps<span class="op">,</span> num1<span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="fu">irq_func:</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    !let temps <span class="op">=</span> <span class="op">{</span> tmp0<span class="op">:</span> <span class="op">$</span><span class="bn">40</span> <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    +mul_imm<span class="op">(</span>temps<span class="op">,</span> num1<span class="op">,</span> <span class="dv">3</span><span class="op">)</span>  <span class="co">; OK, no clobber</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Better but still noisy.</p>
<p><del>Now here‚Äôs the kicker: we can drop the <code>zp</code> argument from <code>mul_imm</code> declaration and rely on a convention that <code>zp</code> is passed implicitly in the enclosing scope at the macro call site.</del></p>
<p><del>In code:</del></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">; no &#39;zp&#39; arg here, rely on it being in scope</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>!<span class="pp">macro</span> mul_imm<span class="op">(</span>m<span class="op">,</span> imm<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    !<span class="pp">if</span> <span class="op">(</span>imm <span class="op">==</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        +add16<span class="op">(</span>zp<span class="op">.</span>tmp0<span class="op">,</span> m<span class="op">,</span> m<span class="op">)</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        +add16<span class="op">(</span>m<span class="op">,</span> zp<span class="op">.</span>tmp0<span class="op">,</span> m<span class="op">)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">; default zeropage temps</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>!let zp <span class="op">=</span> <span class="op">{</span> tmp0<span class="op">:</span> <span class="op">$</span><span class="bn">20</span> <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="fu">func:</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">; use default zp tmp0=$20</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    +mul_imm<span class="op">(</span>num1<span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="fu">irq_func:</span> <span class="op">{</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">; override zp with tmp0=$40 within irq_func</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    !let zp <span class="op">=</span> <span class="op">{</span> tmp0<span class="op">:</span> <span class="op">$</span><span class="bn">40</span> <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    +mul_imm<span class="op">(</span>num1<span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Update 2019-08-09</strong>: Implicit parameters by the sort of ‚Äúdynamic scoping‚Äù shown here does not work as of c64jasm 0.7.0. When a macro is expanded, any symbols in the macro will use bindings from where the macro was declared, not where it‚Äôs expanded. Use global variables instead. See <a href="https://gist.github.com/nurpax/5aeaba58e359c6d040a9e0f87fa68ab9">this gist</a> for an example on how to do this cleanly.</p>
<h2 id="wrap-up">Wrap-up</h2>
<p>This post walked through a couple of tricks that became possible in the latest c64jasm v0.6.0 release. If you‚Äôre feeling adventurous, read more <a href="https://nurpax.github.io/c64jasm/">here</a>. Or <a href="https://nurpax.github.io/c64jasm-browser/">try it in your browser</a>!</p>]]></summary>
</entry>
<entry>
    <title>Loading sprites, PETSCII and SID with C64jasm</title>
    <link href="http://nurpax.github.com/posts/2019-06-06-c64jasm-content-example.html" />
    <id>http://nurpax.github.com/posts/2019-06-06-c64jasm-content-example.html</id>
    <published>2019-06-06T00:00:00Z</published>
    <updated>2019-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post is a walkthrough of a small assembly example project for <a href="https://nurpax.github.io/c64jasm/">c64jasm</a>. The example project was written to illustrate the use of following types of assets in an assembly program:</p>
<ul>
<li>PETSCII (using <a href="https://nurpax.github.io/petmate/">Petmate</a> .json exported files)</li>
<li>Sprites (authored in <a href="http://spritemate.com/">Spritemate</a>, saved as .spd v2.0)</li>
<li>SID music files</li>
</ul>
<p>Project source code can be found in the c64jasm git repo under the <a href="https://github.com/nurpax/c64jasm/tree/master/examples/content-pipe">examples/content-pipe</a> folder.</p>
<p>This post is focused on consuming above file formats in c64jasm code and is not intended to be a tutorial on 6502 machine language.</p>
<p>To compile the app, ensure you have c64jasm installed (see <a href="https://nurpax.github.io/c64jasm/">c64jasm</a> for instructions) and do:</p>
<pre><code>git clone https://github.com/nurpax/c64jasm
cd c64jasm/examples/content-pipe
c64jasm --out demo.prg src/main.asm     # assemble
x64 demo.prg                            # run it in vice</code></pre>
<p>The resulting program should look something like this on a C64:</p>
<p><img width="100%" class="img-pixelated" src="/images/c64/c64jasm/c64jasm-starter-example.png" /></p>
<h1 id="file-overview">File overview</h1>
<pre><code>.vscode/            VSCode project
  launch.json       Running/debugging the output .prg on VICE
  tasks.json        Compiling

src/                All source files (.asm, .js) and assets
  main.asm          Entry point &amp; most code
  macros.asm        Re-usable macro definitions
  pet_rle.asm       PETSCII RLE decompression routine

  assets/           .spd, .json, .sid files

  plugins/          c64jasm extensions written in JavaScript
    math.js         Generic math stuff like sine LUT generation
    petscii.js      Petmate .json reader + RLE packer
    spd.js          SpritePad 2.0 .spd loader
    sid.js          SID loader</code></pre>
<h1 id="loading-sid-tunes-with-c64jasm">Loading SID tunes with c64jasm</h1>
<p><em>Note: I‚Äôve written a longer blog post about c64jasm‚Äôs design goals. You can read it <a href="https://nurpax.github.io/posts/2018-11-08-c64jasm.html">here</a>.</em></p>
<p>Perhaps you noticed some JavaScript .js files in the file listing above? These are JavaScript modules that are callable by assembler pseudo directives.</p>
<p>Rather than using makefiles and a lot of assembler built-in functionality (say SID loading, RNG, math functions), you express your content transformations in JavaScript and glue everything together using c64jasm‚Äôs pseudo directives.</p>
<p>Let‚Äôs take a look at a concrete example of loading and using a SID tune. In order to use a SID tune in an assembly program, you need the following bits:</p>
<ul>
<li>Extract some header information from a .sid file to work out its expected loading address</li>
<li>Extract the actual SID player and emit it in your output PRG at the right address</li>
<li>Map the tune <code>init</code> and <code>play</code> functions to some assembly symbols that you can <code>jsr</code> into</li>
</ul>
<p>To load and extract the header bits from a SID tune, I use the following code.</p>
<p><a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/plugins/sid.js">examples/content-pipe/src/plugins/sid.js</a>:</p>
<pre><code>function readWord(buf, offs) {
    return buf.readUInt8(offs) + (buf.readUInt8(offs+1) &lt;&lt; 8);
}

function readWordBE(buf, offs) {
    return (buf.readUInt8(offs)&lt;&lt;8) + buf.readUInt8(offs+1);
}

module.exports = ({readFileSync, resolveRelative}, filename) =&gt; {
    const buf = readFileSync(resolveRelative(filename));
    const version = readWordBE(buf, 4);
    const dataOffset = readWordBE(buf, 6);
    const startAddress = readWord(buf, dataOffset);
    const init = readWordBE(buf, 0x0a);
    const play = readWordBE(buf, 0x0c);
    const res = {
        startAddress,
        data: [...buf.slice(dataOffset+2)],
        init: startAddress,
        play: startAddress + 3
    }
    return res;
}</code></pre>
<p>The code reads a SID file, extracts its headers and returns the relevant bits as a JavaScript object. Here‚Äôs what a typical return value might look like for the above function:</p>
<pre><code>{ startAddress: 4096,
  data: [ 76, 169, 16, 76, 177, 16, ... 2239 more items ],
  init: 4096,
  play: 4099
}</code></pre>
<p>Let‚Äôs break it down:</p>
<ul>
<li><code>startAddress</code> is the memory location where the SID needs to be placed (usually <code>$1000</code>)</li>
<li><code>data</code> is an array containing the tune data and the player</li>
<li><code>init</code> is the tune init function address (call this with <code>jsr</code>)</li>
<li><code>play</code> is what you <code>jsr</code> every frame to playback music</li>
</ul>
<p>To use this in an assembly program, here‚Äôs what you need to do (this goes into an .asm file, see <a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/main.asm">examples/content-pipe/src/main.asm</a>):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Load the JavaScript sid loader module and bind it to `sid`</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">; (&quot;plugins/sid&quot; refers to ./src/plugins/sid.js)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>!use <span class="st">&quot;plugins/sid&quot;</span> as sid</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">; Call the sid loader, bind the return JavaScript object to</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">; the `music` variable.  The object fields such as `init`,</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">; `startAddress`, `play` can be accessed by the dot-operator</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">; like `music.init`.</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>!let music <span class="op">=</span> sid<span class="op">(</span><span class="st">&quot;assets/Load_Line.sid&quot;</span><span class="op">)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">;....</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="fu">start_demo:</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Initialize sub-tune 0</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    jsr music<span class="op">.</span>init</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">; if SID is at $1000, `music.init` will expand to $1000</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="fu">per_frame:</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    jsr music<span class="op">.</span>play    <span class="co">; e.g., JSR $1003</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co">; Emit the SID player and tune data into the output binary</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>* = music<span class="op">.</span>startAddress</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="fu">sid_data:</span> !<span class="dt">byte</span> music<span class="op">.</span>data</span></code></pre></div>
<p>The last line with the <code>!byte</code> directive may not be immediately obvious if you‚Äôre used to <code>!byte &lt;expr&gt;</code> always emitting just a single byte. The <code>!byte</code> directive in c64jasm supports array arguments ‚Äì <code>!byte some_array_value</code> will loop over the array emitting a byte for each element. For example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Let&#39;s assume data_array is an array of [0,1,2,3]</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">; The below two lines are equivalent</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>!<span class="dt">byte</span> data_array</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>!<span class="dt">byte</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">; You can also write it as an explicit for-loop over the</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">; values in `data_array`:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>!for b in data_array <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    !<span class="dt">byte</span> b</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="importing-petscii-graphics">Importing PETSCII graphics</h1>
<p>This sections explains how to pull PETSCII graphics authored in <a href="https://nurpax.github.io/petmate/">Petmate</a> into your program. Petmate supports a number of different export formats, but we will be using Petmate‚Äôs JSON export format. It‚Äôs accessible from Petmate‚Äôs <em>File / Export As / JSON (.json)</em> menu. This format is intended to be consumed by scripts written in say Python or JavaScript.</p>
<p>A Petmate exported JSON file would look something like this:</p>
<pre><code>{
    &quot;version&quot;: 1,
    &quot;framebufs&quot;: [
        {
            &quot;width&quot;: 40,
            &quot;height&quot;: 25,
            &quot;backgroundColor&quot;: 0,
            &quot;borderColor&quot;: 0,
            &quot;charset&quot;: &quot;upper&quot;,
            &quot;name&quot;: &quot;screen_003&quot;,
            &quot;screencodes&quot;: [ /* width*height bytes */ ],
            &quot;colors&quot;: [ /* width*height bytes */ ]
        }
    ]
}</code></pre>
<p>Suppose you wanted to include the screencodes for a PETSCII JSON file called <code>foo.json</code>, here‚Äôs how you‚Äôd express that in assembly code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Load a JSON file using the c64jasm&#39;s built-in `loadJson` function</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>!let petscii <span class="op">=</span> loadJson<span class="op">(</span><span class="st">&quot;foo.json&quot;</span><span class="op">)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">; Emit a screencode array into the compiled program</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">petscii_screencodes:</span> !<span class="dt">byte</span> petscii<span class="op">.</span>framebufs<span class="op">[</span><span class="dv">0</span><span class="op">].</span>screencodes</span></code></pre></div>
<p>But that‚Äôs.. too easy. üòâ</p>
<p>The example project does something more complicated to illustrate the expressiveness of c64jasm JavaScript extensions.</p>
<p>Rather than simply loading a JSON file and returning it, the code in <a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/plugins/petscii.js">examples/content-pipe/src/plugins/petscii.js</a> loads the input JSON file and RLE compresses it to save some RAM.</p>
<p>Here‚Äôs how this extension is used in assembly code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>!use <span class="st">&quot;plugins/petscii&quot;</span> as petscii</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>!let petscii_background <span class="op">=</span> petscii<span class="op">.</span>rlePetsciiJson<span class="op">(</span><span class="st">&quot;assets/pipes-pet.json&quot;</span><span class="op">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">; Emit the RLE compressed PETSCII bytes (both screencodes and color)</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">background_petscii_rle:</span> !<span class="dt">byte</span> petscii_background<span class="op">.</span>interleaved</span></code></pre></div>
<p>Source file <a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/pet_rle.asm">examples/content-pipe/src/pet_rle.asm</a> contains an implementation of a RLE decoder that can be used to display a PETSCII screen on the C64 screen. All the symbols in this file are wrapped in a scope named <code>pet_rle</code> using the <code>!filescope</code> directive, so to use the <code>decode</code> function from another <code>.asm</code> file, you need to use a scope qualifier <code>pet_rle::decode</code> to refer to the decoder function.</p>
<p>Let‚Äôs piece all this together:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>!use <span class="st">&quot;plugins/petscii&quot;</span> as petscii</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>!let petscii_background <span class="op">=</span> petscii<span class="op">.</span>rlePetsciiJson<span class="op">(</span><span class="st">&quot;assets/pipes-pet.json&quot;</span><span class="op">)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>!<span class="bu">include</span> <span class="st">&quot;pet_rle.asm&quot;</span>  <span class="co">; include RLE decoder (e.g., pet_rle::decode)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="fu">show_petscii:</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Decompress a PETSCII image on the display</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d020</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d021</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#&lt;</span>background_petscii_rle</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    ldx <span class="op">#&gt;</span>background_petscii_rle</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    jsr pet_rle<span class="op">::</span>decode</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    rts</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="fu">background_petscii_rle:</span> !<span class="dt">byte</span> petscii_background<span class="op">.</span>interleaved</span></code></pre></div>
<p>What‚Äôs great about this approach is you don‚Äôt need a separate build step to process your assets into compressed RLE with, say, Python and makefiles. Instead, loading and compressing PETSCII happens as part of your normal assembly compile step.</p>
<h1 id="using-spritemate-authored-sprites">Using Spritemate authored sprites</h1>
<p>Next up, sprite graphics!</p>
<p>I used <a href="http://spritemate.com/">Spritemate</a> to draw sprites. Spritemate is a free, web-based C64 sprite editor written by <a href="https://twitter.com/awsm9000">@awsm9000</a>. Spritemate supports saving SpritePad .spd v2.0 files which is what we‚Äôll use here.</p>
<p>As in the other sections, we need a JavaScript module to load and parse an .spd file, and some assembly code to do something with it.</p>
<p>Let‚Äôs take a look at the JavaScript .spd loader first.</p>
<p><a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/plugins/spd.js">examples/content-pipe/src/plugins/spd.js</a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// File format detailed in https://csdb.dk/forums/?roomid=7&amp;topicid=125812</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>module<span class="op">.</span><span class="at">exports</span> <span class="op">=</span> ({readFileSync<span class="op">,</span> resolveRelative}<span class="op">,</span> filename) <span class="kw">=&gt;</span> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> buf <span class="op">=</span> <span class="fu">readFileSync</span>(<span class="fu">resolveRelative</span>(filename))<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> numSprites <span class="op">=</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(<span class="dv">4</span>)<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> data <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numSprites<span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> offs <span class="op">=</span> i<span class="op">*</span><span class="dv">64</span><span class="op">+</span><span class="dv">9</span><span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> bytes <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">64</span><span class="op">;</span> j<span class="op">++</span>) {</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            bytes<span class="op">.</span><span class="fu">push</span>(buf<span class="op">.</span><span class="fu">readUInt8</span>(offs <span class="op">+</span> j))<span class="op">;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        data<span class="op">.</span><span class="fu">push</span>(bytes)<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        numSprites<span class="op">,</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">multicol1</span><span class="op">:</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(<span class="dv">7</span>)<span class="op">,</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">multicol2</span><span class="op">:</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(<span class="dv">8</span>)<span class="op">,</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        data</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This loads an .spd file, looks at the header information and returns an object describing file contents. The important fields are:</p>
<ul>
<li><code>numSprites</code>: how many sprites does the file contain</li>
<li><code>multicol1</code>, <code>multicol2</code>: multicolor colors used for the sprites</li>
<li><code>data</code>: an array of shape <code>[numSprites][64]</code> containing actual pixel data</li>
</ul>
<p>The importer is hardcoded for multicolor sprites, but it wouldn‚Äôt be too hard to extend it to support single color too.</p>
<p>Here‚Äôs how to use it in assembly code:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>!use <span class="st">&quot;plugins/spd&quot;</span> as spd   <span class="co">; .spd loader</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>!let pacman_spd <span class="op">=</span> spd<span class="op">(</span><span class="st">&quot;assets/pacman.spd&quot;</span><span class="op">)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">show_sprites:</span> <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">; point all 8 sprites to pacman</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>sprite_data<span class="op">/</span><span class="dv">64</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>!for i in range<span class="op">(</span><span class="dv">8</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span><span class="bn">07f8</span> <span class="op">+</span> i</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">; set multicolor registers</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>pacman_spd<span class="op">.</span>multicol1</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d025</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>pacman_spd<span class="op">.</span>multicol2</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d026</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">; ...</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    rts</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>!<span class="bu">align</span> <span class="dv">64</span> <span class="co">; sprites must be 64-byte aligned</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="fu">sprite_data:</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>!<span class="dt">byte</span> pacman_spd<span class="op">.</span>data<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span></code></pre></div>
<h1 id="wrap-up">Wrap up</h1>
<p>We looked at importing various common graphics and sound formats into a C64 assembly program.</p>
<p>You might want to <a href="https://nurpax.github.io/c64jasm/">read more about c64jasm</a> if you‚Äôre like me and enjoy writing code in an environment that comes with:</p>
<ul>
<li>Declarative build process (no manual tracking down of build dependencies, no makefiles)</li>
<li>Good VSCode integration (run &amp; debug from VSCode, VSCode syntax highlighting, error reporting within the editor)</li>
<li>Fast ‚ÄúNode style‚Äù watched builds: have the compiler watch your source dir and automatically trigger a rebuild as soon as any of the input source files changed</li>
<li>Just generally feeling adventurous and wanting to do things in a non-standard way</li>
</ul>
<p>BTW, if you missed my recent C64 demo, you can <a href="https://csdb.dk/release/?id=178389">download it</a> / <a href="https://www.youtube.com/watch?v=UPlS2L9lF4k">watch it here</a>. It‚Äôs also developed with c64jasm.</p>]]></summary>
</entry>
<entry>
    <title>C64jasm - a new take on C64 macro assembling</title>
    <link href="http://nurpax.github.com/posts/2018-11-08-c64jasm.html" />
    <id>http://nurpax.github.com/posts/2018-11-08-c64jasm.html</id>
    <published>2018-11-08T00:00:00Z</published>
    <updated>2018-11-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>For the past couple of months I‚Äôve worked on the C64 <a href="https://csdb.dk/release/?id=171134">VISIO 2018 invitation intro</a> (YouTube capture at the bottom of this post). I upped the difficulty level a bit by first designing and implementing a new 6502 macro assembler called <a href="https://github.com/nurpax/c64jasm">c64jasm</a>, and then using that to develop my demo. While I haven‚Äôt had the time to polish the assembler to, say, KickAssembler level, my tool turned out to be a real joy to work with. This post highlights some of its features that I believe make it somewhat unique in its small niche.</p>
<p>These were my initial design choices for c64jasm:</p>
<ul>
<li>Written in TypeScript &amp; running on Node. Easy multi-platform environment with easy to install dependencies.</li>
<li>Ability to extend the assembler‚Äôs functionality by calling into user-defined JavaScript modules directly from the .asm source.</li>
<li>A sufficiently powerful pseudo language (macros, conditionals, for-loops, etc) but build on the JavaScript extension mechanism for more complex pseudo ops like LUT creation and file format parsing.</li>
<li>Node-style ‚Äúwatch‚Äù support: automatically recompile if any source files change. Design it for efficiency.</li>
<li>VSCode integration (for on-the-fly compilation and error reporting within the IDE, launch output binary in VICE.)</li>
</ul>
<p>The choice of TypeScript was very deliberate. I‚Äôve been meaning to learn the language for quite some time, and developing a macro assembler in it was a good way to learn &amp; evaluate TypeScript. TypeScript turned out to be a great language: supports functional programming style well (and so well-suited for developing compilers) and has a simple but powerful static typing system.</p>
<p>The assembler extension mechanism is the main feature that differentiates c64jasm from traditional 6502 macro assemblers and I‚Äôll spend the rest of this blog talking about this mechanism.</p>
<p>This blog post assumes that you‚Äôre at least somewhat familiar with macro assemblers and that you know a bit of JavaScript.</p>
<h2 id="why-do-i-need-to-extend-my-assembler">Why do I need to extend my assembler?</h2>
<p>So why does one need to extend the assembler in the first place? I have my assembly, macros and other pseudo directives, isn‚Äôt this enough? Well, you need all of these too. But some things like loading graphics files, generating lookup tables, etc. can be better expressed in a real programming language. Quite commonly a demo project is built using a build script that processes LUTs, graphics, and other assets into hex listings to be included in the main assembly source.</p>
<h2 id="extending-functionality">Extending functionality</h2>
<p>Traditionally, extending the functionality of an application or a tool means that you‚Äôd first need to learn the app‚Äôs extension API, figure out how to build your extension (say .DLLs or a Java .jar file), install it (and maybe debug your PATH or CLASSPATH when it fails to load), and once all done, the feature becomes available in your tool and you use it to develop your content.</p>
<p>The approach I took in c64jasm is that assembler extensions are just a bunch of source files in your project‚Äôs source directory. Extensions shouldn‚Äôt require a separate build or installation step and the overhead of creating a new one for any specific purpose should be minimal. Ideally the extensions should be runnable stand-alone without the assembler and that you should be able to debug and test them using standard debugging tools.</p>
<p>Before we get deeper into c64jasm assembler plugins, let‚Äôs review some of the c64jasm pseudo directives.</p>
<h2 id="c64jasm-pseudo-ops">C64jasm pseudo ops</h2>
<p>If you‚Äôve used something like KickAssembler, ACME or 64tass, these should look pretty familiar.</p>
<p>Declaring pseudo variables: You can declare pseudo variables using <code>!let</code>. This is basically the same as KickAssembler‚Äôs <code>.const</code>/<code>.var</code> (many other assemblers commonly have this as <code>EQU</code>.)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">; declaring variables</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>!let after_bounce_frames <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>!let sprite_writer_path_tablen <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">; assigning a new value to a previously declared variable</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>after_bounce_frames <span class="op">=</span> <span class="dv">33</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">; using the variables in immediates</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    sec</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    sbc <span class="op">#</span>sprite_writer_path_tablen</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">cmp</span> <span class="op">#</span>after_bounce_frames</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    bcs do_wrap</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">jmp</span> no_wrap</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu">do_wrap:</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">jmp</span> wrap</span></code></pre></div>
<p>Macros:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">some_mem_loc:</span> !<span class="dt">byte</span> <span class="dv">0</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">; declare a macro to write an immediate value to memory</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>!<span class="pp">macro</span> mov8imm<span class="op">(</span>d<span class="op">,</span> imm<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>imm</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    sta d<span class="op">+</span><span class="dv">0</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">; expand the macro</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>+mov8imm<span class="op">(</span>some_mem_loc<span class="op">,</span> <span class="op">#$</span><span class="bn">80</span><span class="op">)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">; this will emit the following code:</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">;    lda #$80</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">;    sta some_mem_loc</span></span></code></pre></div>
<p>Symbols declared within a macro are local to that macro. You can also declare macros within macros.</p>
<p>If/elif/else:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>!let double_y <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>!<span class="pp">if</span> <span class="op">(</span>double_y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    ldy <span class="op">#</span>yy<span class="op">*</span><span class="dv">6</span><span class="op">+</span><span class="dv">1</span>         <span class="co">; code from this path</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">(</span>zpdst_even<span class="op">),</span>y  <span class="co">; will be emitted</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">(</span>zpdst_odd<span class="op">),</span>y</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    txa</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    dey</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">(</span>zpdst_even<span class="op">),</span>y</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">(</span>zpdst_odd<span class="op">),</span>y</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="pp">else</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    ldy <span class="op">#</span>yy<span class="op">*</span><span class="dv">3</span><span class="op">+</span><span class="dv">1</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">(</span>zpdst_even<span class="op">),</span>y</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    txa</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    dey</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">(</span>zpdst_even<span class="op">),</span>y</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For-loops:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">; emit 8 nops</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>!for i in range<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">8</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">nop</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As opposed to a C-style ‚Äúdeclare loop variable, check condition, increment‚Äù for loops, c64jasm‚Äôs <code>for</code> is similar to Python‚Äôs for-statement. You use a function called <code>range()</code> that returns a list of integers and the for-loop just iterates over the elements of this list, assigning the current list element to the bound loop variable <code>i</code>. E.g., these two are conceptually the same:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">; emit four NOPs</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>!for i in range<span class="op">(</span><span class="dv">4</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">nop</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>!for i in <span class="op">[</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">]</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">nop</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The ‚Äúemit byte‚Äù pseudo <code>!byte</code> supports emitting a list of bytes when passed an integer list. The following two lines are equivalent:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>!<span class="dt">byte</span> range<span class="op">(</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>!<span class="dt">byte</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span></span></code></pre></div>
<h2 id="c64jasm-extensions">C64jasm extensions</h2>
<p>So with the basic c64jasm pseudo ops explained, let‚Äôs continue to c64jasm extensions. A c64jasm extension is just a JavaScript .js module. To use such a .js module in your assembly source, you bind it to a name with <code>!use "path/to/plugin.js"</code>. This name becomes a function that you can call in your assembly source file.</p>
<p>Let‚Äôs illustrate this with some code to generate a sine lookup table. First the plugin code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a># sintab<span class="op">.</span><span class="at">js</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>module<span class="op">.</span><span class="at">exports</span> <span class="op">=</span> ({}<span class="op">,</span> len<span class="op">,</span> scale) <span class="kw">=&gt;</span> {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> res <span class="op">=</span> <span class="bu">Array</span>(len)<span class="op">.</span><span class="fu">fill</span>(<span class="dv">0</span>)<span class="op">.</span><span class="fu">map</span>((v<span class="op">,</span>i) <span class="kw">=&gt;</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">sin</span>(i<span class="op">/</span>len <span class="op">*</span> <span class="bu">Math</span><span class="op">.</span><span class="cn">PI</span> <span class="op">*</span> <span class="fl">2.0</span>) <span class="op">*</span> scale)<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Here‚Äôs how you‚Äôd use the above in your .asm source file:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Bind sintab.js default export to a pseudo function &#39;mkSintab&#39;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>!use <span class="st">&quot;./sintab&quot;</span> as mkSintab</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>!let sin1scale <span class="op">=</span> <span class="dv">26</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">sintab1:</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>!for s in mkSintab<span class="op">(</span><span class="dv">256</span><span class="op">,</span> sin1scale<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    !<span class="dt">byte</span> s</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As <code>!byte</code> and <code>!word</code> accept a list as an argument, the above can be written simply as:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sintab1:</span> !<span class="dt">byte</span> mkSintab<span class="op">(</span><span class="dv">256</span><span class="op">,</span> sin1scale<span class="op">)</span></span></code></pre></div>
<p>The nice thing about this approach is that I can keep the assembler implementation simple. The assembler doesn‚Äôt need a large standard library of math and other utility functions as this functionality can be easily expressed as tiny JavaScript modules.</p>
<p>Sure, generating a sine table would be pretty easy without an extension too (and this is totally supported by c64jasm):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sintab1:</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>   !for s in range<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">256</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>       !<span class="dt">byte</span> sin<span class="op">(</span>s<span class="op">/</span><span class="dv">256</span><span class="op">*</span><span class="dv">2</span><span class="op">*</span>PI<span class="op">)*</span>scl</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code></pre></div>
<p>Where I find the JavaScript extension mechanism really shines is importing assets (sprites from .spd, .sid, etc.). Here‚Äôs how I compile SpritePad .spd files into my demo binary:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a># spd<span class="op">.</span><span class="at">js</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>module<span class="op">.</span><span class="at">exports</span> <span class="op">=</span> ({readFileSync<span class="op">,</span> resolveRelative}<span class="op">,</span> filename) <span class="kw">=&gt;</span> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> buf <span class="op">=</span> <span class="fu">readFileSync</span>(<span class="fu">resolveRelative</span>(filename))<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> numSprites <span class="op">=</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(<span class="dv">4</span>)<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> data <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numSprites<span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> offs <span class="op">=</span> i<span class="op">*</span><span class="dv">64</span><span class="op">+</span><span class="dv">9</span><span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> bytes <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">64</span><span class="op">;</span> j<span class="op">++</span>) {</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            bytes<span class="op">.</span><span class="fu">push</span>(buf<span class="op">.</span><span class="fu">readUInt8</span>(offs <span class="op">+</span> j))<span class="op">;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        data<span class="op">.</span><span class="fu">push</span>(bytes)<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        numSprites<span class="op">,</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">enableMask</span><span class="op">:</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>numSprites)<span class="op">-</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bg</span><span class="op">:</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(<span class="dv">6</span>)<span class="op">,</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">multicol1</span><span class="op">:</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(<span class="dv">7</span>)<span class="op">,</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">multicol2</span><span class="op">:</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(<span class="dv">8</span>)<span class="op">,</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        data</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using the above in an .asm file:</p>
<pre><code>!use &quot;./spd&quot; as spd

; Load &#39;hirmu.spd&#39; and store the returned JavaScript object in a
; variable called &#39;hirmu_sprite&#39;
!let hirmu_sprite = spd(&quot;../sprites/hirmu.spd&quot;)</code></pre>
<p>At this point, no code or bytes were yet emittted. The .spd file contents are now in a pseudo variable called <code>hirmu_sprite</code>. This is just a JavaScript object with fields like <code>numSprites</code>, <code>enableMask</code>, <code>data</code> that can be accessed from .asm with the dot operator (e.g., <code>sprite_data.numSprites</code>.)</p>
<p>With this, I can expand the sprite data into the output binary. Or I can use to emit code to setup sprite registers (enable bits, individual and multi color values, etc).</p>
<p>Emitting actual sprite data for all the sprites contained within the .spd file:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">hirmu_sprite_data:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">; loop over all the sprites in hirmu_sprite.data</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    !for sdata in hirmu_sprite<span class="op">.</span>data <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        !<span class="dt">byte</span> sdata  <span class="co">; expand 64 bytes of sprite data (one sprite)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">; or equivalently:</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">; !for sidx in range(hirmu_sprite.numSprites) {</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">;    !byte hirmu_sprite.data[sidx]  ; expand 64 bytes of sprite data (one sprite)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">; }</span></span></code></pre></div>
<p>I also define a macro that expands machine code to write sprite registers based on the .spd file contents:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>!<span class="pp">macro</span> set_sprite<span class="op">(</span>s<span class="op">,</span> <span class="dt">ptr</span><span class="op">,</span> xScale<span class="op">,</span> yScale<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    !<span class="pp">if</span> <span class="op">(</span>xScale <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span>s<span class="op">.</span>enableMask</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="pp">else</span> <span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d01d  <span class="co">; XSCALE register</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    !<span class="pp">if</span> <span class="op">(</span>yScale <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span>s<span class="op">.</span>enableMask</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="pp">else</span> <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d017  <span class="co">; YSCALE register</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">; set sprite pointers and individual sprite colors for</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">; all sprites</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    !for sprite_idx in range<span class="op">(</span><span class="dv">0</span><span class="op">,</span> s<span class="op">.</span>numSprites<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">; load the individual color from sprite data</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span>s<span class="op">.</span>data<span class="op">[</span>sprite_idx<span class="op">][</span><span class="dv">63</span><span class="op">]</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">; indiv sprite color</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span>d027 <span class="op">+</span> sprite_idx</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        lda <span class="op">#</span>ptr<span class="op">/</span><span class="dv">64</span> <span class="op">+</span> sprite_idx</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>        sta <span class="op">$</span><span class="bn">7f8</span> <span class="op">+</span> sprite_idx</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">; enable multicolor for the same sprites, set multicolor values</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>s<span class="op">.</span>multicol1</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d025</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>s<span class="op">.</span>multicol2</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d026</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">; enable all the sprites that were loaded from the .spd</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span>s<span class="op">.</span>enableMask</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d01c       <span class="co">; multicolor enable</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    sta <span class="op">$</span>d015       <span class="co">; sprite enable</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="fu">set_hirmu_sprite:</span> <span class="op">{</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>    +set_sprite<span class="op">(</span>hirmu_sprite<span class="op">,</span> hirmu_sprite_data<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>    rts</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I use the same pattern for all the different asset types used in my demo. Here‚Äôs how I pull the SID tune into the binary:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a># sid<span class="op">.</span><span class="at">js</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">readWord</span>(buf<span class="op">,</span> offs) {</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(offs) <span class="op">+</span> (buf<span class="op">.</span><span class="fu">readUInt8</span>(offs<span class="op">+</span><span class="dv">1</span>) <span class="op">&lt;&lt;</span> <span class="dv">8</span>)<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Read a big-endian word</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">readWordBE</span>(buf<span class="op">,</span> offs) {</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (buf<span class="op">.</span><span class="fu">readUInt8</span>(offs)<span class="op">&lt;&lt;</span><span class="dv">8</span>) <span class="op">+</span> buf<span class="op">.</span><span class="fu">readUInt8</span>(offs<span class="op">+</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>module<span class="op">.</span><span class="at">exports</span> <span class="op">=</span> ({readFileSync<span class="op">,</span> resolveRelative}<span class="op">,</span> filename) <span class="kw">=&gt;</span> {</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> buf <span class="op">=</span> <span class="fu">readFileSync</span>(<span class="fu">resolveRelative</span>(filename))<span class="op">;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> version <span class="op">=</span> <span class="fu">readWordBE</span>(buf<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> dataOffset <span class="op">=</span> <span class="fu">readWordBE</span>(buf<span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> startAddress <span class="op">=</span> <span class="fu">readWord</span>(buf<span class="op">,</span> dataOffset)<span class="op">;</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> init <span class="op">=</span> <span class="fu">readWordBE</span>(buf<span class="op">,</span> <span class="bn">0x0a</span>)<span class="op">;</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> play <span class="op">=</span> <span class="fu">readWordBE</span>(buf<span class="op">,</span> <span class="bn">0x0c</span>)<span class="op">;</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> numSongs <span class="op">=</span> <span class="fu">readWord</span>(buf<span class="op">,</span> <span class="bn">0x0e</span>)<span class="op">;</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> res <span class="op">=</span> {</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        startAddress<span class="op">,</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">data</span><span class="op">:</span> [<span class="op">...</span>buf<span class="op">.</span><span class="fu">slice</span>(dataOffset<span class="op">+</span><span class="dv">2</span>)]<span class="op">,</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">init</span><span class="op">:</span> startAddress<span class="op">,</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">play</span><span class="op">:</span> startAddress <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Using the loaded SID tune from the .asm source:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>!use <span class="st">&quot;./sid&quot;</span> as sid</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>!let music <span class="op">=</span> sid<span class="op">(</span><span class="st">&quot;sid/tune.sid&quot;</span><span class="op">)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">demo_start:</span> <span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    lda <span class="op">#</span><span class="dv">0</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    jsr music<span class="op">.</span>init</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    jsr music<span class="op">.</span>play      <span class="co">; usually called from an IRQ</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>* = music<span class="op">.</span>startAddress  <span class="co">; usually music.startAddress == $1000</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="fu">music:</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>!<span class="dt">byte</span> music<span class="op">.</span>data</span></code></pre></div>
<p>All of these content plugins are just normal .js files that can be run from the command line with <code>node</code>. This enables you to use standard tools like VSCode to debug them as stand-alone JavaScript modules. I prefer this code to be part of the project source tree rather than buried somewhere within c64jasm‚Äôs standard libraries.</p>
<h2 id="epilogue">Epilogue</h2>
<p>OK, that‚Äôs about it for now on c64jasm plugins. I will probably write another blog later about using c64jasm in VSCode (with quick re-compile-on-save and launch .prg in VICE.) I <a href="https://twitter.com/nurpax/status/1049757222547451906">tweeted</a> about it a while ago, you can check out the video if you‚Äôre curious about this.</p>
<p>Oh by the way, <a href="https://github.com/nurpax/c64jasm">c64jasm</a> is available on GitHub and is already quite usable. However, it‚Äôs still very much work-in-progress. If you‚Äôre into this type of stuff and feeling adventurous, feel free to give it a try. Otherwise, stick with the more established C64 assemblers. :)</p>
<h2 id="visio-2018-invitation-demo-capture">VISIO 2018 invitation demo capture</h2>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/Jr5DqTcFpf4?rel=0&amp;controls=1&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>]]></summary>
</entry>
<entry>
    <title>C64 tool tricks (VICE and others)</title>
    <link href="http://nurpax.github.com/posts/2018-08-23-vice-monitor-tricks.html" />
    <id>http://nurpax.github.com/posts/2018-08-23-vice-monitor-tricks.html</id>
    <published>2018-08-23T00:00:00Z</published>
    <updated>2018-08-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A collection of random C64 tool tricks.</p>
<h1 id="vice">VICE</h1>
<h2 id="capturing-the-rom-charset">Capturing the ROM charset</h2>
<p>Make ROM visible to the monitor and save data from <code>$d000</code> onwards:</p>
<pre><code>bank rom
bs &quot;data.bin&quot; 0 $d000 $d7fff</code></pre>
<h1 id="using-exomizer-to-crunch-executables">Using exomizer to crunch executables</h1>
<h2 id="installation">Installation</h2>
<ol type="1">
<li>Download and extract <a href="https://bitbucket.org/magli143/exomizer/wiki/downloads/exomizer-3.0.2.zip">exomizer</a></li>
<li>Build it by</li>
</ol>
<pre><code>mkdir exomizer
cd exomizer
make -C src</code></pre>
<p>The command line tools will reside under the <code>src</code> directory.</p>
<h2 id="packing-a-.prg-file">Packing a .prg file</h2>
<p>To pack a .prg that uses the BASIC upstart sequence (SYS something), use:</p>
<pre><code>exomizer sfx sys input.prg -o output.prg -x3</code></pre>
<p>The <code>-x3</code> adds a border flashing decrunching effect. Drop that switch if you don‚Äôt want it.</p>]]></summary>
</entry>
<entry>
    <title>BINTRIS C64: Bad lines and flexible line distance (series part 5)</title>
    <link href="http://nurpax.github.com/posts/2018-06-19-bintris-on-c64-part-5.html" />
    <id>http://nurpax.github.com/posts/2018-06-19-bintris-on-c64-part-5.html</id>
    <published>2018-06-19T00:00:00Z</published>
    <updated>2018-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(Looking for the BINTRIS C64 disk image? Find it <a href="/posts/2018-05-21-bintris-on-c64-part-2.html">here</a>.)</p>
<h2 id="introduction">Introduction</h2>
<p>This post discusses how BINTRIS uses YSCROLL manipulation to implement bad line suppression and full-screen vertical scrolling (flexible line distance, or FLD).</p>
<p>Here are the effects in action:</p>
<div class="img-columns-2">
<p class="img-column">
<img width="100%" class="img-pixelated" src="/images/bintris/bintris-writer-fld.gif" /><em>Vertical scrolling.</em>
</p>
<p class="img-column">
<img width="100%" class="img-pixelated" src="/images/bintris/bintris-logo-wobble.gif" />
<em>BINTRIS logo warp effect.</em>
</p>
</div>
<p>Note: all timing values in this post are for specific to PAL-B C64 models.</p>
<h2 id="bad-lines">Bad Lines</h2>
<p>To understand FLD, you need to grasp the concept of Bad Lines. I‚Äôll summarize Bad Lines here but you can read about it in more detail in the excellent <a href="http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt">vic-ii.txt document</a> (section 3.5). The same document also explains FLD in section 3.14.2.</p>
<p>The VIC scans out the video frame line-by-line. Each line takes exactly 63 clock cycles. On normal lines, all these 63 cycles are available to the CPU. However, on every 8th pixel row (=start of a new character row), the VIC needs an extra 40 cycles to fetch a line of character codes from memory. When these fetches start, the CPU is ‚Äústunned‚Äù, meaning it won‚Äôt execute for about 40-43 clock cycles. These lines are called Bad Lines. On these lines, you have only 20-23 clock cycles to spend on your raster magic. With sprites, even less.</p>
<p>This might not be a big deal with timing insensitive code. But since the C64 is all about carefully crafted raster code, bad lines are something you just have to deal with.</p>
<p>To illustrate bad lines, I made this little interactive chart that shows the effect of bad lines. The little green boxes at the bottom represent the 63 cycles you have for a single line. The currently executing cycle is highlighted in white. A white dot over the C64 image is the raster beam. On normal lines, the CPU runs instructions on every cycle. But on bad lines, the CPU is stunned (black boxes) and cannot execute instructions.</p>
<div id="cycle-timing-container">
</div>
<p>When do the bad lines occur? Here‚Äôs the bad line condition in pseudo code:</p>
<pre><code>   if (RASTER &gt;= $30 &amp;&amp; RASTER &lt;= $f7) {
     if ((RASTER &amp; 7) == YSCROLL) {
       // BAD LINE
     }
   }</code></pre>
<p>where RASTER is the current scanline register (<code>$d011</code>/<code>$d012</code>) and YSCROLL is the vertical scroll register (bits 0-2 of <code>$d011</code>). (See the <a href="http://sta.c64.org/cbm64mem.html">C64 memory map</a> for details on these registers.)</p>
<p>Notice how the bad line condition depends on the YSCROLL register. Turns out, you can suppress or delay bad lines by manipulating the YSCROLL value at the right time. Recall the <code>(RASTER&amp;7)==YSCROLL</code> condition. If, at the beginning of a line, you set the YSCROLL to a value that doesn‚Äôt match the lowest 3 bits of the current line, the bad line will not happen. On such lines, VIC has nothing to render (as we just tricked it to not fetch character codes) and it will render the last byte of the video memory instead (e.g., contents of <code>$3fff</code>)</p>
<p>Let‚Äôs see what we can do with this technique.</p>
<h2 id="flexible-line-distance-fld">Flexible Line Distance (FLD)</h2>
<p>Flexible line distance is a technique that uses bad line suppression to scroll the display down by an arbitrary number of lines. I use it in the BINTRIS to scroll the whole screen down when leaving the writer part.</p>
<div class="img-columns-2">
<div class="img-column">
<div id="fld-container" />
<em>The FLD effect.</em>
</div>
<div class="img-column">
<img style="display:block" width="100%" class="img-pixelated" src="/images/bintris/bintris-writer-fld.gif" />
<em>Vertical scrolling.</em>
</div>
</div>
<p>To scroll by N lines, simply trigger a raster IRQ at the top of the screen (say on line 46) and suppress N bad lines. Here‚Äôs how you might do this in C-like pseudo code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// YSCROLL is mapped to $d011</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// RASTER is mapped to $d012</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(!</span>new_frame<span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do nothing</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>YSCROLL <span class="op">=</span> <span class="bn">0x1B</span><span class="op">;</span>  <span class="co">// default YSCROLL value (%111)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">// wait for FLD start line</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>RASTER <span class="op">!=</span> <span class="bn">0x40</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// do nothing</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_fld_lines<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> cur_raster <span class="op">=</span> RASTER<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// wait for next next line</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>cur_raster <span class="op">==</span> RASTER<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do nothing</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// skip over bad line by manipulating YSCROLL</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    YSCROLL <span class="op">=</span> <span class="op">((</span>YSCROLL <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&amp;</span> <span class="dv">7</span><span class="op">)</span> <span class="op">|</span> <span class="bn">0x18</span><span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I found <a href="http://codebase64.org/doku.php?id=base:fld">working FLD code in 6502 assembly</a> from codebase64.org. I tested it by porting it to KickAssembler and running it on VICE.</p>
<h2 id="skipping-bad-lines">Skipping Bad Lines</h2>
<p>As discussed above, it‚Äôs possible to vertically scroll down the whole screen by manipulating the YSCROLL register at appropriate times. However, vertical scrolling is not the only reason why you might want to skip bad lines. Recall from the Bad Lines section that on a bad line, the CPU can run only 20-23 cycles worth of machine code. <em>(NB: although many tutorials say that you have 23 CPU cycles on a bad line, in practice you really only have 20-22 cycles to work with. I might write a separate article about this topic later on.)</em></p>
<p>The situation gets even worse if there are any sprites on a bad line. Also, the more sprites you have, the fewer CPU cycles are available. Here‚Äôs a simplified formula for evaluating how many cycles you can spend on a bad line with sprites:</p>
<p><span class="math inline"><em>n</em><em>u</em><em>m</em>_<em>c</em><em>y</em><em>c</em><em>l</em><em>e</em><em>s</em>‚ÄÑ=‚ÄÑ23‚ÄÖ‚àí‚ÄÖ(3+2*<em>n</em><em>u</em><em>m</em>_<em>s</em><em>p</em><em>r</em><em>i</em><em>t</em><em>e</em><em>s</em>)</span></p>
<p><em>(NB: This is a bit simplified, see <a href="http://www.antimon.org/dl/c64/code/missing.txt">Missing Cycles</a> for details.)</em></p>
<p>Let‚Äôs say you have enabled sprites 0-3 and they all hit a bad line. Now you have only 12 cycles to spare on your fancy raster routine (or in practice, more like 10 cycles.)</p>
<p>Ten cycles is not all that much. For example, say you want to load and store some values. Here‚Äôs all you can run during a single bad line:</p>
<pre><code>LDA abs_addr        (4 cycles)
STA abs_addr        (4 cycles)
NOP                 (2 cycles)</code></pre>
<p>The logo warp effect in BINTRIS is implemented using sprites by encoding the logo pixels into 4 separate sprites. The line-by-line warp is implemented by setting the x-coordinate of each sprite to a new value on every raster line the logo spans. Here‚Äôs a close up of this effect:</p>
<div class="img-columns-2">
<img class="img-column img-pixelated"  width="100%" src="/images/bintris/bintris-logo-wobble.gif" />
<div class="img-column">
<div id="logo-wobble-closeup-container"></div>
</div>
</div>
<p>To set the the horizontal location of each sprite, we‚Äôd need to do this for every raster line the sprites span:</p>
<pre><code>// At the beginning of a raster line
.for (var y 0; y &lt; 21; y++) {
    lda spritex + y*4 + 0   // sprite 0 x-coord
    sta $d000+0
    lda spritex + y*4 + 1   // sprite 1 x-coord
    sta $d000+2
    lda spritex + y*4 + 2   // sprite 2 x-coord
    sta $d000+4
    lda spritex + y*4 + 3   // sprite 3 x-coord
    sta $d000+6
    // + waste cycles until we&#39;re at the beginning of the next
    //   raster line
}</code></pre>
<p>That‚Äôs 32 CPU cycles per line. The sprites fall on a few bad lines and on these scanlines there‚Äôs only 10 cycles to spare. Sure, it‚Äôs possible to optimize the sprite x-coordinate stores down to 24 cycles with self-modifying code but 10 cycles doesn‚Äôt seem possible.</p>
<p>Without bad lines, there‚Äôs 52 cycles (=63-11 to account for 4 sprites) per scanline which is more than enough to move all the four sprites horizontally.</p>
<p>If only there were no bad lines..</p>
<p>You guessed it, right? If bad lines are suppressed for the duration of the logo, there will be plenty of cycles to move the sprites. Bad line suppression can be done by manipulating the YSCROLL register just as we did with FLD:</p>
<pre><code>
// Note: waste_cycles(c) is a macro that inserts the right
// amount of NOPs and BITs to burn &#39;c&#39; clock cycles.
.for (var y = 0; y &lt; 21; y++) {
    .var cycles = 63
    // skip bad line with FLD
    .var rasty = SPRITE_LOGO_YSTART + y
    .eval cycles = cycles - 3 - 8 // sprite overhead
    // Suppress bad line
    lda #$18 | ((rasty+1) &amp; %111)
    sta $d011
    .eval cycles = cycles - 6

    lda spritex + y*4 + 0
    ldx spritex + y*4 + 1
    ldy spritex + y*4 + 2
    .eval cycles -= 3*4

    sta $d000+0
    stx $d000+2
    sty $d000+4
    .eval cycles -= 4*3

    lda spritex + y*4 + 3
    sta $d000+6
    .eval cycles -= 8
    waste_cycles(cycles)
}</code></pre>
<p>If you‚Äôre interested in playing with the sprite warp, I pushed its <a href="https://github.com/nurpax/c64-samples/tree/master/sprite_warp">standalone source code up on github</a>. Here‚Äôs how it looks like:</p>
<p><img class="img-medium-wide" src="/images/bintris/sprite-wobble-standalone.png"/></p>
<script type="text/javascript">
var diagram, fld;

$(function () {
    diagram = new diagrams.TimingDiagram('cycle-timing-container');
    diagram.mount();

    fld = new diagrams.FldDiagram('fld-container');
    fld.mount();

    warpCrop = new diagrams.LogoWarpCrop('logo-wobble-closeup-container');
    warpCrop.mount();
})
</script>
<h2 id="next-in-series">Next in series</h2>
<p>My next BINTRIS post will wrap up the article series.</p>]]></summary>
</entry>
<entry>
    <title>Break down of a C64 demo effect</title>
    <link href="http://nurpax.github.com/posts/2018-06-07-c64-filled-sinewave.html" />
    <id>http://nurpax.github.com/posts/2018-06-07-c64-filled-sinewave.html</id>
    <published>2018-06-07T00:00:00Z</published>
    <updated>2018-06-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>So I recently made this little sinewave demo effect on the Commodore 64:</p>
<p><img class="img-pixelated img-medium-wide" src="/images/c64/sine/sinewave-gifanim-2018-05-31.gif" /></p>
<p>This generated a lot of lively discussion on <a href="https://twitter.com/nurpax/status/1002288831511580672">twitter</a> and <a href="https://www.reddit.com/r/c64/comments/8o9aoh/some_charset_hacking_from_last_week/">/r/c64</a>. A bunch of people were curious as to how it works and I promised to explain it on my blog.</p>
<p>The main idea is to use character mode with a custom character set. I sample y-coordinate every 8 pixels to produce a list of line segments <span class="math inline">[(0,<em>y</em><sub>0</sub>),(8,<em>y</em><sub>1</sub>),(16,<em>y</em><sub>2</sub>),...,(320,<em>y</em><sub>40</sub>)]</span>. In the below animation, you can see these line segments along with blue rectangles that signify which 8x8 character blocks intersect the line segments.</p>
<p><img class="img-medium-wide" src="/images/c64/sine/sinewave-block-cover.gif"/></p>
<p>The goal then is to fill all the pixels below a line segment with light blue and everything above it with dark blue.</p>
<p>Here‚Äôs how you might code this up in Python:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute sine wave by stepping every 8th pixel</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>ypos <span class="op">=</span> [sinewave(phase, x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">+</span> <span class="dv">8</span>, <span class="dv">8</span>)]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>clear_screen(BLUE)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Loop through each line segment</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    x0 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    x1 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span> <span class="op">+</span> <span class="dv">8</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    y0 <span class="op">=</span> ypos[x]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    y1 <span class="op">=</span> ypos[x <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill everything below the (x0,y0)-(x1,y1) line segment</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># with LIGHT_BLUE</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    fill_polygon([(x0, y0), (x1, y1), (x1, <span class="dv">200</span>), (x0, <span class="dv">200</span>)], LIGHT_BLUE)</span></code></pre></div>
<p>Unfortunately using a polygon fill routine in C64 bitmap mode would be pretty slow. To make this run fast, I precompute the different ways a line segment can intersect 8x8 character blocks using an edge function rasterizer written in Python. Here‚Äôs an image that shows some combinations of a line hitting 3 vertically stacked 8x8 blocks:</p>
<p><img class="img-pixelated img-smallest" src="/images/c64/sine/sinewave-fill-closeup.gif"/></p>
<p>Here‚Äôs Python code for the block rasterizer:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a> <span class="co"># one bit of subpixel precision</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a> subpix <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mk8x8(yoffs, a, b, c):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">8</span>)]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        yy <span class="op">=</span> (y <span class="op">+</span> yoffs) <span class="op">*</span> subpix</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            xx <span class="op">=</span> x <span class="op">*</span> subpix</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> a <span class="op">*</span> xx <span class="op">+</span> b <span class="op">*</span> yy <span class="op">+</span> c <span class="op">&gt;=</span> <span class="fl">0.0</span>:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                arr[x <span class="op">+</span> y <span class="op">*</span> <span class="dv">8</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> arr</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct_fill_table():</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    x0 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    x1 <span class="op">=</span> <span class="dv">8</span> <span class="op">*</span> subpix</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    fill_tbl <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> subpix)]</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y0 <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix):</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        fill_tbl[y0] <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix)]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> yi1 <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">4</span> <span class="op">*</span> subpix, <span class="dv">4</span> <span class="op">*</span> subpix):</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            y1 <span class="op">=</span> y0 <span class="op">+</span> yi1</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            a <span class="op">=</span> <span class="op">-</span>(y1 <span class="op">-</span> y0)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            b <span class="op">=</span> (x1 <span class="op">-</span> x0)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="op">-</span>(a <span class="op">*</span> x0 <span class="op">+</span> b <span class="op">*</span> y0)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            chr_a <span class="op">=</span> mk8x8(<span class="op">-</span><span class="dv">8</span>, a, b, c)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            chr_b <span class="op">=</span> mk8x8(<span class="dv">0</span>, a, b, c)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            chr_c <span class="op">=</span> mk8x8(<span class="dv">8</span>, a, b, c)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>            fill_tbl[y0][yi1 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix] <span class="op">=</span> [chr_a, chr_b, chr_c]</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fill_tbl</span></code></pre></div>
<p>A Python renderer using the table generated <code>construct_fill_table()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> draw_fills(ypos):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> xi <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> xi <span class="op">*</span> <span class="dv">8</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        y0 <span class="op">=</span> <span class="bu">int</span>((ypos[xi] <span class="op">*</span> subpix))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        y1 <span class="op">=</span> <span class="bu">int</span>((ypos[xi <span class="op">+</span> <span class="dv">1</span>] <span class="op">*</span> subpix))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        yy0 <span class="op">=</span> y0 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        yy1 <span class="op">=</span> y1 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        y0 <span class="op">-=</span> yy0</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        y1 <span class="op">-=</span> yy0</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        chrs <span class="op">=</span> fill_tbl[y0][y1 <span class="op">-</span> y0 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">-</span> <span class="dv">8</span>, chrs[<span class="dv">0</span>])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        blit_8x8(x, yy0 <span class="op">/</span> subpix, chrs[<span class="dv">1</span>])</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">+</span> <span class="dv">8</span>, chrs[<span class="dv">2</span>])</span></code></pre></div>
<p>Note that in the above code, each entry in the <code>fill_tbl</code> 2d-array is a list 3 character bitmaps. A character bitmap is a 64 entry list of zeros and ones. To make use of this on the C64, you need to turn this data into two separate arrays: the actual character set and an array indexed by <span class="math inline"><em>y</em>0</span>, <span class="math inline"><em>y</em>1</span> that returns a list of 3 character indices.</p>
<p>Here‚Äôs how these two tables look like. First the charset:</p>
<p><img class="img-pixelated img-small" src="/images/c64/sine/charset-16x16.png" /></p>
<p>..and the character index table (<code>$20</code> is the space character, ie., an empty block, <code>$a0</code> is a fully filled 8x8 block):</p>
<pre><code>y0y1tbl:
    .byte $00, $a0, $a0, $a0
    .byte $02, $0e, $a0, $a0
    .byte $0f, $10, $a0, $a0
    .byte $1b, $24, $a0, $a0
... 252 more entries ...</code></pre>
<p>If you‚Äôd run the C64 equivalent of the above Python routine on the default charset, you‚Äôd see something like this:</p>
<p><img class="img-pixelated img-medium-wide" src="/images/c64/sine/sinewave-sans-charset.gif" /></p>
<p>Since I have full control over the sine animation, I choose animation parameters that make the line segments behave ‚Äúnicely‚Äù. Niceness is defined as follows: let <span class="math inline">(<em>x</em>0,<em>y</em>0)</span> and <span class="math inline">(<em>x</em>0+8,<em>y</em>1)</span> be the end points of a line segment. The segment behaves ‚Äúnicely‚Äù if it satisfies the following condition: <span class="math inline">|<em>y</em>0‚àí<em>y</em>1|‚ÄÑ&lt;‚ÄÑ<em>c</em></span> (where <span class="math inline"><em>c</em></span> is some small number, in my case 8). This is required in order to keep the <code>fill_tbl</code> at a reasonable size and to limit the number of unique 8x8 characters (since the hardware character set is only 256 entries).</p>
<p>That‚Äôs about all there is to it, I guess.</p>]]></summary>
</entry>

</feed>
