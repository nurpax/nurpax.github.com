<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>nurpax.github.com blog</title>
    <link href="http://nurpax.github.com/rss.xml" rel="self" />
    <link href="http://nurpax.github.com" />
    <id>http://nurpax.github.com/rss.xml</id>
    <author>
        <name>Janne Hellsten</name>
        <email>jjhellst@gmail.com</email>
    </author>
    <updated>2019-12-04T00:00:00Z</updated>
    <entry>
    <title>Python argparse</title>
    <link href="http://nurpax.github.com/posts/2019-12-04-argparse.html" />
    <id>http://nurpax.github.com/posts/2019-12-04-argparse.html</id>
    <published>2019-12-04T00:00:00Z</published>
    <updated>2019-12-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>How I use argparse.</p>
<h2 id="basic-main-stub">Basic main() stub</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="im">import</span> argparse</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="im">import</span> sys</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">_examples <span class="op">=</span> <span class="st">&#39;&#39;&#39;examples:</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="st">  # Run x, y, z</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="st">  python </span><span class="sc">%(prog)s</span><span class="st"> --output=tmp</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="st">&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">def</span> main():</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    parser <span class="op">=</span> argparse.ArgumentParser(</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">        description<span class="op">=</span><span class="st">&#39;Argparse test&#39;</span>,</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">        epilog<span class="op">=</span>_examples,</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">        formatter_class<span class="op">=</span>argparse.RawDescriptionHelpFormatter</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    )</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    parser.add_argument(<span class="st">&#39;--output&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify output dir&#39;</span>)</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    args <span class="op">=</span> parser.parse_args()</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    <span class="bu">print</span> (<span class="bu">vars</span>(args))</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    main()</a></code></pre></div>
<h2 id="argument-default-values">Argument default values</h2>
<p>Use <code>default=</code> to set a default value for an argument.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1">parser.add_argument(<span class="st">&#39;--format&#39;</span>, default<span class="op">=</span><span class="st">&#39;html&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify output format&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;FMT&#39;</span>)</a></code></pre></div>
<p>To show default values in your help strings, use <code>%(default)s</code> interpolation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1">parser.add_argument(<span class="st">&#39;--format&#39;</span>, default<span class="op">=</span><span class="st">&#39;html&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify output format (default: </span><span class="sc">%(default)s</span><span class="st">)&#39;</span>)</a></code></pre></div>
<p>If the default value is type <code>str</code>, it will be run through your <code>type</code> callback, otherwise it’s returned directly. This can be helpful when authoring help strings containing <code>%(default)s</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1">parser.add_argument(<span class="st">&#39;--enable-x&#39;</span>, <span class="bu">type</span><span class="op">=</span>_str_to_bool, default<span class="op">=</span><span class="va">True</span>,</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Enable feature x (default: </span><span class="sc">%(default)s</span><span class="st">)&#39;</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co"># outputs: --enable-x ENABLE_X   Enable feature x (default: True)</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">parser.add_argument(<span class="st">&#39;--enable-y&#39;</span>, <span class="bu">type</span><span class="op">=</span>_str_to_bool, default<span class="op">=</span><span class="st">&#39;y&#39;</span>,</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Enable feature y (default: </span><span class="sc">%(default)s</span><span class="st">)&#39;</span>)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co"># outputs: --enable-y ENABLE_Y   Enable feature y (default: y)</span></a></code></pre></div>
<h2 id="argument-types">Argument types</h2>
<p>Use <code>type=</code> to set your own type conversion function. A <code>type</code> is just a function that converts a string to some output type.</p>
<p><strong>Numbers.</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1">parser.add_argument(<span class="st">&#39;--int-val&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">int</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify integer&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;N&#39;</span>)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">parser.add_argument(<span class="st">&#39;--flt-val&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">float</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify float&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;N&#39;</span>)</a></code></pre></div>
<p><strong>Booleans.</strong> You can’t use <code>type=bool</code> for booleans (try running <code>bool('True')</code> in the REPL if you want to know why.) Do this instead:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">def</span> _str_to_bool(v):</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="cf">if</span> <span class="bu">isinstance</span>(v, <span class="bu">bool</span>):</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">        <span class="cf">return</span> v</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="cf">if</span> v.lower() <span class="kw">in</span> (<span class="st">&#39;yes&#39;</span>, <span class="st">&#39;true&#39;</span>, <span class="st">&#39;t&#39;</span>, <span class="st">&#39;y&#39;</span>, <span class="st">&#39;1&#39;</span>):</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="cf">elif</span> v.lower() <span class="kw">in</span> (<span class="st">&#39;no&#39;</span>, <span class="st">&#39;false&#39;</span>, <span class="st">&#39;f&#39;</span>, <span class="st">&#39;n&#39;</span>, <span class="st">&#39;0&#39;</span>):</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">        <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">        <span class="cf">raise</span> argparse.ArgumentTypeError(<span class="st">&#39;Boolean value expected.&#39;</span>)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">parser.add_argument(<span class="st">&#39;--enable-output&#39;</span>, <span class="bu">type</span><span class="op">=</span>_str_to_bool, default<span class="op">=</span><span class="va">False</span>, metavar<span class="op">=</span><span class="st">&#39;BOOL&#39;</span>)</a></code></pre></div>
<p><strong>Comma-separated list of values.</strong> How to specify a list of strings like <code>python foo.py --tags=apple,fruit</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">def</span> _parse_comma_sep(s):</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="cf">if</span> (s <span class="kw">is</span> <span class="va">None</span>) <span class="kw">or</span> (s <span class="op">==</span> <span class="st">&#39;&#39;</span>):</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">        <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="cf">return</span> s.split(<span class="st">&#39;,&#39;</span>)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">parser.add_argument(<span class="st">&#39;--tags&#39;</span>, <span class="bu">type</span><span class="op">=</span>_parse_comma_sep, default<span class="op">=</span><span class="st">&#39;&#39;</span>, metavar<span class="op">=</span><span class="st">&#39;TAGS&#39;</span>)</a></code></pre></div>
<h2 id="subcommands">Subcommands</h2>
<p>Add a subcommand called <code>log</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="im">import</span> argparse</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="im">import</span> sys</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">_examples <span class="op">=</span> <span class="st">&#39;&#39;&#39;examples:</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="st">  # Show log in html format</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="st">  python </span><span class="sc">%(prog)s</span><span class="st"> log --format=html</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="st">&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">def</span> main():</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    parser <span class="op">=</span> argparse.ArgumentParser(</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        description<span class="op">=</span><span class="st">&#39;Argparse test&#39;</span>,</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        epilog<span class="op">=</span>_examples,</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        formatter_class<span class="op">=</span>argparse.RawDescriptionHelpFormatter</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    )</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    subparsers <span class="op">=</span> parser.add_subparsers(<span class="bu">help</span><span class="op">=</span><span class="st">&#39;Sub-commands&#39;</span>, dest<span class="op">=</span><span class="st">&#39;command&#39;</span>)</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">    parser_log <span class="op">=</span> subparsers.add_parser(<span class="st">&#39;log&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Show log&#39;</span>)</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">    parser_log.add_argument(<span class="st">&#39;--format&#39;</span>, <span class="bu">help</span><span class="op">=</span><span class="st">&#39;Specify format&#39;</span>, choices<span class="op">=</span>[<span class="st">&#39;raw&#39;</span>, <span class="st">&#39;html&#39;</span>])</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">    args <span class="op">=</span> parser.parse_args()</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    <span class="bu">print</span> (<span class="bu">vars</span>(args))</a>
<a class="sourceLine" id="cb8-23" data-line-number="23"></a>
<a class="sourceLine" id="cb8-24" data-line-number="24"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">    main()</a></code></pre></div>]]></summary>
</entry>
<entry>
    <title>Dirty tricks 6502 programmers use</title>
    <link href="http://nurpax.github.com/posts/2019-08-18-dirty-tricks-6502-programmers-use.html" />
    <id>http://nurpax.github.com/posts/2019-08-18-dirty-tricks-6502-programmers-use.html</id>
    <published>2019-08-18T00:00:00Z</published>
    <updated>2019-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<p>This post recaps some of the C64 coding tricks used in my little <a href="https://twitter.com/nurpax/status/1159192477598965766">Commodore 64 coding competition</a>. The competition rules were simple: make a C64 executable (PRG) that draws two lines to form the below image. The objective was to do this in as few bytes as possible.</p>
<div class="center">
<img width="75%" class="img-pixelated" src="/images/c64/lines/lines-2x.png" />
</div>
<p>Entries were posted as Twitter replies and DMs, containing only the PRG byte-length and an MD5 hash of the PRG file.</p>
<p>Here’s a list of participants with source code links to their submissions:</p>
<ul>
<li><a href="https://twitter.com/fsphil">Philip Heron</a> (<a href="https://github.com/fsphil/tinyx">code</a> - 34 bytes - compo winner)</li>
<li><a href="https://twitter.com/GeirSigmund">Geir Straume</a> (<a href="https://c64prg.appspot.com/downloads/lines34b.zip">code</a> - 34 bytes)</li>
<li><a href="https://twitter.com/petrih3">Petri Häkkinen</a> (<a href="https://github.com/petrihakkinen/c64-lines">code</a> - 37 bytes)</li>
<li><a href="https://twitter.com/laubzega">Mathlev Raxenblatz</a> (<a href="https://gist.github.com/laubzega/fb59ee6a3d482feb509dae7b77e925cf">code</a> - 38 bytes)</li>
<li><a href="https://twitter.com/achrenico">Jan Achrenius</a> (<a href="https://twitter.com/achrenico/status/1161383381835362305">code</a> - 48 bytes)</li>
<li><a href="https://twitter.com/jamie30dbs">Jamie Fuller</a> (<a href="https://github.com/30dbs/c64x">code</a> - 50 bytes)</li>
<li><a href="https://twitter.com/dagershman">David A. Gershman</a> (<a href="http://c64.dagertech.net/cgi-bin/cgiwrap/c64/index.cgi?p=xchallenge/.git;a=tree">code</a> - 53 bytes)</li>
<li><a href="https://twitter.com/nurpax">Janne Hellsten</a> (<a href="https://gist.github.com/nurpax/d429be441c7a9f4a6ceffbddc35a0003">code</a> - 56 bytes)</li>
</ul>
<p>(If I missed someone, please let me know and I’ll update the post.)</p>
<p>The rest of this post focuses on some of the assembly coding tricks used in the compo submissions.</p>
<h2 id="basics">Basics</h2>
<p>The C64 default graphics mode is the 40x25 charset mode. The framebuffer is split into two arrays in RAM:</p>
<ul>
<li><code>$0400</code> (Screen RAM, 40x25 bytes)</li>
<li><code>$d800</code> (Color RAM, 40x25 bytes)</li>
</ul>
<p>To set a character, you store a byte into screen RAM at <code>$0400</code> (e.g., <code>$0400+y*40+x</code>). Color RAM is by default initialized to light blue (color 14) which happens to be the same color we use for the lines – meaning we can leave color RAM untouched.</p>
<p>You can control the border and background colors with memory mapped I/O registers at <code>$d020</code> (border) and <code>$d021</code> (background).</p>
<p>Drawing the two lines is pretty easy as we can hardcode for the fixed line slope. Here’s a C implementation that draws the lines and dumps screen contents on stdout (register writes stubbed out and screen RAM is <code>malloc()</code>’d to make it run on PC):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="dt">void</span> dump(<span class="dt">const</span> <span class="dt">uint8_t</span>* screen) {</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="dt">const</span> <span class="dt">uint8_t</span>* s = screen;</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="cf">for</span> (<span class="dt">int</span> y = <span class="dv">0</span>; y &lt; <span class="dv">25</span>; y++) {</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">        <span class="cf">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; <span class="dv">40</span>; x++, s++) {</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">            printf(<span class="st">&quot;%c&quot;</span>, *s == <span class="bn">0xa0</span> ? <span class="ch">&#39;#&#39;</span> : <span class="ch">&#39;.&#39;</span>);</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="dt">void</span> setreg(<span class="dt">uintptr_t</span> dst, <span class="dt">uint8_t</span> v) {</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="co">//  *((uint8_t *)dst) = v;</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"><span class="co">//  uint8_t* screenRAM = (uint_8*)0x0400;</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    <span class="dt">uint8_t</span>* screenRAM = (<span class="dt">uint8_t</span> *)calloc(<span class="dv">40</span>*<span class="dv">25</span>, <span class="bn">0x20</span>);</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">    setreg(<span class="bn">0xd020</span>, <span class="dv">0</span>); <span class="co">// Set border color</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">    setreg(<span class="bn">0xd021</span>, <span class="dv">0</span>); <span class="co">// Set background color</span></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    <span class="dt">int</span> yslope = (<span class="dv">25</span>&lt;&lt;<span class="dv">8</span>)/<span class="dv">40</span>;</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">    <span class="dt">int</span> yf = yslope/<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">    <span class="cf">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; <span class="dv">40</span>; x++) {</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">        <span class="dt">int</span> yi = yf &gt;&gt; <span class="dv">8</span>;</a>
<a class="sourceLine" id="cb1-30" data-line-number="30">        <span class="co">// First line</span></a>
<a class="sourceLine" id="cb1-31" data-line-number="31">        screenRAM[x + yi*<span class="dv">40</span>] = <span class="bn">0xa0</span>;</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">        <span class="co">// Second line (X-mirrored)</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">        screenRAM[(<span class="dv">39</span>-x) + yi*<span class="dv">40</span>] = <span class="bn">0xa0</span>;</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">        yf += yslope;</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb1-36" data-line-number="36"></a>
<a class="sourceLine" id="cb1-37" data-line-number="37">    dump(screenRAM);</a>
<a class="sourceLine" id="cb1-38" data-line-number="38">}</a></code></pre></div>
<p>The screen codes used above are: <code>$20</code> (blank) and <code>$a0</code> (8x8 filled block). If you run it, you should see ASCII art for the two lines:</p>
<pre class="narrowlines"><code>##....................................##
..#..................................#..
...##..............................##...
.....#............................#.....
......##........................##......
........##....................##........
..........#..................#..........
...........##..............##...........
.............#............#.............
..............##........##..............
................##....##................
..................#..#..................
...................##...................
..................#..#..................
................##....##................
..............##........##..............
.............#............#.............
...........##..............##...........
..........#..................#..........
........##....................##........
......##........................##......
.....#............................#.....
...##..............................##...
..#..................................#..
##....................................##</code></pre>
<p>Using 6502 assembly and assembly pseudos, we can trivially implement the same in assembly:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb3-1" data-line-number="1">!<span class="bu">include</span> <span class="st">&quot;c64.asm&quot;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">+c64::basic_start(<span class="bu">entry</span>)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="bu">entry</span>: {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    lda #<span class="dv">0</span>      <span class="co">; black color</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    sta <span class="dv">$</span>d020   <span class="co">; set border to 0</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    sta <span class="dv">$</span>d021   <span class="co">; set background to 0</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="co">; clear the screen</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    ldx #<span class="dv">0</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    lda #<span class="bn">$20</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="fu">clrscr:</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">!for i <span class="bu">in</span> [<span class="dv">0</span><span class="bn">, $100, $200, </span><span class="dv">$300</span>] {</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    sta<span class="bn"> $0400 </span>+ i, x</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">    inx</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    bne clrscr</a>
<a class="sourceLine" id="cb3-19" data-line-number="19"></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">    <span class="co">; line drawing, completely unrolled</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    <span class="co">; with assembly pseudos</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22">    lda #<span class="dv">$</span>a0</a>
<a class="sourceLine" id="cb3-23" data-line-number="23"></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">    !for i <span class="bu">in</span> range(<span class="dv">40</span>) {</a>
<a class="sourceLine" id="cb3-25" data-line-number="25">        !let y0 = Math.floor(<span class="dv">25</span>/<span class="dv">40</span>*(i<span class="fl">+0.5</span>))</a>
<a class="sourceLine" id="cb3-26" data-line-number="26">        sta<span class="bn"> $0400 </span>+ y0*<span class="dv">40</span> + i</a>
<a class="sourceLine" id="cb3-27" data-line-number="27">        sta<span class="bn"> $0400 </span>+ (<span class="dv">24</span>-y0)*<span class="dv">40</span> + i</a>
<a class="sourceLine" id="cb3-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb3-29" data-line-number="29"><span class="fu">inf:</span> <span class="bu">jmp</span> inf  <span class="co">; halt</span></a>
<a class="sourceLine" id="cb3-30" data-line-number="30">}</a></code></pre></div>
<p>This completely unrolls the line drawing part resulting in a fairly large 286 byte PRG.</p>
<p>Before diving into optimized variants, let’s make a couple of observations:</p>
<p>First, we’re running on the C64 with the ROM routines banked in. There’s a bunch of subroutines in ROM that may be useful for our little program. For example, you can clear the screen with <code>JSR $E544</code>.</p>
<p>Second, address calculations on an 8-bit CPU like the 6502 can be cumbersome and cost a lot of bytes. This CPU also doesn’t have a multiplier, so computing something like <code>y*40+i</code> usually involves either a bunch of logical shifts or a lookup table, again costing bytes. To avoid multiplying by 40, we can instead advance the screen pointer incrementally:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" data-line-number="1">    <span class="dt">int</span> yslope = (<span class="dv">25</span>&lt;&lt;<span class="dv">8</span>)/<span class="dv">40</span>;</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="dt">int</span> yf = yslope/<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="dt">uint8_t</span>* dst = screenRAM;</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="cf">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; <span class="dv">40</span>; x++) {</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">        dst[x] = <span class="bn">0xa0</span>;</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        dst[(<span class="dv">39</span>-x)] = <span class="bn">0xa0</span>;</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        yf += yslope;</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        <span class="cf">if</span> (yf &amp; <span class="dv">256</span>) { <span class="co">// Carry set?</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">            dst += <span class="dv">40</span>;</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">            yf &amp;= <span class="dv">255</span>;</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">        }</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    }</a></code></pre></div>
<p>We keep adding the line slope to a fixed point counter <code>yf</code> and when the 8-bit addition sets the carry flag, add 40.</p>
<p>Here’s the incremental approach implemented in assembly:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb5-1" data-line-number="1">!<span class="bu">include</span> <span class="st">&quot;c64.asm&quot;</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">+c64::basic_start(<span class="bu">entry</span>)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">!let screenptr =<span class="bn"> $20</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">!let x0 =<span class="bn"> $40</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">!let x1 =<span class="bn"> $41</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">!let yf =<span class="bn"> $60</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="bu">entry</span>: {</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">        lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        sta x0</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">        sta <span class="dv">$</span>d020</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        sta <span class="dv">$</span>d021</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">        <span class="co">; kernal clear screen</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">        <span class="bu">js</span>r <span class="dv">$</span>e544</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">        <span class="co">; set screenptr = $0400</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">        lda #&lt;<span class="bn">$0400</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">        sta screenptr+<span class="dv">0</span></a>
<a class="sourceLine" id="cb5-22" data-line-number="22">        lda #&gt;<span class="bn">$0400</span></a>
<a class="sourceLine" id="cb5-23" data-line-number="23">        sta screenptr+<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24"></a>
<a class="sourceLine" id="cb5-25" data-line-number="25">        lda #<span class="dv">80</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">        sta yf</a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">        lda #<span class="dv">39</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">        sta x1</a>
<a class="sourceLine" id="cb5-30" data-line-number="30"><span class="fu">xloop:</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">        lda #<span class="dv">$</span>a0</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">        ldy x0</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">        <span class="co">; screenRAM[x] = 0xA0</span></a>
<a class="sourceLine" id="cb5-34" data-line-number="34">        sta (screenptr), y</a>
<a class="sourceLine" id="cb5-35" data-line-number="35">        ldy x1</a>
<a class="sourceLine" id="cb5-36" data-line-number="36">        <span class="co">; screenRAM[39-x] = 0xA0</span></a>
<a class="sourceLine" id="cb5-37" data-line-number="37">        sta (screenptr), y</a>
<a class="sourceLine" id="cb5-38" data-line-number="38"></a>
<a class="sourceLine" id="cb5-39" data-line-number="39">        <span class="bu">clc</span></a>
<a class="sourceLine" id="cb5-40" data-line-number="40">        lda #<span class="dv">160</span>  <span class="co">; line slope</span></a>
<a class="sourceLine" id="cb5-41" data-line-number="41">        <span class="bu">adc</span> yf</a>
<a class="sourceLine" id="cb5-42" data-line-number="42">        sta yf</a>
<a class="sourceLine" id="cb5-43" data-line-number="43">        bcc no_add</a>
<a class="sourceLine" id="cb5-44" data-line-number="44"></a>
<a class="sourceLine" id="cb5-45" data-line-number="45">        <span class="co">; advance screen ptr by 40</span></a>
<a class="sourceLine" id="cb5-46" data-line-number="46">        <span class="bu">clc</span></a>
<a class="sourceLine" id="cb5-47" data-line-number="47">        lda screenptr</a>
<a class="sourceLine" id="cb5-48" data-line-number="48">        <span class="bu">adc</span> #<span class="dv">40</span></a>
<a class="sourceLine" id="cb5-49" data-line-number="49">        sta screenptr</a>
<a class="sourceLine" id="cb5-50" data-line-number="50">        lda screenptr+<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-51" data-line-number="51">        <span class="bu">adc</span> #<span class="dv">0</span></a>
<a class="sourceLine" id="cb5-52" data-line-number="52">        sta screenptr+<span class="dv">1</span></a>
<a class="sourceLine" id="cb5-53" data-line-number="53"></a>
<a class="sourceLine" id="cb5-54" data-line-number="54"><span class="fu">no_add:</span></a>
<a class="sourceLine" id="cb5-55" data-line-number="55">        <span class="bu">inc</span> x0</a>
<a class="sourceLine" id="cb5-56" data-line-number="56">        <span class="bu">dec</span> x1</a>
<a class="sourceLine" id="cb5-57" data-line-number="57">        bpl xloop</a>
<a class="sourceLine" id="cb5-58" data-line-number="58"></a>
<a class="sourceLine" id="cb5-59" data-line-number="59"><span class="fu">inf:</span>    <span class="bu">jmp</span> inf</a>
<a class="sourceLine" id="cb5-60" data-line-number="60">}</a></code></pre></div>
<p>At 82 bytes, this is still pretty hefty. A couple of obvious size problems arise from 16-bit address computations:</p>
<p>Setting up the <code>screenptr</code> value for indirect-indexed addressing:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb6-1" data-line-number="1">        <span class="co">; set screenptr = $0400</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">        lda #&lt;<span class="bn">$0400</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">        sta screenptr+<span class="dv">0</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">        lda #&gt;<span class="bn">$0400</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        sta screenptr+<span class="dv">1</span></a></code></pre></div>
<p>Advancing <code>screenptr</code> to the next row by adding 40:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb7-1" data-line-number="1">        <span class="co">; advance screen ptr by 40</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">        <span class="bu">clc</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">        lda screenptr</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="bu">adc</span> #<span class="dv">40</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        sta screenptr</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        lda screenptr+<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        <span class="bu">adc</span> #<span class="dv">0</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        sta screenptr+<span class="dv">1</span></a></code></pre></div>
<p>Sure this code could probably be made smaller but what if we didn’t need manipulate 16-bit addresses in the first place? Let’s see this can be avoided.</p>
<h2 id="trick-1-scrolling">Trick 1: Scrolling!</h2>
<p>Instead of plotting the line across the screen RAM, we draw only on the last Y=24 screen row, and scroll the whole screen up by calling a “scroll up” ROM function with <code>JSR $E8EA</code>!</p>
<p>The x-loop becomes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb8-1" data-line-number="1">        lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">        sta x0</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        lda #<span class="dv">39</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">        sta x1</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="fu">xloop:</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        lda #<span class="dv">$</span>a0</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        ldx x0</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        <span class="co">; hardcoded absolute address to last screen line</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        ldx x1</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">        <span class="bu">adc</span> yf</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        sta yf</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        bcc no_scroll</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">        <span class="co">; scroll screen up!</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        <span class="bu">js</span>r <span class="dv">$</span>e8ea</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="fu">no_scroll:</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">        <span class="bu">inc</span> x0</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">        <span class="bu">dec</span> x1</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">        bpl xloop</a></code></pre></div>
<p>Here’s how the line renderer progresses with this trick:</p>
<div class="center">
<img width="75%" class="img-pixelated" src="/images/c64/lines/lines-scroll.gif" />
</div>
<p>This trick was one of my favorites in this compo. It was also independently discovered by pretty much every participant.</p>
<h2 id="trick-2-self-modifying-code">Trick 2: Self-modifying code</h2>
<p>The code to store the pixel values ends up being roughly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb9-1" data-line-number="1">        ldx x1</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">        <span class="co">; hardcoded absolute address to last screen line</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        ldx x0</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">        <span class="bu">inc</span> x0</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="bu">dec</span> x1</a></code></pre></div>
<p>This encodes into the following 14 byte sequence:</p>
<pre><code>0803: A6 22               LDX $22
0805: 9D C0 07            STA $07C0,X
0808: A6 20               LDX $20
080A: 9D C0 07            STA $07C0,X
080D: E6 22               INC $22
080F: C6 20               DEC $20</code></pre>
<p>There’s a more compact way to write this using self-modifying code (SMC)..</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb11-1" data-line-number="1">        ldx x1</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="fu">addr0:</span>  sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        <span class="co">; advance the second x-coord with SMC</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">        <span class="bu">inc</span> addr0+<span class="dv">1</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">        <span class="bu">dec</span> x1</a></code></pre></div>
<p>..which encodes to 13 bytes:</p>
<pre><code>0803: A6 22               LDX $22
0805: 9D C0 07            STA $07C0,X
0808: 8D C0 07            STA $07C0
080B: EE 09 08            INC $0809
080E: C6 22               DEC $22</code></pre>
<h2 id="trick-3-exploiting-the-power-on-state">Trick 3: Exploiting the power on state</h2>
<p>Making wild assumptions about the running environment was considered OK in this compo: the line drawing PRG is the first thing that’s run after C64 power on, and there was no requirement to exit cleanly back to the BASIC prompt. So anything you find from the initial environment upon entry to your PRG, you can and should use to your advantage. Here are some of the things that were considered “constant” upon entry to the PRG:</p>
<ul>
<li>A, X, Y registers were assumed to be all zeros</li>
<li>All CPU flags cleared</li>
<li>Zeropage (addresses <code>$00</code>-<code>$ff</code>) contents</li>
</ul>
<p>Similarly, if you called any KERNAL ROM routines, you could totally take advantage of any side-effects they might have: returned CPU flags, temporary values set into zeropage, etc.</p>
<p>After the first few size-optimization passes, everyone turned their eyes on this machine monitor view to look for any interesting values:</p>
<div class="center overflow">
<img class="img-pixelated" src="/images/c64/lines/monitor-screenshot.png" />
</div>
<p>The zeropage indeed contains some useful values for our purposes:</p>
<ul>
<li><code>$d5</code>: 39/$27 == line length - 1</li>
<li><code>$22</code>: 64/$40 == initial value for line slope counter</li>
</ul>
<p>You can use these to shave off a few bytes at init time. For example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb13-1" data-line-number="1">!let x0 =<span class="bn"> $20</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">        lda #<span class="dv">39</span>      <span class="co">; 0801: A9 27    LDA #$27</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">        sta x0       <span class="co">; 0803: 85 20    STA $20</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="fu">xloop:</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">        <span class="bu">dec</span> x0       <span class="co">; 0805: C6 20    DEC $20</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">        bpl xloop    <span class="co">; 0807: 10 FC    BPL $0805</span></a></code></pre></div>
<p>As <code>$d5</code> contains a value 39, you can map your <code>x0</code> counter to point to <code>$d5</code> and skip the LDA/STA pair:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb14-1" data-line-number="1">!let x0 = <span class="dv">$</span>d5</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">        <span class="co">; nothing here!</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="fu">xloop:</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">        <span class="bu">dec</span> x0       <span class="co">; 0801: C6 D5    DEC $D5</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">        bpl xloop    <span class="co">; 0803: 10 FC    BPL $0801</span></a></code></pre></div>
<p>Philip’s <a href="https://github.com/fsphil/tinyx/blob/master/x34/x34.s">winning entry</a> takes this to the extreme. Recall the address of the last char row <code>$07C0</code> (==<code>$0400+24*40</code>). This value does not exist in the zeropage on init. However, as a side-effect of how the ROM “scroll up” subroutine uses zeropage temporaries, addresses <code>$D1-$D2</code> will contain <code>$07C0</code> on return from this function. So instead of <code>STA $07C0,x</code> to store a pixel, you can use the one byte shorter indirect-indexed addressing mode store <code>STA ($D1),y</code>.</p>
<h2 id="trick-4-smaller-startup">Trick 4: Smaller startup</h2>
<p>A typical C64 PRG binary file contains the following:</p>
<ul>
<li>First 2 bytes: loading address (usually <code>$0801</code>)</li>
<li>12 bytes of BASIC startup sequence</li>
</ul>
<p>The BASIC startup sequence looks like this (addresses <code>$801-$80C</code>):</p>
<pre><code>0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00
080D: 8D 20 D0     STA $D020</code></pre>
<p>Without going into details about <a href="https://www.c64-wiki.com/wiki/BASIC_token">tokenized BASIC memory layout</a>, this sequence more or less amounts to “10 SYS 2061”. Address <code>2061</code> (<code>$080D</code>) is where our actual machine code program starts when the BASIC interpreter executes the SYS command.</p>
<p>14 bytes just to get going feels excessive. Philip, Mathlev and Geir had used some clever tricks to get rid of the BASIC sequence altogether. This requires that the PRG is loaded with <code>LOAD &quot;*&quot;,8,1</code> as <code>LOAD &quot;*&quot;,8</code> ignores the PRG loading address (the first two bytes) and always loads to <code>$0801</code>.</p>
<div class="center">
<img width="75%" class="img-pixelated" src="/images/c64/lines/vice-screen-sys.png" />
</div>
<p>Two methods were used:</p>
<ul>
<li>The stack trick</li>
<li>The BASIC warm reset vector trick</li>
</ul>
<h3 id="the-stack-trick">The stack trick</h3>
<p>The trick is to stomp the CPU stack at <code>$01F8</code> with a value that points to our desired entry point. This is done by crafting a PRG that starts with a 16-bit pointer pointing to our code and loading the PRG into <code>$01F8</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb16-1" data-line-number="1">    * =<span class="bn"> $01F8</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    !<span class="dt">word</span> scroll - <span class="dv">1</span>  <span class="co">; overwrite stack</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="fu">scroll:</span>	<span class="bu">js</span>r <span class="dv">$</span>E8EA</a></code></pre></div>
<p>Once the BASIC loader (see <a href="https://www.pagetable.com/c64disasm/#F4A5">disassembly</a>) has finished loading and returns to its caller with <code>RTS</code>, instead of returning to whoever called LOAD, it returns right into our PRG.</p>
<h3 id="the-basic-warm-reset-vector-trick">The BASIC warm reset vector trick</h3>
<p>This is a little easier to explain by just looking at the PRG disassembly.</p>
<pre><code>02E6: 20 EA E8    JSR $E8EA
02E9: A4 D5       LDY $D5
02EB: A9 A0       LDA #$A0
02ED: 99 20 D0    STA $D020,Y
02F0: 91 D1       STA ($D1),Y
02F2: 9D B5 07    STA $07B5,X
02F5: E6 D6       INC $D6
02F7: 65 90       ADC $90
02F9: 85 90       STA $90
02FB: C6 D5       DEC $D5
02FD: 30 FE       BMI $02FD
02FF: 90 E7       BCC $02E8
0301: 4C E6 02    JMP $02E6</code></pre>
<p>Notice the last line (<code>JMP $02E6</code>). The JMP instruction starts at address <code>$0301</code> with the branch target stored in addresses <code>$0302-$0303</code>.</p>
<p>When this code is loaded into memory starting at address <code>$02E6</code>, a value of <code>$02E6</code> is written to addresses <code>$0302-$0303</code>. Well, location <code>$0302-$0303</code> has a special meaning: it contains a pointer to the “BASIC idle loop” (see <a href="http://sta.c64.org/cbm64mem.html">C64 memory map</a> for details). Loading the PRG overwrote this location with <code>$02E6</code> and so when the BASIC interpreter tries to jump to the idle loop after warm reset, it never enters the idle loop but instead ends up in the line renderer!</p>
<h3 id="other-basic-startup-related-tricks">Other BASIC startup related tricks</h3>
<p>Petri had discovered <a href="https://github.com/petrihakkinen/c64-lines/blob/master/main37.asm">another BASIC start trick</a> which allows injecting your own constants into the zeropage. In this method, you hand-craft your own tokenized BASIC start sequence and encode your constants into the BASIC program line number. The BASIC line number, ahem, your constants, will be stored in addresses <code>$39-$3A</code> upon entry. Very clever!</p>
<h2 id="trick-5-unconventional-control-flow">Trick 5: Unconventional control flow</h2>
<p>Here’s a somewhat simplified version of the x-loop that draws only a single line and then halts execution once the line is done:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb18-1" data-line-number="1">        lda #<span class="dv">39</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">        sta x1</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="fu">xloop:</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">        lda #<span class="dv">$</span>a0</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">        ldx x1</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">        <span class="bu">adc</span> yf</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">        sta yf</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">        bcc no_scroll</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">        <span class="co">; scroll screen up!</span></a>
<a class="sourceLine" id="cb18-12" data-line-number="12">        <span class="bu">js</span>r <span class="dv">$</span>e8ea</a>
<a class="sourceLine" id="cb18-13" data-line-number="13"><span class="fu">no_scroll:</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">        <span class="bu">dec</span> x1</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">        bpl xloop</a>
<a class="sourceLine" id="cb18-16" data-line-number="16"></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">        <span class="co">; intentionally halt at the end</span></a>
<a class="sourceLine" id="cb18-18" data-line-number="18"><span class="fu">inf:</span>    <span class="bu">jmp</span> inf</a></code></pre></div>
<p>This has a bug in it, though. When we’ve drawn the last pixel of a line, we should NOT scroll the screen up anymore. Thus we need more branching to skip scrolling on the last pixel write:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb19-1" data-line-number="1">        lda #<span class="dv">39</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">        sta x1</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="fu">xloop:</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">        lda #<span class="dv">$</span>a0</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">        ldx x1</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb19-7" data-line-number="7"></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">        <span class="bu">dec</span> x1</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">        <span class="co">; skip scrolling if last pixel</span></a>
<a class="sourceLine" id="cb19-10" data-line-number="10">        bmi done</a>
<a class="sourceLine" id="cb19-11" data-line-number="11"></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">        <span class="bu">adc</span> yf</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">        sta yf</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">        bcc no_scroll</a>
<a class="sourceLine" id="cb19-15" data-line-number="15">        <span class="co">; scroll screen up!</span></a>
<a class="sourceLine" id="cb19-16" data-line-number="16">        <span class="bu">js</span>r <span class="dv">$</span>e8ea</a>
<a class="sourceLine" id="cb19-17" data-line-number="17"><span class="fu">no_scroll:</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18">        <span class="bu">jmp</span> xloop</a>
<a class="sourceLine" id="cb19-19" data-line-number="19"><span class="fu">done:</span></a>
<a class="sourceLine" id="cb19-20" data-line-number="20"></a>
<a class="sourceLine" id="cb19-21" data-line-number="21">        <span class="co">; intentionally halt at the end</span></a>
<a class="sourceLine" id="cb19-22" data-line-number="22"><span class="fu">inf:</span>    <span class="bu">jmp</span> inf</a></code></pre></div>
<p>The control flow looks a lot like what a C compiler would output from a structured program. The code to skip the last scroll introduced a new <code>JMP abs</code> instruction that takes up 3 bytes. Conditional branches are only two bytes as they encode the branch target using a relative 8-bit immediate.</p>
<p>The “skip last scroll” JMP can be avoided by moving the scroll up call to the top of the loop, and restructuring the control flow a bit. This is the pattern Philip had come up with:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb20-1" data-line-number="1">        lda #<span class="dv">39</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">        sta x1</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="fu">scroll:</span> <span class="bu">js</span>r <span class="dv">$</span>e8ea</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="fu">xloop:</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">        lda #<span class="dv">$</span>a0</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">        ldx x1</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        sta<span class="bn"> $0400 </span>+ <span class="dv">24</span>*<span class="dv">40</span>, x</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">        <span class="bu">adc</span> yf</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">        sta yf</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">        <span class="bu">dec</span> x1     <span class="co">; doesn&#39;t set carry!</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12"><span class="fu">inf:</span>    bmi inf    <span class="co">; hang here if last pixel!</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">        bcc xloop  <span class="co">; next pixel if no scroll</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">        bcs scroll <span class="co">; scroll up and continue</span></a></code></pre></div>
<p>This completely eliminates one 3 byte JMP and converts another JMP to a 2 byte conditional branch, saving 4 bytes in total.</p>
<h2 id="trick-6-bitpacked-line-drawing">Trick 6: Bitpacked line drawing</h2>
<p>Some of the entries didn’t use a line slope counter but rather they had bit-packed the line pattern into an 8-bit constant. This packing comes out of a realisation that the pixel position along the line follows a repeating 8 pixel pattern:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="dt">int</span> mask = <span class="bn">0xB6</span>; <span class="co">// 10110110</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="dt">uint8_t</span>* dst = screenRAM;</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="cf">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; <span class="dv">40</span>; x++) {</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    dst[x] = <span class="bn">0xA0</span>;</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    <span class="cf">if</span> (mask &amp; (<span class="dv">1</span> &lt;&lt; (x&amp;<span class="dv">7</span>))) {</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">        dst += <span class="dv">40</span>; <span class="co">// go down a row</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">}</a></code></pre></div>
<p>This translates to pretty compact assembly. The slope counter variants tended to be even smaller, though.</p>
<h2 id="winner-entry">Winner entry</h2>
<p>This is the <a href="https://github.com/fsphil/tinyx/blob/master/x34/x34.s">winning 34 byte entry</a> from Philip. Most of the above really comes together nicely in his code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb22-1" data-line-number="1">ov =<span class="bn"> $22 </span><span class="co">; == $40, initial value for the overflow counter</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">ct = <span class="dv">$</span>D5 <span class="co">; == $27 / 39, number of passes. Decrementing, finished at -1</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">lp = <span class="dv">$</span>D1 <span class="co">; == $07C0, pointer to bottom line. Set by the kernal scroller</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">        <span class="co">; Overwrite the return address of the kernal loader on the stack</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">        <span class="co">; with a pointer to our own code</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"></a>
<a class="sourceLine" id="cb22-8" data-line-number="8">        * =<span class="bn"> $01F8</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">        .<span class="dt">word</span> scroll - <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10"></a>
<a class="sourceLine" id="cb22-11" data-line-number="11"><span class="fu">scroll:</span> <span class="bu">js</span>r <span class="dv">$</span>E8EA    <span class="co">; Kernal scroll up, also sets lp pointer to $07C0</span></a>
<a class="sourceLine" id="cb22-12" data-line-number="12"><span class="bu">loop</span>:   ldy ct	     <span class="co">; Load the decrementing counter into Y (39 &gt; -1)</span></a>
<a class="sourceLine" id="cb22-13" data-line-number="13">        lda #<span class="dv">$</span>A0     <span class="co">; Load the PETSCII block / black col / ov step value</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">        sta <span class="dv">$</span>D020, y <span class="co">; On the last two passes, sets the background black</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15"><span class="fu">p1:</span>     sta<span class="bn"> $07C0    </span><span class="co">; Draw first block (left &gt; right line)</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">        sta (lp), y  <span class="co">; Draw second block (right &gt; left line)</span></a>
<a class="sourceLine" id="cb22-17" data-line-number="17">        <span class="bu">inc</span> p1 + <span class="dv">1</span>   <span class="co">; Increment pointer for the left &gt; right line</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">        <span class="bu">adc</span> ov	     <span class="co">; Add step value $A0 to ov</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">        sta ov</a>
<a class="sourceLine" id="cb22-20" data-line-number="20">        <span class="bu">dec</span> ct	     <span class="co">; Decrement the Y counter</span></a>
<a class="sourceLine" id="cb22-21" data-line-number="21">        bmi *	     <span class="co">; If it goes negative, we&#39;re finished</span></a>
<a class="sourceLine" id="cb22-22" data-line-number="22">        bcc <span class="bu">loop</span>     <span class="co">; Repeat. If ov didn&#39;t overflow, don&#39;t scroll</span></a>
<a class="sourceLine" id="cb22-23" data-line-number="23">        bcs scroll   <span class="co">; Repeat. If ov overflowed, scroll</span></a></code></pre></div>
<h2 id="why-stop-at-34-bytes-though">Why stop at 34 bytes, though?</h2>
<p>Once the competition was over, everyone shared code and notes, and a number of lively conversations took place on how to do even better. Several smaller variants were posted after the deadline:</p>
<ul>
<li><a href="https://gist.github.com/fsphil/05deaa06804b9b2054260b616cafed4b">Philip - 33 bytes</a></li>
<li><a href="https://gist.github.com/fsphil/01bda1a9dd58c219002ddd6e18b36c3f">Philip - 32 bytes</a></li>
<li><a href="https://github.com/petrihakkinen/c64-lines/blob/master/main31.asm">Petri - 31 bytes</a></li>
<li><a href="https://gist.github.com/fsphil/7655a394ec5f953c910e9d9369dced56">Philip - 29 bytes</a></li>
</ul>
<p>You should check them out – there are some real gems to be found.</p>
<p>…</p>
<p>Thanks for reading. And most of all, thanks Mathlev, Phil, Geir, Petri, Jamie, Jan and David for your participation. (I hope I didn’t miss anyone – it was really difficult to keep track of these in Twitter mentions!)</p>
<p>PS. Petri had named my compo “<span class="citation" data-cites="nurpax">@nurpax</span>’s annual C64 size optimization compo”, so uhm, see you next year, I guess.</p>]]></summary>
</entry>
<entry>
    <title>C64jasm object literals</title>
    <link href="http://nurpax.github.com/posts/2019-07-27-c64jasm-object-literals.html" />
    <id>http://nurpax.github.com/posts/2019-07-27-c64jasm-object-literals.html</id>
    <published>2019-07-27T00:00:00Z</published>
    <updated>2019-07-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The latest <a href="https://nurpax.github.io/c64jasm/">c64jasm</a> v0.6.0 added support for JavaScript style object literals. This turned out to be surprisingly useful! Here we’ll go over this feature and some tricks that it enables.</p>
<p>This post assumes you’re already familiar with the c64jasm assembler (see: <a href="https://nurpax.github.io/c64jasm/">c64jasm manual</a>).</p>
<h2 id="object-literals">Object literals</h2>
<p>An object in JavaScript and c64jasm is just a dict that maps keys to values. For example, in JavaScript:</p>
<pre><code>const options = {
    filename: &quot;main.asm&quot;,
    indent: 4
};</code></pre>
<p>The equivalent in c64jasm syntax would be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb2-1" data-line-number="1">!let options = {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="fu">    filename:</span> <span class="st">&quot;main.asm&quot;</span>,</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="fu">    indent:</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">}</a></code></pre></div>
<h2 id="how-is-this-useful-in-assembler">How is this useful in assembler?</h2>
<p>Turns out object literals can be quite useful for a few things:</p>
<ul>
<li>Named parameters for macro calls</li>
<li>Keeping track of zeropage addresses</li>
<li>Implicitly parametrize macro expansion</li>
</ul>
<p><strong>Named parameters</strong>: C64jasm supports only positional arguments in macro calls. However, just like in JavaScript, objects are a great substitute for named parameters:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb3-1" data-line-number="1">!<span class="pp">macro</span> clear_screen_named(args) {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    lda #args.clearByte</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    ldx #<span class="dv">0</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="bu">loop</span>:</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    !let screen = args.screen</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    sta screen, x</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    sta screen +<span class="bn"> $100, </span>x</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    sta screen +<span class="bn"> $200, </span>x</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    sta screen +<span class="bn"> $300, </span>x</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    inx</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    bne <span class="bu">loop</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">+clear_screen_named({ screen:<span class="bn"> $0400, </span>clearByte: <span class="dv">$</span>a0 })</a></code></pre></div>
<p><strong>Zero-page addresses</strong>: If you’ve written any decent amounts of 6502 assembly, you may have ran into problems keeping track of what’s in the zeropage. Perhaps you first started out by just keeping all the addresses in your head or code comments:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb4-1" data-line-number="1">    lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    sta<span class="bn"> $20    </span><span class="co">; sprite index</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    lda #<span class="dv">2</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    sta<span class="bn"> $21    </span><span class="co">; num sprites</span></a></code></pre></div>
<p>This is hard to read and easily breaks on modification. Instead, I tend to declare my zeropage allocation in variables:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb5-1" data-line-number="1">!let zp_sprite_idx =<span class="bn"> $20</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">!let zp_num_sprites =<span class="bn"> $21</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    sta zp_sprite_idx</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    lda #<span class="dv">2</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    sta zp_num_sprites</a></code></pre></div>
<p>You can express the above equivalently using an object literal:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb6-1" data-line-number="1">!let zp = {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="fu">    sprite_idx:</span><span class="bn"> $20,</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="fu">    num_sprites:</span><span class="bn"> $21</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    sta zp.sprite_idx</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    lda #<span class="dv">2</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    sta zp.num_sprites</a></code></pre></div>
<p>Turns out, the latter form combines well with macro expansion.</p>
<h2 id="macros-and-zeropage-temporaries">Macros and zeropage temporaries</h2>
<p>Consider the below <code>mul_imm</code> macro that multiplies a 16-bit value by 3. It needs 2 bytes of zeropage memory to hold a temporary value (<code>zp_tmp0</code>). It’s hardcoded to store the tempory in zeropage addresses <code>$20-$21</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb7-1" data-line-number="1">!<span class="pp">macro</span> add16(res, n1, n2) {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="bu">clc</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    lda n1</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="bu">adc</span> n2</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    sta res+<span class="dv">0</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    lda n1+<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="bu">adc</span> n2+<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    sta res+<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">!<span class="pp">macro</span> mul_imm(m, imm) {</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    !let zp_tmp0 =<span class="bn"> $20</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    !<span class="pp">if</span> (imm == <span class="dv">3</span>) {</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">        +add16(zp_tmp0, m, m)</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">        +add16(m, zp_tmp0, m)</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">    } <span class="pp">else</span> {</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">        !error <span class="st">&quot;only imm=3 is supported&quot;</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb7-20" data-line-number="20"></a>
<a class="sourceLine" id="cb7-21" data-line-number="21"><span class="fu">func:</span> {</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    +mul_imm(num1, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb7-23" data-line-number="23">}</a>
<a class="sourceLine" id="cb7-24" data-line-number="24"><span class="fu">irq_func:</span> {</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">    +mul_imm(num1, <span class="dv">3</span>)  <span class="co">; Ouch! Clobbers $20-21!</span></a>
<a class="sourceLine" id="cb7-26" data-line-number="26">}</a>
<a class="sourceLine" id="cb7-27" data-line-number="27"></a>
<a class="sourceLine" id="cb7-28" data-line-number="28"><span class="fu">num1:</span> !<span class="dt">word</span> <span class="dv">27</span></a></code></pre></div>
<p>What if the code calling this macro is also using zeropage <code>$20-$21</code>? The values in <code>$20-$21</code> will get clobbered by the macro. You also probably cannot use this macro in an IRQ as the IRQ might then clobber <code>$20-21</code> while your main code is running and using the same memory.</p>
<p>We could of course pass in a 3rd parameter <code>zp_tmp0</code> that’d specify the temp zeropage location. But this is ugly even with one 16-bit zeropage temp and only gets worse in macros needing many temporaries.</p>
<p>Let’s parametrize zeropage temp locations in <code>mul_imm</code> by adding a <code>zp</code> macro argument that holds the zeropage allocation:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb8-1" data-line-number="1">!<span class="pp">macro</span> mul_imm(zp, m, imm) {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    !<span class="pp">if</span> (imm == <span class="dv">3</span>) {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        +add16(zp.tmp0, m, m)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">        +add16(m, zp.tmp0, m)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="fu">func:</span> {</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    !let temps = { tmp0:<span class="bn"> $20 </span>}</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    +mul_imm(temps, num1, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="fu">irq_func:</span> {</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    !let temps = { tmp0:<span class="bn"> $40 </span>}</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    +mul_imm(temps, num1, <span class="dv">3</span>)  <span class="co">; OK, no clobber</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">}</a></code></pre></div>
<p>Better but still noisy.</p>
<p><del>Now here’s the kicker: we can drop the <code>zp</code> argument from <code>mul_imm</code> declaration and rely on a convention that <code>zp</code> is passed implicitly in the enclosing scope at the macro call site.</del></p>
<p><del>In code:</del></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">; no &#39;zp&#39; arg here, rely on it being in scope</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">!<span class="pp">macro</span> mul_imm(m, imm) {</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    !<span class="pp">if</span> (imm == <span class="dv">3</span>) {</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">        +add16(zp.tmp0, m, m)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">        +add16(m, zp.tmp0, m)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="co">; default zeropage temps</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">!let zp = { tmp0:<span class="bn"> $20 </span>}</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="fu">func:</span> {</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="co">; use default zp tmp0=$20</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">    +mul_imm(num1, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="fu">irq_func:</span> {</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    <span class="co">; override zp with tmp0=$40 within irq_func</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    !let zp = { tmp0:<span class="bn"> $40 </span>}</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    +mul_imm(num1, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">}</a></code></pre></div>
<p><strong>Update 2019-08-09</strong>: Implicit parameters by the sort of “dynamic scoping” shown here does not work as of c64jasm 0.7.0. When a macro is expanded, any symbols in the macro will use bindings from where the macro was declared, not where it’s expanded. Use global variables instead. See <a href="https://gist.github.com/nurpax/5aeaba58e359c6d040a9e0f87fa68ab9">this gist</a> for an example on how to do this cleanly.</p>
<h2 id="wrap-up">Wrap-up</h2>
<p>This post walked through a couple of tricks that became possible in the latest c64jasm v0.6.0 release. If you’re feeling adventurous, read more <a href="https://nurpax.github.io/c64jasm/">here</a>. Or <a href="https://nurpax.github.io/c64jasm-browser/">try it in your browser</a>!</p>]]></summary>
</entry>
<entry>
    <title>Loading sprites, PETSCII and SID with C64jasm</title>
    <link href="http://nurpax.github.com/posts/2019-06-06-c64jasm-content-example.html" />
    <id>http://nurpax.github.com/posts/2019-06-06-c64jasm-content-example.html</id>
    <published>2019-06-06T00:00:00Z</published>
    <updated>2019-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post is a walkthrough of a small assembly example project for <a href="https://nurpax.github.io/c64jasm/">c64jasm</a>. The example project was written to illustrate the use of following types of assets in an assembly program:</p>
<ul>
<li>PETSCII (using <a href="https://nurpax.github.io/petmate/">Petmate</a> .json exported files)</li>
<li>Sprites (authored in <a href="http://spritemate.com/">Spritemate</a>, saved as .spd v2.0)</li>
<li>SID music files</li>
</ul>
<p>Project source code can be found in the c64jasm git repo under the <a href="https://github.com/nurpax/c64jasm/tree/master/examples/content-pipe">examples/content-pipe</a> folder.</p>
<p>This post is focused on consuming above file formats in c64jasm code and is not intended to be a tutorial on 6502 machine language.</p>
<p>To compile the app, ensure you have c64jasm installed (see <a href="https://nurpax.github.io/c64jasm/">c64jasm</a> for instructions) and do:</p>
<pre><code>git clone https://github.com/nurpax/c64jasm
cd c64jasm/examples/content-pipe
c64jasm --out demo.prg src/main.asm     # assemble
x64 demo.prg                            # run it in vice</code></pre>
<p>The resulting program should look something like this on a C64:</p>
<p><img width="100%" class="img-pixelated" src="/images/c64/c64jasm/c64jasm-starter-example.png" /></p>
<h1 id="file-overview">File overview</h1>
<pre><code>.vscode/            VSCode project
  launch.json       Running/debugging the output .prg on VICE
  tasks.json        Compiling

src/                All source files (.asm, .js) and assets
  main.asm          Entry point &amp; most code
  macros.asm        Re-usable macro definitions
  pet_rle.asm       PETSCII RLE decompression routine

  assets/           .spd, .json, .sid files

  plugins/          c64jasm extensions written in JavaScript
    math.js         Generic math stuff like sine LUT generation
    petscii.js      Petmate .json reader + RLE packer
    spd.js          SpritePad 2.0 .spd loader
    sid.js          SID loader</code></pre>
<h1 id="loading-sid-tunes-with-c64jasm">Loading SID tunes with c64jasm</h1>
<p><em>Note: I’ve written a longer blog post about c64jasm’s design goals. You can read it <a href="https://nurpax.github.io/posts/2018-11-08-c64jasm.html">here</a>.</em></p>
<p>Perhaps you noticed some JavaScript .js files in the file listing above? These are JavaScript modules that are callable by assembler pseudo directives.</p>
<p>Rather than using makefiles and a lot of assembler built-in functionality (say SID loading, RNG, math functions), you express your content transformations in JavaScript and glue everything together using c64jasm’s pseudo directives.</p>
<p>Let’s take a look at a concrete example of loading and using a SID tune. In order to use a SID tune in an assembly program, you need the following bits:</p>
<ul>
<li>Extract some header information from a .sid file to work out its expected loading address</li>
<li>Extract the actual SID player and emit it in your output PRG at the right address</li>
<li>Map the tune <code>init</code> and <code>play</code> functions to some assembly symbols that you can <code>jsr</code> into</li>
</ul>
<p>To load and extract the header bits from a SID tune, I use the following code.</p>
<p><a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/plugins/sid.js">examples/content-pipe/src/plugins/sid.js</a>:</p>
<pre><code>function readWord(buf, offs) {
    return buf.readUInt8(offs) + (buf.readUInt8(offs+1) &lt;&lt; 8);
}

function readWordBE(buf, offs) {
    return (buf.readUInt8(offs)&lt;&lt;8) + buf.readUInt8(offs+1);
}

module.exports = ({readFileSync, resolveRelative}, filename) =&gt; {
    const buf = readFileSync(resolveRelative(filename));
    const version = readWordBE(buf, 4);
    const dataOffset = readWordBE(buf, 6);
    const startAddress = readWord(buf, dataOffset);
    const init = readWordBE(buf, 0x0a);
    const play = readWordBE(buf, 0x0c);
    const res = {
        startAddress,
        data: [...buf.slice(dataOffset+2)],
        init: startAddress,
        play: startAddress + 3
    }
    return res;
}</code></pre>
<p>The code reads a SID file, extracts its headers and returns the relevant bits as a JavaScript object. Here’s what a typical return value might look like for the above function:</p>
<pre><code>{ startAddress: 4096,
  data: [ 76, 169, 16, 76, 177, 16, ... 2239 more items ],
  init: 4096,
  play: 4099
}</code></pre>
<p>Let’s break it down:</p>
<ul>
<li><code>startAddress</code> is the memory location where the SID needs to be placed (usually <code>$1000</code>)</li>
<li><code>data</code> is an array containing the tune data and the player</li>
<li><code>init</code> is the tune init function address (call this with <code>jsr</code>)</li>
<li><code>play</code> is what you <code>jsr</code> every frame to playback music</li>
</ul>
<p>To use this in an assembly program, here’s what you need to do (this goes into an .asm file, see <a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/main.asm">examples/content-pipe/src/main.asm</a>):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">; Load the JavaScript sid loader module and bind it to `sid`</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">; (&quot;plugins/sid&quot; refers to ./src/plugins/sid.js)</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">!use <span class="st">&quot;plugins/sid&quot;</span> as sid</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co">; Call the sid loader, bind the return JavaScript object to</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="co">; the `music` variable.  The object fields such as `init`,</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co">; `startAddress`, `play` can be accessed by the dot-operator</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="co">; like `music.init`.</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">!let music = sid(<span class="st">&quot;assets/Load_Line.sid&quot;</span>)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="co">;....</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="fu">start_demo:</span> {</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="co">; Initialize sub-tune 0</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">    <span class="bu">js</span>r music.init</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    <span class="co">; if SID is at $1000, `music.init` will expand to $1000</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb5-18" data-line-number="18"></a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="fu">per_frame:</span> {</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    <span class="bu">js</span>r music.play    <span class="co">; e.g., JSR $1003</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">}</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"></a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="co">; Emit the SID player and tune data into the output binary</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">* = music.startAddress</a>
<a class="sourceLine" id="cb5-25" data-line-number="25"><span class="fu">sid_data:</span> !<span class="dt">byte</span> music.<span class="bu">data</span></a></code></pre></div>
<p>The last line with the <code>!byte</code> directive may not be immediately obvious if you’re used to <code>!byte &lt;expr&gt;</code> always emitting just a single byte. The <code>!byte</code> directive in c64jasm supports array arguments – <code>!byte some_array_value</code> will loop over the array emitting a byte for each element. For example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">; Let&#39;s assume data_array is an array of [0,1,2,3]</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="co">; The below two lines are equivalent</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">!<span class="dt">byte</span> data_array</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">!<span class="dt">byte</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="co">; You can also write it as an explicit for-loop over the</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="co">; values in `data_array`:</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">!for b <span class="bu">in</span> data_array {</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    !<span class="dt">byte</span> b</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">}</a></code></pre></div>
<h1 id="importing-petscii-graphics">Importing PETSCII graphics</h1>
<p>This sections explains how to pull PETSCII graphics authored in <a href="https://nurpax.github.io/petmate/">Petmate</a> into your program. Petmate supports a number of different export formats, but we will be using Petmate’s JSON export format. It’s accessible from Petmate’s <em>File / Export As / JSON (.json)</em> menu. This format is intended to be consumed by scripts written in say Python or JavaScript.</p>
<p>A Petmate exported JSON file would look something like this:</p>
<pre><code>{
    &quot;version&quot;: 1,
    &quot;framebufs&quot;: [
        {
            &quot;width&quot;: 40,
            &quot;height&quot;: 25,
            &quot;backgroundColor&quot;: 0,
            &quot;borderColor&quot;: 0,
            &quot;charset&quot;: &quot;upper&quot;,
            &quot;name&quot;: &quot;screen_003&quot;,
            &quot;screencodes&quot;: [ /* width*height bytes */ ],
            &quot;colors&quot;: [ /* width*height bytes */ ]
        }
    ]
}</code></pre>
<p>Suppose you wanted to include the screencodes for a PETSCII JSON file called <code>foo.json</code>, here’s how you’d express that in assembly code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">; Load a JSON file using the c64jasm&#39;s built-in `loadJson` function</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">!let petscii = loadJson(<span class="st">&quot;foo.json&quot;</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="co">; Emit a screencode array into the compiled program</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="fu">petscii_screencodes:</span> !<span class="dt">byte</span> petscii.framebufs[<span class="dv">0</span>].screencodes</a></code></pre></div>
<p>But that’s.. too easy. 😉</p>
<p>The example project does something more complicated to illustrate the expressiveness of c64jasm JavaScript extensions.</p>
<p>Rather than simply loading a JSON file and returning it, the code in <a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/plugins/petscii.js">examples/content-pipe/src/plugins/petscii.js</a> loads the input JSON file and RLE compresses it to save some RAM.</p>
<p>Here’s how this extension is used in assembly code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb9-1" data-line-number="1">!use <span class="st">&quot;plugins/petscii&quot;</span> as petscii</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">!let petscii_background = petscii.rlePetsciiJson(<span class="st">&quot;assets/pipes-pet.json&quot;</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">; Emit the RLE compressed PETSCII bytes (both screencodes and color)</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="fu">background_petscii_rle:</span> !<span class="dt">byte</span> petscii_background.interleaved</a></code></pre></div>
<p>Source file <a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/pet_rle.asm">examples/content-pipe/src/pet_rle.asm</a> contains an implementation of a RLE decoder that can be used to display a PETSCII screen on the C64 screen. All the symbols in this file are wrapped in a scope named <code>pet_rle</code> using the <code>!filescope</code> directive, so to use the <code>decode</code> function from another <code>.asm</code> file, you need to use a scope qualifier <code>pet_rle::decode</code> to refer to the decoder function.</p>
<p>Let’s piece all this together:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb10-1" data-line-number="1">!use <span class="st">&quot;plugins/petscii&quot;</span> as petscii</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">!let petscii_background = petscii.rlePetsciiJson(<span class="st">&quot;assets/pipes-pet.json&quot;</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">!<span class="bu">include</span> <span class="st">&quot;pet_rle.asm&quot;</span>  <span class="co">; include RLE decoder (e.g., pet_rle::decode)</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="fu">show_petscii:</span> {</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="co">; Decompress a PETSCII image on the display</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    sta <span class="dv">$</span>d020</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    sta <span class="dv">$</span>d021</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    lda #&lt;background_petscii_rle</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    ldx #&gt;background_petscii_rle</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    <span class="bu">js</span>r pet_rle::decode</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">    rts</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb10-16" data-line-number="16"></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="fu">background_petscii_rle:</span> !<span class="dt">byte</span> petscii_background.interleaved</a></code></pre></div>
<p>What’s great about this approach is you don’t need a separate build step to process your assets into compressed RLE with, say, Python and makefiles. Instead, loading and compressing PETSCII happens as part of your normal assembly compile step.</p>
<h1 id="using-spritemate-authored-sprites">Using Spritemate authored sprites</h1>
<p>Next up, sprite graphics!</p>
<p>I used <a href="http://spritemate.com/">Spritemate</a> to draw sprites. Spritemate is a free, web-based C64 sprite editor written by <a href="https://twitter.com/awsm9000">@awsm9000</a>. Spritemate supports saving SpritePad .spd v2.0 files which is what we’ll use here.</p>
<p>As in the other sections, we need a JavaScript module to load and parse an .spd file, and some assembly code to do something with it.</p>
<p>Let’s take a look at the JavaScript .spd loader first.</p>
<p><a href="https://github.com/nurpax/c64jasm/blob/master/examples/content-pipe/src/plugins/spd.js">examples/content-pipe/src/plugins/spd.js</a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">// File format detailed in https://csdb.dk/forums/?roomid=7&amp;topicid=125812</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> (<span class="op">{</span>readFileSync<span class="op">,</span> resolveRelative<span class="op">},</span> filename) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">const</span> buf <span class="op">=</span> <span class="at">readFileSync</span>(<span class="at">resolveRelative</span>(filename))<span class="op">;</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="kw">const</span> numSprites <span class="op">=</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(<span class="dv">4</span>)<span class="op">+</span><span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    <span class="kw">const</span> data <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numSprites<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        <span class="kw">const</span> offs <span class="op">=</span> i<span class="op">*</span><span class="dv">64</span><span class="op">+</span><span class="dv">9</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="kw">const</span> bytes <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">        <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">64</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">            <span class="va">bytes</span>.<span class="at">push</span>(<span class="va">buf</span>.<span class="at">readUInt8</span>(offs <span class="op">+</span> j))<span class="op">;</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">        <span class="op">}</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        <span class="va">data</span>.<span class="at">push</span>(bytes)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        numSprites<span class="op">,</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16">        <span class="dt">multicol1</span><span class="op">:</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(<span class="dv">7</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17">        <span class="dt">multicol2</span><span class="op">:</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(<span class="dv">8</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">        data</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">    <span class="op">};</span></a>
<a class="sourceLine" id="cb11-20" data-line-number="20"><span class="op">}</span></a></code></pre></div>
<p>This loads an .spd file, looks at the header information and returns an object describing file contents. The important fields are:</p>
<ul>
<li><code>numSprites</code>: how many sprites does the file contain</li>
<li><code>multicol1</code>, <code>multicol2</code>: multicolor colors used for the sprites</li>
<li><code>data</code>: an array of shape <code>[numSprites][64]</code> containing actual pixel data</li>
</ul>
<p>The importer is hardcoded for multicolor sprites, but it wouldn’t be too hard to extend it to support single color too.</p>
<p>Here’s how to use it in assembly code:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb12-1" data-line-number="1">!use <span class="st">&quot;plugins/spd&quot;</span> as spd   <span class="co">; .spd loader</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">!let pacman_spd = spd(<span class="st">&quot;assets/pacman.spd&quot;</span>)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="fu">show_sprites:</span> {</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    <span class="co">; point all 8 sprites to pacman</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    lda #sprite_data/<span class="dv">64</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">!for i <span class="bu">in</span> range(<span class="dv">8</span>) {</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    sta<span class="bn"> $07f8 </span>+ i</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    <span class="co">; set multicolor registers</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    lda #pacman_spd.multicol1</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    sta <span class="dv">$</span>d025</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    lda #pacman_spd.multicol2</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">    sta <span class="dv">$</span>d026</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">    <span class="co">; ...</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">    rts</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">}</a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20">!<span class="bu">align</span> <span class="dv">64</span> <span class="co">; sprites must be 64-byte aligned</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21"><span class="fu">sprite_data:</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22">!<span class="dt">byte</span> pacman_spd.<span class="bu">data</span>[<span class="dv">0</span>]</a></code></pre></div>
<h1 id="wrap-up">Wrap up</h1>
<p>We looked at importing various common graphics and sound formats into a C64 assembly program.</p>
<p>You might want to <a href="https://nurpax.github.io/c64jasm/">read more about c64jasm</a> if you’re like me and enjoy writing code in an environment that comes with:</p>
<ul>
<li>Declarative build process (no manual tracking down of build dependencies, no makefiles)</li>
<li>Good VSCode integration (run &amp; debug from VSCode, VSCode syntax highlighting, error reporting within the editor)</li>
<li>Fast “Node style” watched builds: have the compiler watch your source dir and automatically trigger a rebuild as soon as any of the input source files changed</li>
<li>Just generally feeling adventurous and wanting to do things in a non-standard way</li>
</ul>
<p>BTW, if you missed my recent C64 demo, you can <a href="https://csdb.dk/release/?id=178389">download it</a> / <a href="https://www.youtube.com/watch?v=UPlS2L9lF4k">watch it here</a>. It’s also developed with c64jasm.</p>]]></summary>
</entry>
<entry>
    <title>C64jasm - a new take on C64 macro assembling</title>
    <link href="http://nurpax.github.com/posts/2018-11-08-c64jasm.html" />
    <id>http://nurpax.github.com/posts/2018-11-08-c64jasm.html</id>
    <published>2018-11-08T00:00:00Z</published>
    <updated>2018-11-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>For the past couple of months I’ve worked on the C64 <a href="https://csdb.dk/release/?id=171134">VISIO 2018 invitation intro</a> (YouTube capture at the bottom of this post). I upped the difficulty level a bit by first designing and implementing a new 6502 macro assembler called <a href="https://github.com/nurpax/c64jasm">c64jasm</a>, and then using that to develop my demo. While I haven’t had the time to polish the assembler to, say, KickAssembler level, my tool turned out to be a real joy to work with. This post highlights some of its features that I believe make it somewhat unique in its small niche.</p>
<p>These were my initial design choices for c64jasm:</p>
<ul>
<li>Written in TypeScript &amp; running on Node. Easy multi-platform environment with easy to install dependencies.</li>
<li>Ability to extend the assembler’s functionality by calling into user-defined JavaScript modules directly from the .asm source.</li>
<li>A sufficiently powerful pseudo language (macros, conditionals, for-loops, etc) but build on the JavaScript extension mechanism for more complex pseudo ops like LUT creation and file format parsing.</li>
<li>Node-style “watch” support: automatically recompile if any source files change. Design it for efficiency.</li>
<li>VSCode integration (for on-the-fly compilation and error reporting within the IDE, launch output binary in VICE.)</li>
</ul>
<p>The choice of TypeScript was very deliberate. I’ve been meaning to learn the language for quite some time, and developing a macro assembler in it was a good way to learn &amp; evaluate TypeScript. TypeScript turned out to be a great language: supports functional programming style well (and so well-suited for developing compilers) and has a simple but powerful static typing system.</p>
<p>The assembler extension mechanism is the main feature that differentiates c64jasm from traditional 6502 macro assemblers and I’ll spend the rest of this blog talking about this mechanism.</p>
<p>This blog post assumes that you’re at least somewhat familiar with macro assemblers and that you know a bit of JavaScript.</p>
<h2 id="why-do-i-need-to-extend-my-assembler">Why do I need to extend my assembler?</h2>
<p>So why does one need to extend the assembler in the first place? I have my assembly, macros and other pseudo directives, isn’t this enough? Well, you need all of these too. But some things like loading graphics files, generating lookup tables, etc. can be better expressed in a real programming language. Quite commonly a demo project is built using a build script that processes LUTs, graphics, and other assets into hex listings to be included in the main assembly source.</p>
<h2 id="extending-functionality">Extending functionality</h2>
<p>Traditionally, extending the functionality of an application or a tool means that you’d first need to learn the app’s extension API, figure out how to build your extension (say .DLLs or a Java .jar file), install it (and maybe debug your PATH or CLASSPATH when it fails to load), and once all done, the feature becomes available in your tool and you use it to develop your content.</p>
<p>The approach I took in c64jasm is that assembler extensions are just a bunch of source files in your project’s source directory. Extensions shouldn’t require a separate build or installation step and the overhead of creating a new one for any specific purpose should be minimal. Ideally the extensions should be runnable stand-alone without the assembler and that you should be able to debug and test them using standard debugging tools.</p>
<p>Before we get deeper into c64jasm assembler plugins, let’s review some of the c64jasm pseudo directives.</p>
<h2 id="c64jasm-pseudo-ops">C64jasm pseudo ops</h2>
<p>If you’ve used something like KickAssembler, ACME or 64tass, these should look pretty familiar.</p>
<p>Declaring pseudo variables: You can declare pseudo variables using <code>!let</code>. This is basically the same as KickAssembler’s <code>.const</code>/<code>.var</code> (many other assemblers commonly have this as <code>EQU</code>.)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">; declaring variables</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">!let after_bounce_frames = <span class="dv">64</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">!let sprite_writer_path_tablen = <span class="dv">128</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co">; assigning a new value to a previously declared variable</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">after_bounce_frames = <span class="dv">33</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="co">; using the variables in immediates</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    sec</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    sbc #sprite_writer_path_tablen</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="bu">cmp</span> #after_bounce_frames</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    bcs do_wrap</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="bu">jmp</span> no_wrap</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="fu">do_wrap:</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="bu">jmp</span> wrap</a></code></pre></div>
<p>Macros:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">some_mem_loc:</span> !<span class="dt">byte</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">; declare a macro to write an immediate value to memory</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">!<span class="pp">macro</span> mov8imm(d, imm) {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    lda #imm</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    sta d+<span class="dv">0</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">; expand the macro</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">+mov8imm(some_mem_loc, #<span class="dv">$80</span>)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co">; this will emit the following code:</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">;</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="co">;    lda #$80</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="co">;    sta some_mem_loc</span></a></code></pre></div>
<p>Symbols declared within a macro are local to that macro. You can also declare macros within macros.</p>
<p>If/elif/else:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb3-1" data-line-number="1">!let double_y = <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">!<span class="pp">if</span> (double_y) {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    ldy #yy*<span class="dv">6</span>+<span class="dv">1</span>         <span class="co">; code from this path</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    sta (zpdst_even),y  <span class="co">; will be emitted</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    sta (zpdst_odd),y</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    txa</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    dey</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    sta (zpdst_even),y</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    sta (zpdst_odd),y</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">} <span class="pp">else</span> {</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    ldy #yy*<span class="dv">3</span>+<span class="dv">1</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    sta (zpdst_even),y</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    txa</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    dey</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    sta (zpdst_even),y</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">}</a></code></pre></div>
<p>For-loops:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">; emit 8 nops</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">!for i <span class="bu">in</span> range(<span class="dv">0</span>, <span class="dv">8</span>) {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="bu">nop</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">}</a></code></pre></div>
<p>As opposed to a C-style “declare loop variable, check condition, increment” for loops, c64jasm’s <code>for</code> is similar to Python’s for-statement. You use a function called <code>range()</code> that returns a list of integers and the for-loop just iterates over the elements of this list, assigning the current list element to the bound loop variable <code>i</code>. E.g., these two are conceptually the same:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">; emit four NOPs</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">!for i <span class="bu">in</span> range(<span class="dv">4</span>) {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="bu">nop</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">!for i <span class="bu">in</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] {</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="bu">nop</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">}</a></code></pre></div>
<p>The “emit byte” pseudo <code>!byte</code> supports emitting a list of bytes when passed an integer list. The following two lines are equivalent:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb6-1" data-line-number="1">!<span class="dt">byte</span> range(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">!<span class="dt">byte</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span></a></code></pre></div>
<h2 id="c64jasm-extensions">C64jasm extensions</h2>
<p>So with the basic c64jasm pseudo ops explained, let’s continue to c64jasm extensions. A c64jasm extension is just a JavaScript .js module. To use such a .js module in your assembly source, you bind it to a name with <code>!use &quot;path/to/plugin.js&quot;</code>. This name becomes a function that you can call in your assembly source file.</p>
<p>Let’s illustrate this with some code to generate a sine lookup table. First the plugin code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" data-line-number="1"># <span class="va">sintab</span>.<span class="at">js</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> (<span class="op">{},</span> len<span class="op">,</span> scale) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="kw">const</span> res <span class="op">=</span> <span class="at">Array</span>(len).<span class="at">fill</span>(<span class="dv">0</span>).<span class="at">map</span>((v<span class="op">,</span>i) <span class="op">=&gt;</span> <span class="va">Math</span>.<span class="at">sin</span>(i/len <span class="op">*</span> <span class="va">Math</span>.<span class="at">PI</span> <span class="op">*</span> <span class="fl">2.0</span>) <span class="op">*</span> scale)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="cf">return</span> res<span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="op">}</span></a></code></pre></div>
<p>Here’s how you’d use the above in your .asm source file:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">; Bind sintab.js default export to a pseudo function &#39;mkSintab&#39;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">!use <span class="st">&quot;./sintab&quot;</span> as mkSintab</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">!let sin1scale = <span class="dv">26</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="fu">sintab1:</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">!for s <span class="bu">in</span> mkSintab(<span class="dv">256</span>, sin1scale) {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    !<span class="dt">byte</span> s</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">}</a></code></pre></div>
<p>As <code>!byte</code> and <code>!word</code> accept a list as an argument, the above can be written simply as:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">sintab1:</span> !<span class="dt">byte</span> mkSintab(<span class="dv">256</span>, sin1scale)</a></code></pre></div>
<p>The nice thing about this approach is that I can keep the assembler implementation simple. The assembler doesn’t need a large standard library of math and other utility functions as this functionality can be easily expressed as tiny JavaScript modules.</p>
<p>Sure, generating a sine table would be pretty easy without an extension too (and this is totally supported by c64jasm):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">sintab1:</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">   !for s <span class="bu">in</span> range(<span class="dv">0</span>, <span class="dv">256</span>) {</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">       !<span class="dt">byte</span> sin(s/<span class="dv">256</span>*<span class="dv">2</span>*PI)*scl</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">   }</a></code></pre></div>
<p>Where I find the JavaScript extension mechanism really shines is importing assets (sprites from .spd, .sid, etc.). Here’s how I compile SpritePad .spd files into my demo binary:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" data-line-number="1"># <span class="va">spd</span>.<span class="at">js</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> (<span class="op">{</span>readFileSync<span class="op">,</span> resolveRelative<span class="op">},</span> filename) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">const</span> buf <span class="op">=</span> <span class="at">readFileSync</span>(<span class="at">resolveRelative</span>(filename))<span class="op">;</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="kw">const</span> numSprites <span class="op">=</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(<span class="dv">4</span>)<span class="op">+</span><span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    <span class="kw">const</span> data <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> numSprites<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        <span class="kw">const</span> offs <span class="op">=</span> i<span class="op">*</span><span class="dv">64</span><span class="op">+</span><span class="dv">9</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="kw">const</span> bytes <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">        <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">64</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">            <span class="va">bytes</span>.<span class="at">push</span>(<span class="va">buf</span>.<span class="at">readUInt8</span>(offs <span class="op">+</span> j))<span class="op">;</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">        <span class="op">}</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">        <span class="va">data</span>.<span class="at">push</span>(bytes)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        numSprites<span class="op">,</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16">        <span class="dt">enableMask</span><span class="op">:</span> (<span class="dv">1</span><span class="op">&lt;&lt;</span>numSprites)<span class="op">-</span><span class="dv">1</span><span class="op">,</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17">        <span class="dt">bg</span><span class="op">:</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(<span class="dv">6</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">        <span class="dt">multicol1</span><span class="op">:</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(<span class="dv">7</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-19" data-line-number="19">        <span class="dt">multicol2</span><span class="op">:</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(<span class="dv">8</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb11-20" data-line-number="20">        data</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">    <span class="op">};</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="op">}</span></a></code></pre></div>
<p>Using the above in an .asm file:</p>
<pre><code>!use &quot;./spd&quot; as spd

; Load &#39;hirmu.spd&#39; and store the returned JavaScript object in a
; variable called &#39;hirmu_sprite&#39;
!let hirmu_sprite = spd(&quot;../sprites/hirmu.spd&quot;)</code></pre>
<p>At this point, no code or bytes were yet emittted. The .spd file contents are now in a pseudo variable called <code>hirmu_sprite</code>. This is just a JavaScript object with fields like <code>numSprites</code>, <code>enableMask</code>, <code>data</code> that can be accessed from .asm with the dot operator (e.g., <code>sprite_data.numSprites</code>.)</p>
<p>With this, I can expand the sprite data into the output binary. Or I can use to emit code to setup sprite registers (enable bits, individual and multi color values, etc).</p>
<p>Emitting actual sprite data for all the sprites contained within the .spd file:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">hirmu_sprite_data:</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    <span class="co">; loop over all the sprites in hirmu_sprite.data</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    !for sdata <span class="bu">in</span> hirmu_sprite.<span class="bu">data</span> {</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">        !<span class="dt">byte</span> sdata  <span class="co">; expand 64 bytes of sprite data (one sprite)</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="co">; or equivalently:</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    <span class="co">; !for sidx in range(hirmu_sprite.numSprites) {</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    <span class="co">;    !byte hirmu_sprite.data[sidx]  ; expand 64 bytes of sprite data (one sprite)</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    <span class="co">; }</span></a></code></pre></div>
<p>I also define a macro that expands machine code to write sprite registers based on the .spd file contents:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb14-1" data-line-number="1">!<span class="pp">macro</span> set_sprite(s, <span class="dt">ptr</span>, xScale, yScale) {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    !<span class="pp">if</span> (xScale == <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">        lda #s.enableMask</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    } <span class="pp">else</span> {</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">        lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    sta <span class="dv">$</span>d01d  <span class="co">; XSCALE register</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    !<span class="pp">if</span> (yScale == <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">        lda #s.enableMask</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    } <span class="pp">else</span> {</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">        lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb14-14" data-line-number="14">    sta <span class="dv">$</span>d017  <span class="co">; YSCALE register</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15"></a>
<a class="sourceLine" id="cb14-16" data-line-number="16">    <span class="co">; set sprite pointers and individual sprite colors for</span></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">    <span class="co">; all sprites</span></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">    !for sprite_idx <span class="bu">in</span> range(<span class="dv">0</span>, s.numSprites) {</a>
<a class="sourceLine" id="cb14-19" data-line-number="19">        <span class="co">; load the individual color from sprite data</span></a>
<a class="sourceLine" id="cb14-20" data-line-number="20">        lda #s.<span class="bu">data</span>[sprite_idx][<span class="dv">63</span>]</a>
<a class="sourceLine" id="cb14-21" data-line-number="21">        <span class="co">; indiv sprite color</span></a>
<a class="sourceLine" id="cb14-22" data-line-number="22">        sta <span class="dv">$</span>d027 + sprite_idx</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">        lda #ptr/<span class="dv">64</span> + sprite_idx</a>
<a class="sourceLine" id="cb14-24" data-line-number="24">        sta<span class="bn"> $7f8 </span>+ sprite_idx</a>
<a class="sourceLine" id="cb14-25" data-line-number="25">    }</a>
<a class="sourceLine" id="cb14-26" data-line-number="26"></a>
<a class="sourceLine" id="cb14-27" data-line-number="27">    <span class="co">; enable multicolor for the same sprites, set multicolor values</span></a>
<a class="sourceLine" id="cb14-28" data-line-number="28">    lda #s.multicol1</a>
<a class="sourceLine" id="cb14-29" data-line-number="29">    sta <span class="dv">$</span>d025</a>
<a class="sourceLine" id="cb14-30" data-line-number="30">    lda #s.multicol2</a>
<a class="sourceLine" id="cb14-31" data-line-number="31">    sta <span class="dv">$</span>d026</a>
<a class="sourceLine" id="cb14-32" data-line-number="32"></a>
<a class="sourceLine" id="cb14-33" data-line-number="33">    <span class="co">; enable all the sprites that were loaded from the .spd</span></a>
<a class="sourceLine" id="cb14-34" data-line-number="34">    lda #s.enableMask</a>
<a class="sourceLine" id="cb14-35" data-line-number="35">    sta <span class="dv">$</span>d01c       <span class="co">; multicolor enable</span></a>
<a class="sourceLine" id="cb14-36" data-line-number="36">    sta <span class="dv">$</span>d015       <span class="co">; sprite enable</span></a>
<a class="sourceLine" id="cb14-37" data-line-number="37">}</a>
<a class="sourceLine" id="cb14-38" data-line-number="38"></a>
<a class="sourceLine" id="cb14-39" data-line-number="39"><span class="fu">set_hirmu_sprite:</span> {</a>
<a class="sourceLine" id="cb14-40" data-line-number="40">    +set_sprite(hirmu_sprite, hirmu_sprite_data, <span class="dv">2</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb14-41" data-line-number="41">    rts</a>
<a class="sourceLine" id="cb14-42" data-line-number="42">}</a></code></pre></div>
<p>I use the same pattern for all the different asset types used in my demo. Here’s how I pull the SID tune into the binary:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" data-line-number="1"># <span class="va">sid</span>.<span class="at">js</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">function</span> <span class="at">readWord</span>(buf<span class="op">,</span> offs) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="cf">return</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(offs) <span class="op">+</span> (<span class="va">buf</span>.<span class="at">readUInt8</span>(offs<span class="op">+</span><span class="dv">1</span>) <span class="op">&lt;&lt;</span> <span class="dv">8</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">// Read a big-endian word</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">function</span> <span class="at">readWordBE</span>(buf<span class="op">,</span> offs) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">    <span class="cf">return</span> (<span class="va">buf</span>.<span class="at">readUInt8</span>(offs)<span class="op">&lt;&lt;</span><span class="dv">8</span>) <span class="op">+</span> <span class="va">buf</span>.<span class="at">readUInt8</span>(offs<span class="op">+</span><span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"></a>
<a class="sourceLine" id="cb15-11" data-line-number="11"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> (<span class="op">{</span>readFileSync<span class="op">,</span> resolveRelative<span class="op">},</span> filename) <span class="op">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    <span class="kw">const</span> buf <span class="op">=</span> <span class="at">readFileSync</span>(<span class="at">resolveRelative</span>(filename))<span class="op">;</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    <span class="kw">const</span> version <span class="op">=</span> <span class="at">readWordBE</span>(buf<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">    <span class="kw">const</span> dataOffset <span class="op">=</span> <span class="at">readWordBE</span>(buf<span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">    <span class="kw">const</span> startAddress <span class="op">=</span> <span class="at">readWord</span>(buf<span class="op">,</span> dataOffset)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-16" data-line-number="16">    <span class="kw">const</span> init <span class="op">=</span> <span class="at">readWordBE</span>(buf<span class="op">,</span> <span class="bn">0x0a</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-17" data-line-number="17">    <span class="kw">const</span> play <span class="op">=</span> <span class="at">readWordBE</span>(buf<span class="op">,</span> <span class="bn">0x0c</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-18" data-line-number="18">    <span class="kw">const</span> numSongs <span class="op">=</span> <span class="at">readWord</span>(buf<span class="op">,</span> <span class="bn">0x0e</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-19" data-line-number="19">    <span class="kw">const</span> res <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-20" data-line-number="20">        startAddress<span class="op">,</span></a>
<a class="sourceLine" id="cb15-21" data-line-number="21">        <span class="dt">data</span><span class="op">:</span> [...<span class="va">buf</span>.<span class="at">slice</span>(dataOffset<span class="op">+</span><span class="dv">2</span>)]<span class="op">,</span></a>
<a class="sourceLine" id="cb15-22" data-line-number="22">        <span class="dt">init</span><span class="op">:</span> startAddress<span class="op">,</span></a>
<a class="sourceLine" id="cb15-23" data-line-number="23">        <span class="dt">play</span><span class="op">:</span> startAddress <span class="op">+</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb15-24" data-line-number="24">    <span class="op">}</span></a>
<a class="sourceLine" id="cb15-25" data-line-number="25">    <span class="cf">return</span> res<span class="op">;</span></a>
<a class="sourceLine" id="cb15-26" data-line-number="26"><span class="op">}</span></a></code></pre></div>
<p>Using the loaded SID tune from the .asm source:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb16-1" data-line-number="1">!use <span class="st">&quot;./sid&quot;</span> as sid</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">!let music = sid(<span class="st">&quot;sid/tune.sid&quot;</span>)</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="fu">demo_start:</span> {</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    lda #<span class="dv">0</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    <span class="bu">js</span>r music.init</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    ...</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    <span class="bu">js</span>r music.play      <span class="co">; usually called from an IRQ</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">* = music.startAddress  <span class="co">; usually music.startAddress == $1000</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="fu">music:</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">!<span class="dt">byte</span> music.<span class="bu">data</span></a></code></pre></div>
<p>All of these content plugins are just normal .js files that can be run from the command line with <code>node</code>. This enables you to use standard tools like VSCode to debug them as stand-alone JavaScript modules. I prefer this code to be part of the project source tree rather than buried somewhere within c64jasm’s standard libraries.</p>
<h2 id="epilogue">Epilogue</h2>
<p>OK, that’s about it for now on c64jasm plugins. I will probably write another blog later about using c64jasm in VSCode (with quick re-compile-on-save and launch .prg in VICE.) I <a href="https://twitter.com/nurpax/status/1049757222547451906">tweeted</a> about it a while ago, you can check out the video if you’re curious about this.</p>
<p>Oh by the way, <a href="https://github.com/nurpax/c64jasm">c64jasm</a> is available on GitHub and is already quite usable. However, it’s still very much work-in-progress. If you’re into this type of stuff and feeling adventurous, feel free to give it a try. Otherwise, stick with the more established C64 assemblers. :)</p>
<h2 id="visio-2018-invitation-demo-capture">VISIO 2018 invitation demo capture</h2>
<div class="youtube">
<iframe class="video" src="https://www.youtube.com/embed/Jr5DqTcFpf4?rel=0&amp;controls=1&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>]]></summary>
</entry>
<entry>
    <title>C64 tool tricks (VICE and others)</title>
    <link href="http://nurpax.github.com/posts/2018-08-23-vice-monitor-tricks.html" />
    <id>http://nurpax.github.com/posts/2018-08-23-vice-monitor-tricks.html</id>
    <published>2018-08-23T00:00:00Z</published>
    <updated>2018-08-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>A collection of random C64 tool tricks.</p>
<h1 id="vice">VICE</h1>
<h2 id="capturing-the-rom-charset">Capturing the ROM charset</h2>
<p>Make ROM visible to the monitor and save data from <code>$d000</code> onwards:</p>
<pre><code>bank rom
bs &quot;data.bin&quot; 0 $d000 $d7fff</code></pre>
<h1 id="using-exomizer-to-crunch-executables">Using exomizer to crunch executables</h1>
<h2 id="installation">Installation</h2>
<ol type="1">
<li>Download and extract <a href="https://bitbucket.org/magli143/exomizer/wiki/downloads/exomizer-3.0.2.zip">exomizer</a></li>
<li>Build it by</li>
</ol>
<pre><code>mkdir exomizer
cd exomizer
make -C src</code></pre>
<p>The command line tools will reside under the <code>src</code> directory.</p>
<h2 id="packing-a-.prg-file">Packing a .prg file</h2>
<p>To pack a .prg that uses the BASIC upstart sequence (SYS something), use:</p>
<pre><code>exomizer sfx sys input.prg -o output.prg -x3</code></pre>
<p>The <code>-x3</code> adds a border flashing decrunching effect. Drop that switch if you don’t want it.</p>]]></summary>
</entry>
<entry>
    <title>BINTRIS C64: Bad lines and flexible line distance (series part 5)</title>
    <link href="http://nurpax.github.com/posts/2018-06-19-bintris-on-c64-part-5.html" />
    <id>http://nurpax.github.com/posts/2018-06-19-bintris-on-c64-part-5.html</id>
    <published>2018-06-19T00:00:00Z</published>
    <updated>2018-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<p>(Looking for the BINTRIS C64 disk image? Find it <a href="/posts/2018-05-21-bintris-on-c64-part-2.html">here</a>.)</p>
<h2 id="introduction">Introduction</h2>
<p>This post discusses how BINTRIS uses YSCROLL manipulation to implement bad line suppression and full-screen vertical scrolling (flexible line distance, or FLD).</p>
<p>Here are the effects in action:</p>
<div class="img-columns-2">
<p class="img-column">
<img width="100%" class="img-pixelated" src="/images/bintris/bintris-writer-fld.gif" /><em>Vertical scrolling.</em>
</p>
<p class="img-column">
<img width="100%" class="img-pixelated" src="/images/bintris/bintris-logo-wobble.gif" /> <em>BINTRIS logo warp effect.</em>
</p>
</div>
<p>Note: all timing values in this post are for specific to PAL-B C64 models.</p>
<h2 id="bad-lines">Bad Lines</h2>
<p>To understand FLD, you need to grasp the concept of Bad Lines. I’ll summarize Bad Lines here but you can read about it in more detail in the excellent <a href="http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt">vic-ii.txt document</a> (section 3.5). The same document also explains FLD in section 3.14.2.</p>
<p>The VIC scans out the video frame line-by-line. Each line takes exactly 63 clock cycles. On normal lines, all these 63 cycles are available to the CPU. However, on every 8th pixel row (=start of a new character row), the VIC needs an extra 40 cycles to fetch a line of character codes from memory. When these fetches start, the CPU is “stunned”, meaning it won’t execute for about 40-43 clock cycles. These lines are called Bad Lines. On these lines, you have only 20-23 clock cycles to spend on your raster magic. With sprites, even less.</p>
<p>This might not be a big deal with timing insensitive code. But since the C64 is all about carefully crafted raster code, bad lines are something you just have to deal with.</p>
<p>To illustrate bad lines, I made this little interactive chart that shows the effect of bad lines. The little green boxes at the bottom represent the 63 cycles you have for a single line. The currently executing cycle is highlighted in white. A white dot over the C64 image is the raster beam. On normal lines, the CPU runs instructions on every cycle. But on bad lines, the CPU is stunned (black boxes) and cannot execute instructions.</p>
<div id="cycle-timing-container">
</div>
<p>When do the bad lines occur? Here’s the bad line condition in pseudo code:</p>
<pre><code>   if (RASTER &gt;= $30 &amp;&amp; RASTER &lt;= $f7) {
     if ((RASTER &amp; 7) == YSCROLL) {
       // BAD LINE
     }
   }</code></pre>
<p>where RASTER is the current scanline register (<code>$d011</code>/<code>$d012</code>) and YSCROLL is the vertical scroll register (bits 0-2 of <code>$d011</code>). (See the <a href="http://sta.c64.org/cbm64mem.html">C64 memory map</a> for details on these registers.)</p>
<p>Notice how the bad line condition depends on the YSCROLL register. Turns out, you can suppress or delay bad lines by manipulating the YSCROLL value at the right time. Recall the <code>(RASTER&amp;7)==YSCROLL</code> condition. If, at the beginning of a line, you set the YSCROLL to a value that doesn’t match the lowest 3 bits of the current line, the bad line will not happen. On such lines, VIC has nothing to render (as we just tricked it to not fetch character codes) and it will render the last byte of the video memory instead (e.g., contents of <code>$3fff</code>)</p>
<p>Let’s see what we can do with this technique.</p>
<h2 id="flexible-line-distance-fld">Flexible Line Distance (FLD)</h2>
<p>Flexible line distance is a technique that uses bad line suppression to scroll the display down by an arbitrary number of lines. I use it in the BINTRIS to scroll the whole screen down when leaving the writer part.</p>
<div class="img-columns-2">
<div class="img-column">
<div id="fld-container"></div>
<em>The FLD effect.</em>
</div>
<div class="img-column">
<img style="display:block" width="100%" class="img-pixelated" src="/images/bintris/bintris-writer-fld.gif" /> <em>Vertical scrolling.</em>
</div>
</div>
<p>To scroll by N lines, simply trigger a raster IRQ at the top of the screen (say on line 46) and suppress N bad lines. Here’s how you might do this in C-like pseudo code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">// YSCROLL is mapped to $d011</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">// RASTER is mapped to $d012</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="cf">while</span>(!new_frame()) {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="co">// do nothing</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">YSCROLL = <span class="bn">0x1B</span>;  <span class="co">// default YSCROLL value (%111)</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">// wait for FLD start line</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="cf">while</span> (RASTER != <span class="bn">0x40</span>) {</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    <span class="co">// do nothing</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; num_fld_lines; i++) {</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    <span class="dt">uint8_t</span> cur_raster = RASTER;</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    <span class="co">// wait for next next line</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">    <span class="cf">while</span> (cur_raster == RASTER) {</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">        <span class="co">// do nothing</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    <span class="co">// skip over bad line by manipulating YSCROLL</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">    YSCROLL = ((YSCROLL + <span class="dv">1</span>) &amp; <span class="dv">7</span>) | <span class="bn">0x18</span>;</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">}</a></code></pre></div>
<p>I found <a href="http://codebase64.org/doku.php?id=base:fld">working FLD code in 6502 assembly</a> from codebase64.org. I tested it by porting it to KickAssembler and running it on VICE.</p>
<h2 id="skipping-bad-lines">Skipping Bad Lines</h2>
<p>As discussed above, it’s possible to vertically scroll down the whole screen by manipulating the YSCROLL register at appropriate times. However, vertical scrolling is not the only reason why you might want to skip bad lines. Recall from the Bad Lines section that on a bad line, the CPU can run only 20-23 cycles worth of machine code. <em>(NB: although many tutorials say that you have 23 CPU cycles on a bad line, in practice you really only have 20-22 cycles to work with. I might write a separate article about this topic later on.)</em></p>
<p>The situation gets even worse if there are any sprites on a bad line. Also, the more sprites you have, the fewer CPU cycles are available. Here’s a simplified formula for evaluating how many cycles you can spend on a bad line with sprites:</p>
<p><span class="math inline"><em>n</em><em>u</em><em>m</em>_<em>c</em><em>y</em><em>c</em><em>l</em><em>e</em><em>s</em> = 23 − (3 + 2 * <em>n</em><em>u</em><em>m</em>_<em>s</em><em>p</em><em>r</em><em>i</em><em>t</em><em>e</em><em>s</em>)</span></p>
<p><em>(NB: This is a bit simplified, see <a href="http://www.antimon.org/dl/c64/code/missing.txt">Missing Cycles</a> for details.)</em></p>
<p>Let’s say you have enabled sprites 0-3 and they all hit a bad line. Now you have only 12 cycles to spare on your fancy raster routine (or in practice, more like 10 cycles.)</p>
<p>Ten cycles is not all that much. For example, say you want to load and store some values. Here’s all you can run during a single bad line:</p>
<pre><code>LDA abs_addr        (4 cycles)
STA abs_addr        (4 cycles)
NOP                 (2 cycles)</code></pre>
<p>The logo warp effect in BINTRIS is implemented using sprites by encoding the logo pixels into 4 separate sprites. The line-by-line warp is implemented by setting the x-coordinate of each sprite to a new value on every raster line the logo spans. Here’s a close up of this effect:</p>
<div class="img-columns-2">
<img class="img-column img-pixelated"  width="100%" src="/images/bintris/bintris-logo-wobble.gif" />
<div class="img-column">
<div id="logo-wobble-closeup-container"></div>
</div>
</div>
<p>To set the the horizontal location of each sprite, we’d need to do this for every raster line the sprites span:</p>
<pre><code>// At the beginning of a raster line
.for (var y 0; y &lt; 21; y++) {
    lda spritex + y*4 + 0   // sprite 0 x-coord
    sta $d000+0
    lda spritex + y*4 + 1   // sprite 1 x-coord
    sta $d000+2
    lda spritex + y*4 + 2   // sprite 2 x-coord
    sta $d000+4
    lda spritex + y*4 + 3   // sprite 3 x-coord
    sta $d000+6
    // + waste cycles until we&#39;re at the beginning of the next
    //   raster line
}</code></pre>
<p>That’s 32 CPU cycles per line. The sprites fall on a few bad lines and on these scanlines there’s only 10 cycles to spare. Sure, it’s possible to optimize the sprite x-coordinate stores down to 24 cycles with self-modifying code but 10 cycles doesn’t seem possible.</p>
<p>Without bad lines, there’s 52 cycles (=63-11 to account for 4 sprites) per scanline which is more than enough to move all the four sprites horizontally.</p>
<p>If only there were no bad lines..</p>
<p>You guessed it, right? If bad lines are suppressed for the duration of the logo, there will be plenty of cycles to move the sprites. Bad line suppression can be done by manipulating the YSCROLL register just as we did with FLD:</p>
<pre><code>
// Note: waste_cycles(c) is a macro that inserts the right
// amount of NOPs and BITs to burn &#39;c&#39; clock cycles.
.for (var y = 0; y &lt; 21; y++) {
    .var cycles = 63
    // skip bad line with FLD
    .var rasty = SPRITE_LOGO_YSTART + y
    .eval cycles = cycles - 3 - 8 // sprite overhead
    // Suppress bad line
    lda #$18 | ((rasty+1) &amp; %111)
    sta $d011
    .eval cycles = cycles - 6

    lda spritex + y*4 + 0
    ldx spritex + y*4 + 1
    ldy spritex + y*4 + 2
    .eval cycles -= 3*4

    sta $d000+0
    stx $d000+2
    sty $d000+4
    .eval cycles -= 4*3

    lda spritex + y*4 + 3
    sta $d000+6
    .eval cycles -= 8
    waste_cycles(cycles)
}</code></pre>
<p>If you’re interested in playing with the sprite warp, I pushed its <a href="https://github.com/nurpax/c64-samples/tree/master/sprite_warp">standalone source code up on github</a>. Here’s how it looks like:</p>
<p><img class="img-medium-wide" src="/images/bintris/sprite-wobble-standalone.png"/></p>
<script type="text/javascript">
var diagram, fld;

$(function () {
    diagram = new diagrams.TimingDiagram('cycle-timing-container');
    diagram.mount();

    fld = new diagrams.FldDiagram('fld-container');
    fld.mount();

    warpCrop = new diagrams.LogoWarpCrop('logo-wobble-closeup-container');
    warpCrop.mount();
})
</script>
<h2 id="next-in-series">Next in series</h2>
<p>My next BINTRIS post will wrap up the article series.</p>]]></summary>
</entry>
<entry>
    <title>Break down of a C64 demo effect</title>
    <link href="http://nurpax.github.com/posts/2018-06-07-c64-filled-sinewave.html" />
    <id>http://nurpax.github.com/posts/2018-06-07-c64-filled-sinewave.html</id>
    <published>2018-06-07T00:00:00Z</published>
    <updated>2018-06-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>So I recently made this little sinewave demo effect on the Commodore 64:</p>
<p><img class="img-pixelated img-medium-wide" src="/images/c64/sine/sinewave-gifanim-2018-05-31.gif" /></p>
<p>This generated a lot of lively discussion on <a href="https://twitter.com/nurpax/status/1002288831511580672">twitter</a> and <a href="https://www.reddit.com/r/c64/comments/8o9aoh/some_charset_hacking_from_last_week/">/r/c64</a>. A bunch of people were curious as to how it works and I promised to explain it on my blog.</p>
<p>The main idea is to use character mode with a custom character set. I sample y-coordinate every 8 pixels to produce a list of line segments <span class="math inline">[(0, <em>y</em><sub>0</sub>), (8, <em>y</em><sub>1</sub>), (16, <em>y</em><sub>2</sub>), ..., (320, <em>y</em><sub>40</sub>)]</span>. In the below animation, you can see these line segments along with blue rectangles that signify which 8x8 character blocks intersect the line segments.</p>
<p><img class="img-medium-wide" src="/images/c64/sine/sinewave-block-cover.gif"/></p>
<p>The goal then is to fill all the pixels below a line segment with light blue and everything above it with dark blue.</p>
<p>Here’s how you might code this up in Python:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co"># Compute sine wave by stepping every 8th pixel</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">ypos <span class="op">=</span> [sinewave(phase, x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">+</span> <span class="dv">8</span>, <span class="dv">8</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">clear_screen(BLUE)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="co"># Loop through each line segment</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    x0 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    x1 <span class="op">=</span> x <span class="op">*</span> <span class="dv">8</span> <span class="op">+</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    y0 <span class="op">=</span> ypos[x]</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    y1 <span class="op">=</span> ypos[x <span class="op">+</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="co"># Fill everything below the (x0,y0)-(x1,y1) line segment</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="co"># with LIGHT_BLUE</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    fill_polygon([(x0, y0), (x1, y1), (x1, <span class="dv">200</span>), (x0, <span class="dv">200</span>)], LIGHT_BLUE)</a></code></pre></div>
<p>Unfortunately using a polygon fill routine in C64 bitmap mode would be pretty slow. To make this run fast, I precompute the different ways a line segment can intersect 8x8 character blocks using an edge function rasterizer written in Python. Here’s an image that shows some combinations of a line hitting 3 vertically stacked 8x8 blocks:</p>
<p><img class="img-pixelated img-smallest" src="/images/c64/sine/sinewave-fill-closeup.gif"/></p>
<p>Here’s Python code for the block rasterizer:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"> <span class="co"># one bit of subpixel precision</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"> subpix <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">def</span> mk8x8(yoffs, a, b, c):</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    arr <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">8</span>)]</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        yy <span class="op">=</span> (y <span class="op">+</span> yoffs) <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">            xx <span class="op">=</span> x <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">            <span class="cf">if</span> a <span class="op">*</span> xx <span class="op">+</span> b <span class="op">*</span> yy <span class="op">+</span> c <span class="op">&gt;=</span> <span class="fl">0.0</span>:</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">                arr[x <span class="op">+</span> y <span class="op">*</span> <span class="dv">8</span>] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="cf">return</span> arr</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="kw">def</span> construct_fill_table():</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">    x0 <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">    x1 <span class="op">=</span> <span class="dv">8</span> <span class="op">*</span> subpix</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    fill_tbl <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span> <span class="op">*</span> subpix)]</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    <span class="cf">for</span> y0 <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix):</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">        fill_tbl[y0] <span class="op">=</span> [<span class="va">None</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">8</span> <span class="op">*</span> subpix)]</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">        <span class="cf">for</span> yi1 <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">4</span> <span class="op">*</span> subpix, <span class="dv">4</span> <span class="op">*</span> subpix):</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">            y1 <span class="op">=</span> y0 <span class="op">+</span> yi1</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">            a <span class="op">=</span> <span class="op">-</span>(y1 <span class="op">-</span> y0)</a>
<a class="sourceLine" id="cb2-23" data-line-number="23">            b <span class="op">=</span> (x1 <span class="op">-</span> x0)</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">            c <span class="op">=</span> <span class="op">-</span>(a <span class="op">*</span> x0 <span class="op">+</span> b <span class="op">*</span> y0)</a>
<a class="sourceLine" id="cb2-25" data-line-number="25">            chr_a <span class="op">=</span> mk8x8(<span class="op">-</span><span class="dv">8</span>, a, b, c)</a>
<a class="sourceLine" id="cb2-26" data-line-number="26">            chr_b <span class="op">=</span> mk8x8(<span class="dv">0</span>, a, b, c)</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">            chr_c <span class="op">=</span> mk8x8(<span class="dv">8</span>, a, b, c)</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">            fill_tbl[y0][yi1 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix] <span class="op">=</span> [chr_a, chr_b, chr_c]</a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    <span class="cf">return</span> fill_tbl</a></code></pre></div>
<p>A Python renderer using the table generated <code>construct_fill_table()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">def</span> draw_fills(ypos):</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="cf">for</span> xi <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">320</span> <span class="op">//</span> <span class="dv">8</span>):</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        x <span class="op">=</span> xi <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        y0 <span class="op">=</span> <span class="bu">int</span>((ypos[xi] <span class="op">*</span> subpix))</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        y1 <span class="op">=</span> <span class="bu">int</span>((ypos[xi <span class="op">+</span> <span class="dv">1</span>] <span class="op">*</span> subpix))</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        yy0 <span class="op">=</span> y0 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        yy1 <span class="op">=</span> y1 <span class="op">&amp;</span> <span class="op">~</span>(<span class="dv">8</span> <span class="op">*</span> subpix <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        y0 <span class="op">-=</span> yy0</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        y1 <span class="op">-=</span> yy0</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        chrs <span class="op">=</span> fill_tbl[y0][y1 <span class="op">-</span> y0 <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> subpix]</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">-</span> <span class="dv">8</span>, chrs[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">        blit_8x8(x, yy0 <span class="op">/</span> subpix, chrs[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">        blit_8x8(x, yy0 <span class="op">/</span> subpix <span class="op">+</span> <span class="dv">8</span>, chrs[<span class="dv">2</span>])</a></code></pre></div>
<p>Note that in the above code, each entry in the <code>fill_tbl</code> 2d-array is a list 3 character bitmaps. A character bitmap is a 64 entry list of zeros and ones. To make use of this on the C64, you need to turn this data into two separate arrays: the actual character set and an array indexed by <span class="math inline"><em>y</em>0</span>, <span class="math inline"><em>y</em>1</span> that returns a list of 3 character indices.</p>
<p>Here’s how these two tables look like. First the charset:</p>
<p><img class="img-pixelated img-small" src="/images/c64/sine/charset-16x16.png" /></p>
<p>..and the character index table (<code>$20</code> is the space character, ie., an empty block, <code>$a0</code> is a fully filled 8x8 block):</p>
<pre><code>y0y1tbl:
    .byte $00, $a0, $a0, $a0
    .byte $02, $0e, $a0, $a0
    .byte $0f, $10, $a0, $a0
    .byte $1b, $24, $a0, $a0
... 252 more entries ...</code></pre>
<p>If you’d run the C64 equivalent of the above Python routine on the default charset, you’d see something like this:</p>
<p><img class="img-pixelated img-medium-wide" src="/images/c64/sine/sinewave-sans-charset.gif" /></p>
<p>Since I have full control over the sine animation, I choose animation parameters that make the line segments behave “nicely”. Niceness is defined as follows: let <span class="math inline">(<em>x</em>0, <em>y</em>0)</span> and <span class="math inline">(<em>x</em>0 + 8, <em>y</em>1)</span> be the end points of a line segment. The segment behaves “nicely” if it satisfies the following condition: <span class="math inline">|<em>y</em>0 − <em>y</em>1| &lt; <em>c</em></span> (where <span class="math inline"><em>c</em></span> is some small number, in my case 8). This is required in order to keep the <code>fill_tbl</code> at a reasonable size and to limit the number of unique 8x8 characters (since the hardware character set is only 256 entries).</p>
<p>That’s about all there is to it, I guess.</p>]]></summary>
</entry>
<entry>
    <title>BINTRIS C64 game screen rendering (series part 4)</title>
    <link href="http://nurpax.github.com/posts/2018-05-30-bintris-on-c64-part-4.html" />
    <id>http://nurpax.github.com/posts/2018-05-30-bintris-on-c64-part-4.html</id>
    <published>2018-05-30T00:00:00Z</published>
    <updated>2018-05-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(Looking for the BINTRIS C64 disk image? Find it <a href="/posts/2018-05-21-bintris-on-c64-part-2.html">here</a>.)</p>
<p>Let’s take a look at how the actual BINTRIS game screen is rendered. This is the first thing I implemented for this projet (after maybe 25 years of C64 dev hiatus) and in hindsight I think it could’ve been simpler with less sprites and more charset manipulation.</p>
<p>The graphic elements of this screen are:</p>
<ul>
<li>The BINTRIS logo at the top (4 multicolor sprites)</li>
<li>Currently falling bit (one single color sprite)</li>
<li>Current score (3 multicolor sprites, one sprite per number, max 3 digits)</li>
<li>The collapse noise animation (3 multicolor sprites)</li>
<li>The game board rendered in text mode (one character per bit)</li>
<li>Decimal targets (standard text)</li>
</ul>
<p>Here’s how it looks like (with red &amp; green rectangles highlighting sprite locations):</p>
<p><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
    "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 384 272"><style>text { font-family: "arial";}

.pointsample { image-rendering: pixelated; }</style><g><image width="384.0" height="272.0" class="pointsample" xlink:href="/images/bintris/gamescreen-collapse.gif" /><rect width="1120.0" height="1.0" x="-8.0" y="26.0" fill="#393" /><rect width="1120.0" height="1.0" x="-8.0" y="62.0" fill="#933" /><rect width="24.0" height="1.0" x="72.0" y="110.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="96.0" y="110.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="131.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="72.0" y="110.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="158.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="96.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="179.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="72.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="96.0" y="158.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="120.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="96.0" y="179.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="96.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="120.0" y="158.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="144.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="120.0" y="179.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="120.0" y="158.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="158.0" y="68.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="182.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="158.0" y="89.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="158.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="182.0" y="68.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="206.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="182.0" y="89.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="182.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="206.0" y="68.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="230.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="206.0" y="89.0" fill="#ff4422" /><rect width="1.0" height="21.0" x="206.0" y="68.0" fill="#ff4422" /><rect width="24.0" height="1.0" x="72.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="96.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="72.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="72.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="96.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="120.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="96.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="96.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="120.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="144.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="120.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="120.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="144.0" y="36.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="168.0" y="36.0" fill="#44ff22" /><rect width="24.0" height="1.0" x="144.0" y="57.0" fill="#44ff22" /><rect width="1.0" height="21.0" x="144.0" y="36.0" fill="#44ff22" /><g transform="matrix(0.6,0.0,0.0,0.6,28.0,92.0)"><g id="title"><rect width="14.0" height="14.0" x="70.0" y="229.0" fill="#393" /><text x="89.0" y="242.0" fill="white">logo irq line </text></g></g><g transform="matrix(0.6,0.0,0.0,0.6,64.0,92.0)"><g id="title"><rect width="14.0" height="14.0" x="160.0" y="229.0" fill="#933" /><text x="179.0" y="242.0" fill="white">board irq line</text></g></g></g></svg></p>
<p>That’s 11 sprites in total. As the C64 hardware only supports 8 sprites, we need to multiplex hardware sprites with raster interrupts:</p>
<ol type="1">
<li>Program sprites 0-3 for the BINTRIS logo at the top of the frame, before the raster beam reaches the logo.</li>
<li>Once the raster beam’s past the logo, program sprites 0-6 to be used for the current score (3 sprites), falling bit (1 sprite), and the collapse noise animation (3 sprites).</li>
</ol>
<p>Note that not all these sprites are always enabled: the noise animation sprites are enabled only when rows are collapsing, the falling bit is turned off during the noise animation, and if the current score is, say, less than 10, we need only one sprite for the score digits.</p>
<p>I did skip over some details, though. The biggest omission is the BINTRIS logo level up warp effect. It looks something like this:</p>
<div class="screenshot">
<img src="/images/bintris/logowarp.gif" title="BINTRIS logo warp gif" class="img-pixelated" width="300" height="80" />
</div>
<p>This effect manipulates the logo sprite X locations on each scanline to achieve the line-by-line distortion effect. It might not look like much in this .gif capture, but as far as timing sensitive code goes, this is by far the trickiest routine in the game. There will be a blog about this effect later in the series.</p>
<p>The game board is rendered using text mode characters. The charset contains an 8x8 filled rectangle which is used to clear the board area on game start or on level up. Per-frame rendering only sets the color of each such block.</p>
<p>Board state is represented by two arrays: <code>setbit</code> and <code>bits</code> (16 bytes each). The <code>setbit</code> array encodes which cells contain a block (one bit per column, one byte per row). The <code>bits</code> array containts the actual bit values. The code to render the board is pretty simple with these two arrays:</p>
<pre><code>piececol:
    .byte DARK_GRAY, BLACK, DARK_GRAY, WHITE

.macro drawboard(colorbuf) {
    .const tsetbits = $62
    .const tbits = $63
    // Note unrolling by 16 is simply due to lazyness, it&#39;s not
    // necessary for performance.
    .for (var y = 0; y &lt; 16; y++) {
        lda setbit+y
        sta tsetbits
        lda bits+y
        sta tbits
        ldy bitwidth     // current board bitwidth
xloop:
        lda tbits
        and #1
        lsr tsetbits
        rol
        tax
        lda piececol, x
        lsr tbits
        sta colorbuf+[(y+1)*40], y
        dey
        bne xloop
    }
}</code></pre>
<p>That’s roughly 31 clock cycles per block. In the <a href="http://nurpax.com/bintris">BINTRIS web version</a> each block is a bunch of SVG <code>&lt;rect&gt;</code> elements wrapped in a <code>&lt;g&gt;</code> element wrapped in a <code>React.PureComponent</code>. I’m pretty sure the cost to render a block in the web version is at least a couple of orders of magnitude higher. That’s not React’s fault of course, I should totally get the blame for abusing React for gamedev like this.</p>
<h2 id="next-in-series">Next in series</h2>
<p>The next post will discuss vertical scrolling with flexible line distance (FLD) and will also go into details on how the BINTRIS logo warp was done.</p>]]></summary>
</entry>
<entry>
    <title>Handy command-line incantations</title>
    <link href="http://nurpax.github.com/posts/2018-05-28-handy-command-line-incantations.html" />
    <id>http://nurpax.github.com/posts/2018-05-28-handy-command-line-incantations.html</id>
    <published>2018-05-28T00:00:00Z</published>
    <updated>2018-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Just some command line copy&amp;pastes that I always tend to forget. Mainly ImageMagick and ffmpeg.</p>
<h2 id="image-files">Image files</h2>
<p>View image width, height &amp; format:</p>
<pre><code>identify &lt;imagefile&gt;</code></pre>
<p>Make a .gif anim from a collection of image files:</p>
<pre><code>convert -loop 0 -delay 300 image1.png image2.png image3.png result.gif</code></pre>
<p>Resize an image with point-sampling while NOT preserving aspect-ratio (ImageMagick forces original aspect ratio without warning):</p>
<pre><code>convert input.png -sample 640x200! output.png</code></pre>
<p>Double image width and height with point-sampling:</p>
<pre><code>convert in.png -filter point -resize 200% out.png</code></pre>
<p>Stack two images side by side:</p>
<pre><code>convert left.png right.png -gravity center +append out.png</code></pre>
<p>Crop the input image and then make a .gif (<code>+repage</code> is required to actually crop the output image dimensions too):</p>
<pre><code># 104x30 is the size of the crop rectangle
# +62+22 is an offset to the top/left corner of the crop area
convert -crop 104x30+62+22 +repage -loop 0 -delay 300 image?.png result.gif</code></pre>
<h2 id="video-files">Video files</h2>
<p>View video file format details:</p>
<pre><code>ffprobe &lt;videofile&gt;</code></pre>
<p>Convert a VICE video capture .avi (in DivX format) to MP4:</p>
<pre><code>ffmpeg -i screencap.avi -c:v libx264 -crf 19 -preset slow -c:a libvo_aacenc -b:a 192k -ac 2 out.mp4
# or a simpler version (save to .avi the lossless FFV1 codec in VICE)
ffmpeg -i screencap.avi -c:v libx264 -pix_fmt yuv420p -preset veryslow -crf 5 foo.mp4</code></pre>
<p>Convert a series of image files into an MP4:</p>
<pre><code>ffmpeg -r 25 -i &#39;frame_%04d.png&#39; -c:v libx264 -vf fps=25 -pix_fmt yuv420p out.mp4</code></pre>
<p>Convert a MOV/MP4 into a series of image files:</p>
<pre><code>ffmpeg -i input.mov output_%04d.png
# with scaling to 320x240 resolution
ffmpeg -i input.mov -vf scale=320:240 output_%04d.png</code></pre>
<p>Convert a MOV file into an MP4 (e.g., for uploading Quicktime screencaps to Twitter):</p>
<pre><code>ffmpeg -i movie.mov -vcodec copy -acodec copy out.mp4</code></pre>]]></summary>
</entry>

</feed>
